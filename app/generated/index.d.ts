
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Lawyer
 * 
 */
export type Lawyer = $Result.DefaultSelection<Prisma.$LawyerPayload>
/**
 * Model ConseilJuridique
 * 
 */
export type ConseilJuridique = $Result.DefaultSelection<Prisma.$ConseilJuridiquePayload>
/**
 * Model Redaction
 * 
 */
export type Redaction = $Result.DefaultSelection<Prisma.$RedactionPayload>
/**
 * Model ResolutionLitige
 * 
 */
export type ResolutionLitige = $Result.DefaultSelection<Prisma.$ResolutionLitigePayload>
/**
 * Model ServiceParDomaine
 * 
 */
export type ServiceParDomaine = $Result.DefaultSelection<Prisma.$ServiceParDomainePayload>
/**
 * Model Preventifs
 * 
 */
export type Preventifs = $Result.DefaultSelection<Prisma.$PreventifsPayload>
/**
 * Model ValeurAjouter
 * 
 */
export type ValeurAjouter = $Result.DefaultSelection<Prisma.$ValeurAjouterPayload>
/**
 * Model Friends
 * 
 */
export type Friends = $Result.DefaultSelection<Prisma.$FriendsPayload>
/**
 * Model FriendLaw
 * 
 */
export type FriendLaw = $Result.DefaultSelection<Prisma.$FriendLawPayload>
/**
 * Model Contrat
 * 
 */
export type Contrat = $Result.DefaultSelection<Prisma.$ContratPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ClientNotification
 * 
 */
export type ClientNotification = $Result.DefaultSelection<Prisma.$ClientNotificationPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model ClientContact
 * 
 */
export type ClientContact = $Result.DefaultSelection<Prisma.$ClientContactPayload>
/**
 * Model Diplome
 * 
 */
export type Diplome = $Result.DefaultSelection<Prisma.$DiplomePayload>
/**
 * Model Experience
 * 
 */
export type Experience = $Result.DefaultSelection<Prisma.$ExperiencePayload>
/**
 * Model Calendar
 * 
 */
export type Calendar = $Result.DefaultSelection<Prisma.$CalendarPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lawyer`: Exposes CRUD operations for the **Lawyer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lawyers
    * const lawyers = await prisma.lawyer.findMany()
    * ```
    */
  get lawyer(): Prisma.LawyerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conseilJuridique`: Exposes CRUD operations for the **ConseilJuridique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConseilJuridiques
    * const conseilJuridiques = await prisma.conseilJuridique.findMany()
    * ```
    */
  get conseilJuridique(): Prisma.ConseilJuridiqueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.redaction`: Exposes CRUD operations for the **Redaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redactions
    * const redactions = await prisma.redaction.findMany()
    * ```
    */
  get redaction(): Prisma.RedactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resolutionLitige`: Exposes CRUD operations for the **ResolutionLitige** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResolutionLitiges
    * const resolutionLitiges = await prisma.resolutionLitige.findMany()
    * ```
    */
  get resolutionLitige(): Prisma.ResolutionLitigeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceParDomaine`: Exposes CRUD operations for the **ServiceParDomaine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceParDomaines
    * const serviceParDomaines = await prisma.serviceParDomaine.findMany()
    * ```
    */
  get serviceParDomaine(): Prisma.ServiceParDomaineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.preventifs`: Exposes CRUD operations for the **Preventifs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Preventifs
    * const preventifs = await prisma.preventifs.findMany()
    * ```
    */
  get preventifs(): Prisma.PreventifsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.valeurAjouter`: Exposes CRUD operations for the **ValeurAjouter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ValeurAjouters
    * const valeurAjouters = await prisma.valeurAjouter.findMany()
    * ```
    */
  get valeurAjouter(): Prisma.ValeurAjouterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.friends`: Exposes CRUD operations for the **Friends** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friends
    * const friends = await prisma.friends.findMany()
    * ```
    */
  get friends(): Prisma.FriendsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.friendLaw`: Exposes CRUD operations for the **FriendLaw** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FriendLaws
    * const friendLaws = await prisma.friendLaw.findMany()
    * ```
    */
  get friendLaw(): Prisma.FriendLawDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contrat`: Exposes CRUD operations for the **Contrat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contrats
    * const contrats = await prisma.contrat.findMany()
    * ```
    */
  get contrat(): Prisma.ContratDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientNotification`: Exposes CRUD operations for the **ClientNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientNotifications
    * const clientNotifications = await prisma.clientNotification.findMany()
    * ```
    */
  get clientNotification(): Prisma.ClientNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientContact`: Exposes CRUD operations for the **ClientContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientContacts
    * const clientContacts = await prisma.clientContact.findMany()
    * ```
    */
  get clientContact(): Prisma.ClientContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.diplome`: Exposes CRUD operations for the **Diplome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diplomes
    * const diplomes = await prisma.diplome.findMany()
    * ```
    */
  get diplome(): Prisma.DiplomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.experience`: Exposes CRUD operations for the **Experience** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Experiences
    * const experiences = await prisma.experience.findMany()
    * ```
    */
  get experience(): Prisma.ExperienceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendar`: Exposes CRUD operations for the **Calendar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calendars
    * const calendars = await prisma.calendar.findMany()
    * ```
    */
  get calendar(): Prisma.CalendarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Client: 'Client',
    Lawyer: 'Lawyer',
    ConseilJuridique: 'ConseilJuridique',
    Redaction: 'Redaction',
    ResolutionLitige: 'ResolutionLitige',
    ServiceParDomaine: 'ServiceParDomaine',
    Preventifs: 'Preventifs',
    ValeurAjouter: 'ValeurAjouter',
    Friends: 'Friends',
    FriendLaw: 'FriendLaw',
    Contrat: 'Contrat',
    Notification: 'Notification',
    ClientNotification: 'ClientNotification',
    Contact: 'Contact',
    ClientContact: 'ClientContact',
    Diplome: 'Diplome',
    Experience: 'Experience',
    Calendar: 'Calendar',
    Account: 'Account',
    Session: 'Session',
    Post: 'Post',
    VerificationToken: 'VerificationToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "client" | "lawyer" | "conseilJuridique" | "redaction" | "resolutionLitige" | "serviceParDomaine" | "preventifs" | "valeurAjouter" | "friends" | "friendLaw" | "contrat" | "notification" | "clientNotification" | "contact" | "clientContact" | "diplome" | "experience" | "calendar" | "account" | "session" | "post" | "verificationToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Lawyer: {
        payload: Prisma.$LawyerPayload<ExtArgs>
        fields: Prisma.LawyerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LawyerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawyerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LawyerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawyerPayload>
          }
          findFirst: {
            args: Prisma.LawyerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawyerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LawyerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawyerPayload>
          }
          findMany: {
            args: Prisma.LawyerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawyerPayload>[]
          }
          create: {
            args: Prisma.LawyerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawyerPayload>
          }
          createMany: {
            args: Prisma.LawyerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LawyerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawyerPayload>
          }
          update: {
            args: Prisma.LawyerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawyerPayload>
          }
          deleteMany: {
            args: Prisma.LawyerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LawyerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LawyerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LawyerPayload>
          }
          aggregate: {
            args: Prisma.LawyerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLawyer>
          }
          groupBy: {
            args: Prisma.LawyerGroupByArgs<ExtArgs>
            result: $Utils.Optional<LawyerGroupByOutputType>[]
          }
          count: {
            args: Prisma.LawyerCountArgs<ExtArgs>
            result: $Utils.Optional<LawyerCountAggregateOutputType> | number
          }
        }
      }
      ConseilJuridique: {
        payload: Prisma.$ConseilJuridiquePayload<ExtArgs>
        fields: Prisma.ConseilJuridiqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConseilJuridiqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConseilJuridiquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConseilJuridiqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConseilJuridiquePayload>
          }
          findFirst: {
            args: Prisma.ConseilJuridiqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConseilJuridiquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConseilJuridiqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConseilJuridiquePayload>
          }
          findMany: {
            args: Prisma.ConseilJuridiqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConseilJuridiquePayload>[]
          }
          create: {
            args: Prisma.ConseilJuridiqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConseilJuridiquePayload>
          }
          createMany: {
            args: Prisma.ConseilJuridiqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConseilJuridiqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConseilJuridiquePayload>
          }
          update: {
            args: Prisma.ConseilJuridiqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConseilJuridiquePayload>
          }
          deleteMany: {
            args: Prisma.ConseilJuridiqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConseilJuridiqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConseilJuridiqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConseilJuridiquePayload>
          }
          aggregate: {
            args: Prisma.ConseilJuridiqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConseilJuridique>
          }
          groupBy: {
            args: Prisma.ConseilJuridiqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConseilJuridiqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConseilJuridiqueCountArgs<ExtArgs>
            result: $Utils.Optional<ConseilJuridiqueCountAggregateOutputType> | number
          }
        }
      }
      Redaction: {
        payload: Prisma.$RedactionPayload<ExtArgs>
        fields: Prisma.RedactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RedactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RedactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedactionPayload>
          }
          findFirst: {
            args: Prisma.RedactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RedactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedactionPayload>
          }
          findMany: {
            args: Prisma.RedactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedactionPayload>[]
          }
          create: {
            args: Prisma.RedactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedactionPayload>
          }
          createMany: {
            args: Prisma.RedactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RedactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedactionPayload>
          }
          update: {
            args: Prisma.RedactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedactionPayload>
          }
          deleteMany: {
            args: Prisma.RedactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RedactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RedactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedactionPayload>
          }
          aggregate: {
            args: Prisma.RedactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRedaction>
          }
          groupBy: {
            args: Prisma.RedactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RedactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RedactionCountArgs<ExtArgs>
            result: $Utils.Optional<RedactionCountAggregateOutputType> | number
          }
        }
      }
      ResolutionLitige: {
        payload: Prisma.$ResolutionLitigePayload<ExtArgs>
        fields: Prisma.ResolutionLitigeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResolutionLitigeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResolutionLitigePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResolutionLitigeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResolutionLitigePayload>
          }
          findFirst: {
            args: Prisma.ResolutionLitigeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResolutionLitigePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResolutionLitigeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResolutionLitigePayload>
          }
          findMany: {
            args: Prisma.ResolutionLitigeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResolutionLitigePayload>[]
          }
          create: {
            args: Prisma.ResolutionLitigeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResolutionLitigePayload>
          }
          createMany: {
            args: Prisma.ResolutionLitigeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ResolutionLitigeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResolutionLitigePayload>
          }
          update: {
            args: Prisma.ResolutionLitigeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResolutionLitigePayload>
          }
          deleteMany: {
            args: Prisma.ResolutionLitigeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResolutionLitigeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResolutionLitigeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResolutionLitigePayload>
          }
          aggregate: {
            args: Prisma.ResolutionLitigeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResolutionLitige>
          }
          groupBy: {
            args: Prisma.ResolutionLitigeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResolutionLitigeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResolutionLitigeCountArgs<ExtArgs>
            result: $Utils.Optional<ResolutionLitigeCountAggregateOutputType> | number
          }
        }
      }
      ServiceParDomaine: {
        payload: Prisma.$ServiceParDomainePayload<ExtArgs>
        fields: Prisma.ServiceParDomaineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceParDomaineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceParDomainePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceParDomaineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceParDomainePayload>
          }
          findFirst: {
            args: Prisma.ServiceParDomaineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceParDomainePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceParDomaineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceParDomainePayload>
          }
          findMany: {
            args: Prisma.ServiceParDomaineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceParDomainePayload>[]
          }
          create: {
            args: Prisma.ServiceParDomaineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceParDomainePayload>
          }
          createMany: {
            args: Prisma.ServiceParDomaineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceParDomaineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceParDomainePayload>
          }
          update: {
            args: Prisma.ServiceParDomaineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceParDomainePayload>
          }
          deleteMany: {
            args: Prisma.ServiceParDomaineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceParDomaineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceParDomaineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceParDomainePayload>
          }
          aggregate: {
            args: Prisma.ServiceParDomaineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceParDomaine>
          }
          groupBy: {
            args: Prisma.ServiceParDomaineGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceParDomaineGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceParDomaineCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceParDomaineCountAggregateOutputType> | number
          }
        }
      }
      Preventifs: {
        payload: Prisma.$PreventifsPayload<ExtArgs>
        fields: Prisma.PreventifsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PreventifsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventifsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PreventifsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventifsPayload>
          }
          findFirst: {
            args: Prisma.PreventifsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventifsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PreventifsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventifsPayload>
          }
          findMany: {
            args: Prisma.PreventifsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventifsPayload>[]
          }
          create: {
            args: Prisma.PreventifsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventifsPayload>
          }
          createMany: {
            args: Prisma.PreventifsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PreventifsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventifsPayload>
          }
          update: {
            args: Prisma.PreventifsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventifsPayload>
          }
          deleteMany: {
            args: Prisma.PreventifsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PreventifsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PreventifsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PreventifsPayload>
          }
          aggregate: {
            args: Prisma.PreventifsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePreventifs>
          }
          groupBy: {
            args: Prisma.PreventifsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PreventifsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PreventifsCountArgs<ExtArgs>
            result: $Utils.Optional<PreventifsCountAggregateOutputType> | number
          }
        }
      }
      ValeurAjouter: {
        payload: Prisma.$ValeurAjouterPayload<ExtArgs>
        fields: Prisma.ValeurAjouterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ValeurAjouterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValeurAjouterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ValeurAjouterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValeurAjouterPayload>
          }
          findFirst: {
            args: Prisma.ValeurAjouterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValeurAjouterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ValeurAjouterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValeurAjouterPayload>
          }
          findMany: {
            args: Prisma.ValeurAjouterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValeurAjouterPayload>[]
          }
          create: {
            args: Prisma.ValeurAjouterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValeurAjouterPayload>
          }
          createMany: {
            args: Prisma.ValeurAjouterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ValeurAjouterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValeurAjouterPayload>
          }
          update: {
            args: Prisma.ValeurAjouterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValeurAjouterPayload>
          }
          deleteMany: {
            args: Prisma.ValeurAjouterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ValeurAjouterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ValeurAjouterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValeurAjouterPayload>
          }
          aggregate: {
            args: Prisma.ValeurAjouterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateValeurAjouter>
          }
          groupBy: {
            args: Prisma.ValeurAjouterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ValeurAjouterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ValeurAjouterCountArgs<ExtArgs>
            result: $Utils.Optional<ValeurAjouterCountAggregateOutputType> | number
          }
        }
      }
      Friends: {
        payload: Prisma.$FriendsPayload<ExtArgs>
        fields: Prisma.FriendsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          findFirst: {
            args: Prisma.FriendsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          findMany: {
            args: Prisma.FriendsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>[]
          }
          create: {
            args: Prisma.FriendsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          createMany: {
            args: Prisma.FriendsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FriendsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          update: {
            args: Prisma.FriendsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          deleteMany: {
            args: Prisma.FriendsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FriendsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendsPayload>
          }
          aggregate: {
            args: Prisma.FriendsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriends>
          }
          groupBy: {
            args: Prisma.FriendsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendsCountArgs<ExtArgs>
            result: $Utils.Optional<FriendsCountAggregateOutputType> | number
          }
        }
      }
      FriendLaw: {
        payload: Prisma.$FriendLawPayload<ExtArgs>
        fields: Prisma.FriendLawFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendLawFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendLawPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendLawFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendLawPayload>
          }
          findFirst: {
            args: Prisma.FriendLawFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendLawPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendLawFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendLawPayload>
          }
          findMany: {
            args: Prisma.FriendLawFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendLawPayload>[]
          }
          create: {
            args: Prisma.FriendLawCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendLawPayload>
          }
          createMany: {
            args: Prisma.FriendLawCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FriendLawDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendLawPayload>
          }
          update: {
            args: Prisma.FriendLawUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendLawPayload>
          }
          deleteMany: {
            args: Prisma.FriendLawDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendLawUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FriendLawUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendLawPayload>
          }
          aggregate: {
            args: Prisma.FriendLawAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendLaw>
          }
          groupBy: {
            args: Prisma.FriendLawGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendLawGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendLawCountArgs<ExtArgs>
            result: $Utils.Optional<FriendLawCountAggregateOutputType> | number
          }
        }
      }
      Contrat: {
        payload: Prisma.$ContratPayload<ExtArgs>
        fields: Prisma.ContratFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContratFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContratFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratPayload>
          }
          findFirst: {
            args: Prisma.ContratFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContratFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratPayload>
          }
          findMany: {
            args: Prisma.ContratFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratPayload>[]
          }
          create: {
            args: Prisma.ContratCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratPayload>
          }
          createMany: {
            args: Prisma.ContratCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContratDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratPayload>
          }
          update: {
            args: Prisma.ContratUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratPayload>
          }
          deleteMany: {
            args: Prisma.ContratDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContratUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContratUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContratPayload>
          }
          aggregate: {
            args: Prisma.ContratAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContrat>
          }
          groupBy: {
            args: Prisma.ContratGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContratGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContratCountArgs<ExtArgs>
            result: $Utils.Optional<ContratCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ClientNotification: {
        payload: Prisma.$ClientNotificationPayload<ExtArgs>
        fields: Prisma.ClientNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientNotificationPayload>
          }
          findFirst: {
            args: Prisma.ClientNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientNotificationPayload>
          }
          findMany: {
            args: Prisma.ClientNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientNotificationPayload>[]
          }
          create: {
            args: Prisma.ClientNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientNotificationPayload>
          }
          createMany: {
            args: Prisma.ClientNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientNotificationPayload>
          }
          update: {
            args: Prisma.ClientNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientNotificationPayload>
          }
          deleteMany: {
            args: Prisma.ClientNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientNotificationPayload>
          }
          aggregate: {
            args: Prisma.ClientNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientNotification>
          }
          groupBy: {
            args: Prisma.ClientNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<ClientNotificationCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      ClientContact: {
        payload: Prisma.$ClientContactPayload<ExtArgs>
        fields: Prisma.ClientContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>
          }
          findFirst: {
            args: Prisma.ClientContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>
          }
          findMany: {
            args: Prisma.ClientContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>[]
          }
          create: {
            args: Prisma.ClientContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>
          }
          createMany: {
            args: Prisma.ClientContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>
          }
          update: {
            args: Prisma.ClientContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>
          }
          deleteMany: {
            args: Prisma.ClientContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientContactPayload>
          }
          aggregate: {
            args: Prisma.ClientContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientContact>
          }
          groupBy: {
            args: Prisma.ClientContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientContactCountArgs<ExtArgs>
            result: $Utils.Optional<ClientContactCountAggregateOutputType> | number
          }
        }
      }
      Diplome: {
        payload: Prisma.$DiplomePayload<ExtArgs>
        fields: Prisma.DiplomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiplomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiplomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>
          }
          findFirst: {
            args: Prisma.DiplomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiplomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>
          }
          findMany: {
            args: Prisma.DiplomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>[]
          }
          create: {
            args: Prisma.DiplomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>
          }
          createMany: {
            args: Prisma.DiplomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DiplomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>
          }
          update: {
            args: Prisma.DiplomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>
          }
          deleteMany: {
            args: Prisma.DiplomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiplomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiplomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiplomePayload>
          }
          aggregate: {
            args: Prisma.DiplomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiplome>
          }
          groupBy: {
            args: Prisma.DiplomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiplomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiplomeCountArgs<ExtArgs>
            result: $Utils.Optional<DiplomeCountAggregateOutputType> | number
          }
        }
      }
      Experience: {
        payload: Prisma.$ExperiencePayload<ExtArgs>
        fields: Prisma.ExperienceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExperienceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExperienceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          findFirst: {
            args: Prisma.ExperienceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExperienceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          findMany: {
            args: Prisma.ExperienceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>[]
          }
          create: {
            args: Prisma.ExperienceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          createMany: {
            args: Prisma.ExperienceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExperienceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          update: {
            args: Prisma.ExperienceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          deleteMany: {
            args: Prisma.ExperienceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExperienceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExperienceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExperiencePayload>
          }
          aggregate: {
            args: Prisma.ExperienceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExperience>
          }
          groupBy: {
            args: Prisma.ExperienceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExperienceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExperienceCountArgs<ExtArgs>
            result: $Utils.Optional<ExperienceCountAggregateOutputType> | number
          }
        }
      }
      Calendar: {
        payload: Prisma.$CalendarPayload<ExtArgs>
        fields: Prisma.CalendarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          findFirst: {
            args: Prisma.CalendarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          findMany: {
            args: Prisma.CalendarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>[]
          }
          create: {
            args: Prisma.CalendarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          createMany: {
            args: Prisma.CalendarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CalendarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          update: {
            args: Prisma.CalendarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          deleteMany: {
            args: Prisma.CalendarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarPayload>
          }
          aggregate: {
            args: Prisma.CalendarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendar>
          }
          groupBy: {
            args: Prisma.CalendarGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    client?: ClientOmit
    lawyer?: LawyerOmit
    conseilJuridique?: ConseilJuridiqueOmit
    redaction?: RedactionOmit
    resolutionLitige?: ResolutionLitigeOmit
    serviceParDomaine?: ServiceParDomaineOmit
    preventifs?: PreventifsOmit
    valeurAjouter?: ValeurAjouterOmit
    friends?: FriendsOmit
    friendLaw?: FriendLawOmit
    contrat?: ContratOmit
    notification?: NotificationOmit
    clientNotification?: ClientNotificationOmit
    contact?: ContactOmit
    clientContact?: ClientContactOmit
    diplome?: DiplomeOmit
    experience?: ExperienceOmit
    calendar?: CalendarOmit
    account?: AccountOmit
    session?: SessionOmit
    post?: PostOmit
    verificationToken?: VerificationTokenOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    client: number
    lawyer: number
    accounts: number
    sessions: number
    posts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | UserCountOutputTypeCountClientArgs
    lawyer?: boolean | UserCountOutputTypeCountLawyerArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLawyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LawyerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    friend: number
    notification: number
    client: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    friend?: boolean | ClientCountOutputTypeCountFriendArgs
    notification?: boolean | ClientCountOutputTypeCountNotificationArgs
    client?: boolean | ClientCountOutputTypeCountClientArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountFriendArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendsWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientNotificationWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContactWhereInput
  }


  /**
   * Count Type LawyerCountOutputType
   */

  export type LawyerCountOutputType = {
    diplome: number
    experience: number
    Notification: number
    contrat: number
    calendar: number
    friendLaw: number
    contact: number
    conseil: number
    redaction: number
    resolution: number
    services: number
    preventifs: number
    valuer: number
  }

  export type LawyerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diplome?: boolean | LawyerCountOutputTypeCountDiplomeArgs
    experience?: boolean | LawyerCountOutputTypeCountExperienceArgs
    Notification?: boolean | LawyerCountOutputTypeCountNotificationArgs
    contrat?: boolean | LawyerCountOutputTypeCountContratArgs
    calendar?: boolean | LawyerCountOutputTypeCountCalendarArgs
    friendLaw?: boolean | LawyerCountOutputTypeCountFriendLawArgs
    contact?: boolean | LawyerCountOutputTypeCountContactArgs
    conseil?: boolean | LawyerCountOutputTypeCountConseilArgs
    redaction?: boolean | LawyerCountOutputTypeCountRedactionArgs
    resolution?: boolean | LawyerCountOutputTypeCountResolutionArgs
    services?: boolean | LawyerCountOutputTypeCountServicesArgs
    preventifs?: boolean | LawyerCountOutputTypeCountPreventifsArgs
    valuer?: boolean | LawyerCountOutputTypeCountValuerArgs
  }

  // Custom InputTypes
  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LawyerCountOutputType
     */
    select?: LawyerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeCountDiplomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiplomeWhereInput
  }

  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeCountExperienceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperienceWhereInput
  }

  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeCountContratArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContratWhereInput
  }

  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeCountCalendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarWhereInput
  }

  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeCountFriendLawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendLawWhereInput
  }

  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeCountContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeCountConseilArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConseilJuridiqueWhereInput
  }

  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeCountRedactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedactionWhereInput
  }

  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeCountResolutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResolutionLitigeWhereInput
  }

  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceParDomaineWhereInput
  }

  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeCountPreventifsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreventifsWhereInput
  }

  /**
   * LawyerCountOutputType without action
   */
  export type LawyerCountOutputTypeCountValuerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValeurAjouterWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: string | null
    emailVerified: Date | null
    image: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: string | null
    emailVerified: Date | null
    image: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    emailVerified: number
    image: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    emailVerified?: true
    image?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    emailVerified?: true
    image?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    emailVerified?: true
    image?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    role: string
    emailVerified: Date | null
    image: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    emailVerified?: boolean
    image?: boolean
    client?: boolean | User$clientArgs<ExtArgs>
    lawyer?: boolean | User$lawyerArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    emailVerified?: boolean
    image?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "role" | "emailVerified" | "image", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | User$clientArgs<ExtArgs>
    lawyer?: boolean | User$lawyerArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>[]
      lawyer: Prisma.$LawyerPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      role: string
      emailVerified: Date | null
      image: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends User$clientArgs<ExtArgs> = {}>(args?: Subset<T, User$clientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lawyer<T extends User$lawyerArgs<ExtArgs> = {}>(args?: Subset<T, User$lawyerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.client
   */
  export type User$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * User.lawyer
   */
  export type User$lawyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    where?: LawyerWhereInput
    orderBy?: LawyerOrderByWithRelationInput | LawyerOrderByWithRelationInput[]
    cursor?: LawyerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LawyerScalarFieldEnum | LawyerScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    age: number | null
  }

  export type ClientSumAggregateOutputType = {
    age: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    profession: string | null
    age: number | null
    gender: string | null
    localisation: string | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    profession: string | null
    age: number | null
    gender: string | null
    localisation: string | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    profession: number
    age: number
    gender: number
    localisation: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    age?: true
  }

  export type ClientSumAggregateInputType = {
    age?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    profession?: true
    age?: true
    gender?: true
    localisation?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    profession?: true
    age?: true
    gender?: true
    localisation?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    profession?: true
    age?: true
    gender?: true
    localisation?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    userId: string
    name: string
    profession: string
    age: number
    gender: string
    localisation: string
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    profession?: boolean
    age?: boolean
    gender?: boolean
    localisation?: boolean
    friend?: boolean | Client$friendArgs<ExtArgs>
    notification?: boolean | Client$notificationArgs<ExtArgs>
    client?: boolean | Client$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>



  export type ClientSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    profession?: boolean
    age?: boolean
    gender?: boolean
    localisation?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "profession" | "age" | "gender" | "localisation", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    friend?: boolean | Client$friendArgs<ExtArgs>
    notification?: boolean | Client$notificationArgs<ExtArgs>
    client?: boolean | Client$clientArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      friend: Prisma.$FriendsPayload<ExtArgs>[]
      notification: Prisma.$ClientNotificationPayload<ExtArgs>[]
      client: Prisma.$ClientContactPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      profession: string
      age: number
      gender: string
      localisation: string
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    friend<T extends Client$friendArgs<ExtArgs> = {}>(args?: Subset<T, Client$friendArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification<T extends Client$notificationArgs<ExtArgs> = {}>(args?: Subset<T, Client$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    client<T extends Client$clientArgs<ExtArgs> = {}>(args?: Subset<T, Client$clientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly userId: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly profession: FieldRef<"Client", 'String'>
    readonly age: FieldRef<"Client", 'Int'>
    readonly gender: FieldRef<"Client", 'String'>
    readonly localisation: FieldRef<"Client", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.friend
   */
  export type Client$friendArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    where?: FriendsWhereInput
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    cursor?: FriendsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Client.notification
   */
  export type Client$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientNotification
     */
    select?: ClientNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientNotification
     */
    omit?: ClientNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientNotificationInclude<ExtArgs> | null
    where?: ClientNotificationWhereInput
    orderBy?: ClientNotificationOrderByWithRelationInput | ClientNotificationOrderByWithRelationInput[]
    cursor?: ClientNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientNotificationScalarFieldEnum | ClientNotificationScalarFieldEnum[]
  }

  /**
   * Client.client
   */
  export type Client$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null
    where?: ClientContactWhereInput
    orderBy?: ClientContactOrderByWithRelationInput | ClientContactOrderByWithRelationInput[]
    cursor?: ClientContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientContactScalarFieldEnum | ClientContactScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Lawyer
   */

  export type AggregateLawyer = {
    _count: LawyerCountAggregateOutputType | null
    _avg: LawyerAvgAggregateOutputType | null
    _sum: LawyerSumAggregateOutputType | null
    _min: LawyerMinAggregateOutputType | null
    _max: LawyerMaxAggregateOutputType | null
  }

  export type LawyerAvgAggregateOutputType = {
    age: number | null
    Star: number | null
  }

  export type LawyerSumAggregateOutputType = {
    age: number | null
    Star: number | null
  }

  export type LawyerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    age: number | null
    localisation: string | null
    budget: string | null
    gender: string | null
    specialité: string | null
    Star: number | null
  }

  export type LawyerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    age: number | null
    localisation: string | null
    budget: string | null
    gender: string | null
    specialité: string | null
    Star: number | null
  }

  export type LawyerCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    age: number
    localisation: number
    budget: number
    gender: number
    specialité: number
    Star: number
    _all: number
  }


  export type LawyerAvgAggregateInputType = {
    age?: true
    Star?: true
  }

  export type LawyerSumAggregateInputType = {
    age?: true
    Star?: true
  }

  export type LawyerMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    age?: true
    localisation?: true
    budget?: true
    gender?: true
    specialité?: true
    Star?: true
  }

  export type LawyerMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    age?: true
    localisation?: true
    budget?: true
    gender?: true
    specialité?: true
    Star?: true
  }

  export type LawyerCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    age?: true
    localisation?: true
    budget?: true
    gender?: true
    specialité?: true
    Star?: true
    _all?: true
  }

  export type LawyerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lawyer to aggregate.
     */
    where?: LawyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lawyers to fetch.
     */
    orderBy?: LawyerOrderByWithRelationInput | LawyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LawyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lawyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lawyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lawyers
    **/
    _count?: true | LawyerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LawyerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LawyerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LawyerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LawyerMaxAggregateInputType
  }

  export type GetLawyerAggregateType<T extends LawyerAggregateArgs> = {
        [P in keyof T & keyof AggregateLawyer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLawyer[P]>
      : GetScalarType<T[P], AggregateLawyer[P]>
  }




  export type LawyerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LawyerWhereInput
    orderBy?: LawyerOrderByWithAggregationInput | LawyerOrderByWithAggregationInput[]
    by: LawyerScalarFieldEnum[] | LawyerScalarFieldEnum
    having?: LawyerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LawyerCountAggregateInputType | true
    _avg?: LawyerAvgAggregateInputType
    _sum?: LawyerSumAggregateInputType
    _min?: LawyerMinAggregateInputType
    _max?: LawyerMaxAggregateInputType
  }

  export type LawyerGroupByOutputType = {
    id: string
    userId: string
    name: string | null
    age: number | null
    localisation: string | null
    budget: string | null
    gender: string | null
    specialité: string | null
    Star: number | null
    _count: LawyerCountAggregateOutputType | null
    _avg: LawyerAvgAggregateOutputType | null
    _sum: LawyerSumAggregateOutputType | null
    _min: LawyerMinAggregateOutputType | null
    _max: LawyerMaxAggregateOutputType | null
  }

  type GetLawyerGroupByPayload<T extends LawyerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LawyerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LawyerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LawyerGroupByOutputType[P]>
            : GetScalarType<T[P], LawyerGroupByOutputType[P]>
        }
      >
    >


  export type LawyerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    age?: boolean
    localisation?: boolean
    budget?: boolean
    gender?: boolean
    specialité?: boolean
    Star?: boolean
    diplome?: boolean | Lawyer$diplomeArgs<ExtArgs>
    experience?: boolean | Lawyer$experienceArgs<ExtArgs>
    Notification?: boolean | Lawyer$NotificationArgs<ExtArgs>
    contrat?: boolean | Lawyer$contratArgs<ExtArgs>
    calendar?: boolean | Lawyer$calendarArgs<ExtArgs>
    friendLaw?: boolean | Lawyer$friendLawArgs<ExtArgs>
    contact?: boolean | Lawyer$contactArgs<ExtArgs>
    conseil?: boolean | Lawyer$conseilArgs<ExtArgs>
    redaction?: boolean | Lawyer$redactionArgs<ExtArgs>
    resolution?: boolean | Lawyer$resolutionArgs<ExtArgs>
    services?: boolean | Lawyer$servicesArgs<ExtArgs>
    preventifs?: boolean | Lawyer$preventifsArgs<ExtArgs>
    valuer?: boolean | Lawyer$valuerArgs<ExtArgs>
    user?: boolean | Lawyer$userArgs<ExtArgs>
    _count?: boolean | LawyerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lawyer"]>



  export type LawyerSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    age?: boolean
    localisation?: boolean
    budget?: boolean
    gender?: boolean
    specialité?: boolean
    Star?: boolean
  }

  export type LawyerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "age" | "localisation" | "budget" | "gender" | "specialité" | "Star", ExtArgs["result"]["lawyer"]>
  export type LawyerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diplome?: boolean | Lawyer$diplomeArgs<ExtArgs>
    experience?: boolean | Lawyer$experienceArgs<ExtArgs>
    Notification?: boolean | Lawyer$NotificationArgs<ExtArgs>
    contrat?: boolean | Lawyer$contratArgs<ExtArgs>
    calendar?: boolean | Lawyer$calendarArgs<ExtArgs>
    friendLaw?: boolean | Lawyer$friendLawArgs<ExtArgs>
    contact?: boolean | Lawyer$contactArgs<ExtArgs>
    conseil?: boolean | Lawyer$conseilArgs<ExtArgs>
    redaction?: boolean | Lawyer$redactionArgs<ExtArgs>
    resolution?: boolean | Lawyer$resolutionArgs<ExtArgs>
    services?: boolean | Lawyer$servicesArgs<ExtArgs>
    preventifs?: boolean | Lawyer$preventifsArgs<ExtArgs>
    valuer?: boolean | Lawyer$valuerArgs<ExtArgs>
    user?: boolean | Lawyer$userArgs<ExtArgs>
    _count?: boolean | LawyerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LawyerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lawyer"
    objects: {
      diplome: Prisma.$DiplomePayload<ExtArgs>[]
      experience: Prisma.$ExperiencePayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
      contrat: Prisma.$ContratPayload<ExtArgs>[]
      calendar: Prisma.$CalendarPayload<ExtArgs>[]
      friendLaw: Prisma.$FriendLawPayload<ExtArgs>[]
      contact: Prisma.$ContactPayload<ExtArgs>[]
      conseil: Prisma.$ConseilJuridiquePayload<ExtArgs>[]
      redaction: Prisma.$RedactionPayload<ExtArgs>[]
      resolution: Prisma.$ResolutionLitigePayload<ExtArgs>[]
      services: Prisma.$ServiceParDomainePayload<ExtArgs>[]
      preventifs: Prisma.$PreventifsPayload<ExtArgs>[]
      valuer: Prisma.$ValeurAjouterPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string | null
      age: number | null
      localisation: string | null
      budget: string | null
      gender: string | null
      specialité: string | null
      Star: number | null
    }, ExtArgs["result"]["lawyer"]>
    composites: {}
  }

  type LawyerGetPayload<S extends boolean | null | undefined | LawyerDefaultArgs> = $Result.GetResult<Prisma.$LawyerPayload, S>

  type LawyerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LawyerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LawyerCountAggregateInputType | true
    }

  export interface LawyerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lawyer'], meta: { name: 'Lawyer' } }
    /**
     * Find zero or one Lawyer that matches the filter.
     * @param {LawyerFindUniqueArgs} args - Arguments to find a Lawyer
     * @example
     * // Get one Lawyer
     * const lawyer = await prisma.lawyer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LawyerFindUniqueArgs>(args: SelectSubset<T, LawyerFindUniqueArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lawyer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LawyerFindUniqueOrThrowArgs} args - Arguments to find a Lawyer
     * @example
     * // Get one Lawyer
     * const lawyer = await prisma.lawyer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LawyerFindUniqueOrThrowArgs>(args: SelectSubset<T, LawyerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lawyer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawyerFindFirstArgs} args - Arguments to find a Lawyer
     * @example
     * // Get one Lawyer
     * const lawyer = await prisma.lawyer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LawyerFindFirstArgs>(args?: SelectSubset<T, LawyerFindFirstArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lawyer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawyerFindFirstOrThrowArgs} args - Arguments to find a Lawyer
     * @example
     * // Get one Lawyer
     * const lawyer = await prisma.lawyer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LawyerFindFirstOrThrowArgs>(args?: SelectSubset<T, LawyerFindFirstOrThrowArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lawyers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawyerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lawyers
     * const lawyers = await prisma.lawyer.findMany()
     * 
     * // Get first 10 Lawyers
     * const lawyers = await prisma.lawyer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lawyerWithIdOnly = await prisma.lawyer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LawyerFindManyArgs>(args?: SelectSubset<T, LawyerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lawyer.
     * @param {LawyerCreateArgs} args - Arguments to create a Lawyer.
     * @example
     * // Create one Lawyer
     * const Lawyer = await prisma.lawyer.create({
     *   data: {
     *     // ... data to create a Lawyer
     *   }
     * })
     * 
     */
    create<T extends LawyerCreateArgs>(args: SelectSubset<T, LawyerCreateArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lawyers.
     * @param {LawyerCreateManyArgs} args - Arguments to create many Lawyers.
     * @example
     * // Create many Lawyers
     * const lawyer = await prisma.lawyer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LawyerCreateManyArgs>(args?: SelectSubset<T, LawyerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lawyer.
     * @param {LawyerDeleteArgs} args - Arguments to delete one Lawyer.
     * @example
     * // Delete one Lawyer
     * const Lawyer = await prisma.lawyer.delete({
     *   where: {
     *     // ... filter to delete one Lawyer
     *   }
     * })
     * 
     */
    delete<T extends LawyerDeleteArgs>(args: SelectSubset<T, LawyerDeleteArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lawyer.
     * @param {LawyerUpdateArgs} args - Arguments to update one Lawyer.
     * @example
     * // Update one Lawyer
     * const lawyer = await prisma.lawyer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LawyerUpdateArgs>(args: SelectSubset<T, LawyerUpdateArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lawyers.
     * @param {LawyerDeleteManyArgs} args - Arguments to filter Lawyers to delete.
     * @example
     * // Delete a few Lawyers
     * const { count } = await prisma.lawyer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LawyerDeleteManyArgs>(args?: SelectSubset<T, LawyerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lawyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawyerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lawyers
     * const lawyer = await prisma.lawyer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LawyerUpdateManyArgs>(args: SelectSubset<T, LawyerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lawyer.
     * @param {LawyerUpsertArgs} args - Arguments to update or create a Lawyer.
     * @example
     * // Update or create a Lawyer
     * const lawyer = await prisma.lawyer.upsert({
     *   create: {
     *     // ... data to create a Lawyer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lawyer we want to update
     *   }
     * })
     */
    upsert<T extends LawyerUpsertArgs>(args: SelectSubset<T, LawyerUpsertArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lawyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawyerCountArgs} args - Arguments to filter Lawyers to count.
     * @example
     * // Count the number of Lawyers
     * const count = await prisma.lawyer.count({
     *   where: {
     *     // ... the filter for the Lawyers we want to count
     *   }
     * })
    **/
    count<T extends LawyerCountArgs>(
      args?: Subset<T, LawyerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LawyerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lawyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawyerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LawyerAggregateArgs>(args: Subset<T, LawyerAggregateArgs>): Prisma.PrismaPromise<GetLawyerAggregateType<T>>

    /**
     * Group by Lawyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LawyerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LawyerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LawyerGroupByArgs['orderBy'] }
        : { orderBy?: LawyerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LawyerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLawyerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lawyer model
   */
  readonly fields: LawyerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lawyer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LawyerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    diplome<T extends Lawyer$diplomeArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$diplomeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    experience<T extends Lawyer$experienceArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$experienceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends Lawyer$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contrat<T extends Lawyer$contratArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$contratArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContratPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calendar<T extends Lawyer$calendarArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$calendarArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    friendLaw<T extends Lawyer$friendLawArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$friendLawArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendLawPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contact<T extends Lawyer$contactArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$contactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conseil<T extends Lawyer$conseilArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$conseilArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConseilJuridiquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    redaction<T extends Lawyer$redactionArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$redactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resolution<T extends Lawyer$resolutionArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$resolutionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResolutionLitigePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends Lawyer$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceParDomainePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preventifs<T extends Lawyer$preventifsArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$preventifsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreventifsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    valuer<T extends Lawyer$valuerArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$valuerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValeurAjouterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Lawyer$userArgs<ExtArgs> = {}>(args?: Subset<T, Lawyer$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lawyer model
   */
  interface LawyerFieldRefs {
    readonly id: FieldRef<"Lawyer", 'String'>
    readonly userId: FieldRef<"Lawyer", 'String'>
    readonly name: FieldRef<"Lawyer", 'String'>
    readonly age: FieldRef<"Lawyer", 'Int'>
    readonly localisation: FieldRef<"Lawyer", 'String'>
    readonly budget: FieldRef<"Lawyer", 'String'>
    readonly gender: FieldRef<"Lawyer", 'String'>
    readonly specialité: FieldRef<"Lawyer", 'String'>
    readonly Star: FieldRef<"Lawyer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Lawyer findUnique
   */
  export type LawyerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    /**
     * Filter, which Lawyer to fetch.
     */
    where: LawyerWhereUniqueInput
  }

  /**
   * Lawyer findUniqueOrThrow
   */
  export type LawyerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    /**
     * Filter, which Lawyer to fetch.
     */
    where: LawyerWhereUniqueInput
  }

  /**
   * Lawyer findFirst
   */
  export type LawyerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    /**
     * Filter, which Lawyer to fetch.
     */
    where?: LawyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lawyers to fetch.
     */
    orderBy?: LawyerOrderByWithRelationInput | LawyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lawyers.
     */
    cursor?: LawyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lawyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lawyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lawyers.
     */
    distinct?: LawyerScalarFieldEnum | LawyerScalarFieldEnum[]
  }

  /**
   * Lawyer findFirstOrThrow
   */
  export type LawyerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    /**
     * Filter, which Lawyer to fetch.
     */
    where?: LawyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lawyers to fetch.
     */
    orderBy?: LawyerOrderByWithRelationInput | LawyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lawyers.
     */
    cursor?: LawyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lawyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lawyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lawyers.
     */
    distinct?: LawyerScalarFieldEnum | LawyerScalarFieldEnum[]
  }

  /**
   * Lawyer findMany
   */
  export type LawyerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    /**
     * Filter, which Lawyers to fetch.
     */
    where?: LawyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lawyers to fetch.
     */
    orderBy?: LawyerOrderByWithRelationInput | LawyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lawyers.
     */
    cursor?: LawyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lawyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lawyers.
     */
    skip?: number
    distinct?: LawyerScalarFieldEnum | LawyerScalarFieldEnum[]
  }

  /**
   * Lawyer create
   */
  export type LawyerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    /**
     * The data needed to create a Lawyer.
     */
    data: XOR<LawyerCreateInput, LawyerUncheckedCreateInput>
  }

  /**
   * Lawyer createMany
   */
  export type LawyerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lawyers.
     */
    data: LawyerCreateManyInput | LawyerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lawyer update
   */
  export type LawyerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    /**
     * The data needed to update a Lawyer.
     */
    data: XOR<LawyerUpdateInput, LawyerUncheckedUpdateInput>
    /**
     * Choose, which Lawyer to update.
     */
    where: LawyerWhereUniqueInput
  }

  /**
   * Lawyer updateMany
   */
  export type LawyerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lawyers.
     */
    data: XOR<LawyerUpdateManyMutationInput, LawyerUncheckedUpdateManyInput>
    /**
     * Filter which Lawyers to update
     */
    where?: LawyerWhereInput
    /**
     * Limit how many Lawyers to update.
     */
    limit?: number
  }

  /**
   * Lawyer upsert
   */
  export type LawyerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    /**
     * The filter to search for the Lawyer to update in case it exists.
     */
    where: LawyerWhereUniqueInput
    /**
     * In case the Lawyer found by the `where` argument doesn't exist, create a new Lawyer with this data.
     */
    create: XOR<LawyerCreateInput, LawyerUncheckedCreateInput>
    /**
     * In case the Lawyer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LawyerUpdateInput, LawyerUncheckedUpdateInput>
  }

  /**
   * Lawyer delete
   */
  export type LawyerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    /**
     * Filter which Lawyer to delete.
     */
    where: LawyerWhereUniqueInput
  }

  /**
   * Lawyer deleteMany
   */
  export type LawyerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lawyers to delete
     */
    where?: LawyerWhereInput
    /**
     * Limit how many Lawyers to delete.
     */
    limit?: number
  }

  /**
   * Lawyer.diplome
   */
  export type Lawyer$diplomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diplome
     */
    omit?: DiplomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiplomeInclude<ExtArgs> | null
    where?: DiplomeWhereInput
    orderBy?: DiplomeOrderByWithRelationInput | DiplomeOrderByWithRelationInput[]
    cursor?: DiplomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiplomeScalarFieldEnum | DiplomeScalarFieldEnum[]
  }

  /**
   * Lawyer.experience
   */
  export type Lawyer$experienceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    where?: ExperienceWhereInput
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    cursor?: ExperienceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExperienceScalarFieldEnum | ExperienceScalarFieldEnum[]
  }

  /**
   * Lawyer.Notification
   */
  export type Lawyer$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Lawyer.contrat
   */
  export type Lawyer$contratArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrat
     */
    select?: ContratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contrat
     */
    omit?: ContratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratInclude<ExtArgs> | null
    where?: ContratWhereInput
    orderBy?: ContratOrderByWithRelationInput | ContratOrderByWithRelationInput[]
    cursor?: ContratWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContratScalarFieldEnum | ContratScalarFieldEnum[]
  }

  /**
   * Lawyer.calendar
   */
  export type Lawyer$calendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    where?: CalendarWhereInput
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    cursor?: CalendarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Lawyer.friendLaw
   */
  export type Lawyer$friendLawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendLaw
     */
    select?: FriendLawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendLaw
     */
    omit?: FriendLawOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendLawInclude<ExtArgs> | null
    where?: FriendLawWhereInput
    orderBy?: FriendLawOrderByWithRelationInput | FriendLawOrderByWithRelationInput[]
    cursor?: FriendLawWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendLawScalarFieldEnum | FriendLawScalarFieldEnum[]
  }

  /**
   * Lawyer.contact
   */
  export type Lawyer$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Lawyer.conseil
   */
  export type Lawyer$conseilArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConseilJuridique
     */
    select?: ConseilJuridiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConseilJuridique
     */
    omit?: ConseilJuridiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConseilJuridiqueInclude<ExtArgs> | null
    where?: ConseilJuridiqueWhereInput
    orderBy?: ConseilJuridiqueOrderByWithRelationInput | ConseilJuridiqueOrderByWithRelationInput[]
    cursor?: ConseilJuridiqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConseilJuridiqueScalarFieldEnum | ConseilJuridiqueScalarFieldEnum[]
  }

  /**
   * Lawyer.redaction
   */
  export type Lawyer$redactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redaction
     */
    select?: RedactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redaction
     */
    omit?: RedactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedactionInclude<ExtArgs> | null
    where?: RedactionWhereInput
    orderBy?: RedactionOrderByWithRelationInput | RedactionOrderByWithRelationInput[]
    cursor?: RedactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RedactionScalarFieldEnum | RedactionScalarFieldEnum[]
  }

  /**
   * Lawyer.resolution
   */
  export type Lawyer$resolutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResolutionLitige
     */
    select?: ResolutionLitigeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResolutionLitige
     */
    omit?: ResolutionLitigeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResolutionLitigeInclude<ExtArgs> | null
    where?: ResolutionLitigeWhereInput
    orderBy?: ResolutionLitigeOrderByWithRelationInput | ResolutionLitigeOrderByWithRelationInput[]
    cursor?: ResolutionLitigeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResolutionLitigeScalarFieldEnum | ResolutionLitigeScalarFieldEnum[]
  }

  /**
   * Lawyer.services
   */
  export type Lawyer$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceParDomaine
     */
    select?: ServiceParDomaineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceParDomaine
     */
    omit?: ServiceParDomaineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceParDomaineInclude<ExtArgs> | null
    where?: ServiceParDomaineWhereInput
    orderBy?: ServiceParDomaineOrderByWithRelationInput | ServiceParDomaineOrderByWithRelationInput[]
    cursor?: ServiceParDomaineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceParDomaineScalarFieldEnum | ServiceParDomaineScalarFieldEnum[]
  }

  /**
   * Lawyer.preventifs
   */
  export type Lawyer$preventifsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preventifs
     */
    select?: PreventifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preventifs
     */
    omit?: PreventifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreventifsInclude<ExtArgs> | null
    where?: PreventifsWhereInput
    orderBy?: PreventifsOrderByWithRelationInput | PreventifsOrderByWithRelationInput[]
    cursor?: PreventifsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PreventifsScalarFieldEnum | PreventifsScalarFieldEnum[]
  }

  /**
   * Lawyer.valuer
   */
  export type Lawyer$valuerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValeurAjouter
     */
    select?: ValeurAjouterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValeurAjouter
     */
    omit?: ValeurAjouterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValeurAjouterInclude<ExtArgs> | null
    where?: ValeurAjouterWhereInput
    orderBy?: ValeurAjouterOrderByWithRelationInput | ValeurAjouterOrderByWithRelationInput[]
    cursor?: ValeurAjouterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ValeurAjouterScalarFieldEnum | ValeurAjouterScalarFieldEnum[]
  }

  /**
   * Lawyer.user
   */
  export type Lawyer$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Lawyer without action
   */
  export type LawyerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
  }


  /**
   * Model ConseilJuridique
   */

  export type AggregateConseilJuridique = {
    _count: ConseilJuridiqueCountAggregateOutputType | null
    _min: ConseilJuridiqueMinAggregateOutputType | null
    _max: ConseilJuridiqueMaxAggregateOutputType | null
  }

  export type ConseilJuridiqueMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    desc: string | null
  }

  export type ConseilJuridiqueMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    desc: string | null
  }

  export type ConseilJuridiqueCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    desc: number
    _all: number
  }


  export type ConseilJuridiqueMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
  }

  export type ConseilJuridiqueMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
  }

  export type ConseilJuridiqueCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
    _all?: true
  }

  export type ConseilJuridiqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConseilJuridique to aggregate.
     */
    where?: ConseilJuridiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConseilJuridiques to fetch.
     */
    orderBy?: ConseilJuridiqueOrderByWithRelationInput | ConseilJuridiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConseilJuridiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConseilJuridiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConseilJuridiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConseilJuridiques
    **/
    _count?: true | ConseilJuridiqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConseilJuridiqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConseilJuridiqueMaxAggregateInputType
  }

  export type GetConseilJuridiqueAggregateType<T extends ConseilJuridiqueAggregateArgs> = {
        [P in keyof T & keyof AggregateConseilJuridique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConseilJuridique[P]>
      : GetScalarType<T[P], AggregateConseilJuridique[P]>
  }




  export type ConseilJuridiqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConseilJuridiqueWhereInput
    orderBy?: ConseilJuridiqueOrderByWithAggregationInput | ConseilJuridiqueOrderByWithAggregationInput[]
    by: ConseilJuridiqueScalarFieldEnum[] | ConseilJuridiqueScalarFieldEnum
    having?: ConseilJuridiqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConseilJuridiqueCountAggregateInputType | true
    _min?: ConseilJuridiqueMinAggregateInputType
    _max?: ConseilJuridiqueMaxAggregateInputType
  }

  export type ConseilJuridiqueGroupByOutputType = {
    id: string
    userId: string
    title: string
    content: string
    desc: string
    _count: ConseilJuridiqueCountAggregateOutputType | null
    _min: ConseilJuridiqueMinAggregateOutputType | null
    _max: ConseilJuridiqueMaxAggregateOutputType | null
  }

  type GetConseilJuridiqueGroupByPayload<T extends ConseilJuridiqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConseilJuridiqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConseilJuridiqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConseilJuridiqueGroupByOutputType[P]>
            : GetScalarType<T[P], ConseilJuridiqueGroupByOutputType[P]>
        }
      >
    >


  export type ConseilJuridiqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    desc?: boolean
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conseilJuridique"]>



  export type ConseilJuridiqueSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    desc?: boolean
  }

  export type ConseilJuridiqueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "content" | "desc", ExtArgs["result"]["conseilJuridique"]>
  export type ConseilJuridiqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }

  export type $ConseilJuridiquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConseilJuridique"
    objects: {
      lawyer: Prisma.$LawyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      content: string
      desc: string
    }, ExtArgs["result"]["conseilJuridique"]>
    composites: {}
  }

  type ConseilJuridiqueGetPayload<S extends boolean | null | undefined | ConseilJuridiqueDefaultArgs> = $Result.GetResult<Prisma.$ConseilJuridiquePayload, S>

  type ConseilJuridiqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConseilJuridiqueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConseilJuridiqueCountAggregateInputType | true
    }

  export interface ConseilJuridiqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConseilJuridique'], meta: { name: 'ConseilJuridique' } }
    /**
     * Find zero or one ConseilJuridique that matches the filter.
     * @param {ConseilJuridiqueFindUniqueArgs} args - Arguments to find a ConseilJuridique
     * @example
     * // Get one ConseilJuridique
     * const conseilJuridique = await prisma.conseilJuridique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConseilJuridiqueFindUniqueArgs>(args: SelectSubset<T, ConseilJuridiqueFindUniqueArgs<ExtArgs>>): Prisma__ConseilJuridiqueClient<$Result.GetResult<Prisma.$ConseilJuridiquePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConseilJuridique that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConseilJuridiqueFindUniqueOrThrowArgs} args - Arguments to find a ConseilJuridique
     * @example
     * // Get one ConseilJuridique
     * const conseilJuridique = await prisma.conseilJuridique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConseilJuridiqueFindUniqueOrThrowArgs>(args: SelectSubset<T, ConseilJuridiqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConseilJuridiqueClient<$Result.GetResult<Prisma.$ConseilJuridiquePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConseilJuridique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilJuridiqueFindFirstArgs} args - Arguments to find a ConseilJuridique
     * @example
     * // Get one ConseilJuridique
     * const conseilJuridique = await prisma.conseilJuridique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConseilJuridiqueFindFirstArgs>(args?: SelectSubset<T, ConseilJuridiqueFindFirstArgs<ExtArgs>>): Prisma__ConseilJuridiqueClient<$Result.GetResult<Prisma.$ConseilJuridiquePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConseilJuridique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilJuridiqueFindFirstOrThrowArgs} args - Arguments to find a ConseilJuridique
     * @example
     * // Get one ConseilJuridique
     * const conseilJuridique = await prisma.conseilJuridique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConseilJuridiqueFindFirstOrThrowArgs>(args?: SelectSubset<T, ConseilJuridiqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConseilJuridiqueClient<$Result.GetResult<Prisma.$ConseilJuridiquePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConseilJuridiques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilJuridiqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConseilJuridiques
     * const conseilJuridiques = await prisma.conseilJuridique.findMany()
     * 
     * // Get first 10 ConseilJuridiques
     * const conseilJuridiques = await prisma.conseilJuridique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conseilJuridiqueWithIdOnly = await prisma.conseilJuridique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConseilJuridiqueFindManyArgs>(args?: SelectSubset<T, ConseilJuridiqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConseilJuridiquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConseilJuridique.
     * @param {ConseilJuridiqueCreateArgs} args - Arguments to create a ConseilJuridique.
     * @example
     * // Create one ConseilJuridique
     * const ConseilJuridique = await prisma.conseilJuridique.create({
     *   data: {
     *     // ... data to create a ConseilJuridique
     *   }
     * })
     * 
     */
    create<T extends ConseilJuridiqueCreateArgs>(args: SelectSubset<T, ConseilJuridiqueCreateArgs<ExtArgs>>): Prisma__ConseilJuridiqueClient<$Result.GetResult<Prisma.$ConseilJuridiquePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConseilJuridiques.
     * @param {ConseilJuridiqueCreateManyArgs} args - Arguments to create many ConseilJuridiques.
     * @example
     * // Create many ConseilJuridiques
     * const conseilJuridique = await prisma.conseilJuridique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConseilJuridiqueCreateManyArgs>(args?: SelectSubset<T, ConseilJuridiqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConseilJuridique.
     * @param {ConseilJuridiqueDeleteArgs} args - Arguments to delete one ConseilJuridique.
     * @example
     * // Delete one ConseilJuridique
     * const ConseilJuridique = await prisma.conseilJuridique.delete({
     *   where: {
     *     // ... filter to delete one ConseilJuridique
     *   }
     * })
     * 
     */
    delete<T extends ConseilJuridiqueDeleteArgs>(args: SelectSubset<T, ConseilJuridiqueDeleteArgs<ExtArgs>>): Prisma__ConseilJuridiqueClient<$Result.GetResult<Prisma.$ConseilJuridiquePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConseilJuridique.
     * @param {ConseilJuridiqueUpdateArgs} args - Arguments to update one ConseilJuridique.
     * @example
     * // Update one ConseilJuridique
     * const conseilJuridique = await prisma.conseilJuridique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConseilJuridiqueUpdateArgs>(args: SelectSubset<T, ConseilJuridiqueUpdateArgs<ExtArgs>>): Prisma__ConseilJuridiqueClient<$Result.GetResult<Prisma.$ConseilJuridiquePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConseilJuridiques.
     * @param {ConseilJuridiqueDeleteManyArgs} args - Arguments to filter ConseilJuridiques to delete.
     * @example
     * // Delete a few ConseilJuridiques
     * const { count } = await prisma.conseilJuridique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConseilJuridiqueDeleteManyArgs>(args?: SelectSubset<T, ConseilJuridiqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConseilJuridiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilJuridiqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConseilJuridiques
     * const conseilJuridique = await prisma.conseilJuridique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConseilJuridiqueUpdateManyArgs>(args: SelectSubset<T, ConseilJuridiqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConseilJuridique.
     * @param {ConseilJuridiqueUpsertArgs} args - Arguments to update or create a ConseilJuridique.
     * @example
     * // Update or create a ConseilJuridique
     * const conseilJuridique = await prisma.conseilJuridique.upsert({
     *   create: {
     *     // ... data to create a ConseilJuridique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConseilJuridique we want to update
     *   }
     * })
     */
    upsert<T extends ConseilJuridiqueUpsertArgs>(args: SelectSubset<T, ConseilJuridiqueUpsertArgs<ExtArgs>>): Prisma__ConseilJuridiqueClient<$Result.GetResult<Prisma.$ConseilJuridiquePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConseilJuridiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilJuridiqueCountArgs} args - Arguments to filter ConseilJuridiques to count.
     * @example
     * // Count the number of ConseilJuridiques
     * const count = await prisma.conseilJuridique.count({
     *   where: {
     *     // ... the filter for the ConseilJuridiques we want to count
     *   }
     * })
    **/
    count<T extends ConseilJuridiqueCountArgs>(
      args?: Subset<T, ConseilJuridiqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConseilJuridiqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConseilJuridique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilJuridiqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConseilJuridiqueAggregateArgs>(args: Subset<T, ConseilJuridiqueAggregateArgs>): Prisma.PrismaPromise<GetConseilJuridiqueAggregateType<T>>

    /**
     * Group by ConseilJuridique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConseilJuridiqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConseilJuridiqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConseilJuridiqueGroupByArgs['orderBy'] }
        : { orderBy?: ConseilJuridiqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConseilJuridiqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConseilJuridiqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConseilJuridique model
   */
  readonly fields: ConseilJuridiqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConseilJuridique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConseilJuridiqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lawyer<T extends LawyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LawyerDefaultArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConseilJuridique model
   */
  interface ConseilJuridiqueFieldRefs {
    readonly id: FieldRef<"ConseilJuridique", 'String'>
    readonly userId: FieldRef<"ConseilJuridique", 'String'>
    readonly title: FieldRef<"ConseilJuridique", 'String'>
    readonly content: FieldRef<"ConseilJuridique", 'String'>
    readonly desc: FieldRef<"ConseilJuridique", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConseilJuridique findUnique
   */
  export type ConseilJuridiqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConseilJuridique
     */
    select?: ConseilJuridiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConseilJuridique
     */
    omit?: ConseilJuridiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConseilJuridiqueInclude<ExtArgs> | null
    /**
     * Filter, which ConseilJuridique to fetch.
     */
    where: ConseilJuridiqueWhereUniqueInput
  }

  /**
   * ConseilJuridique findUniqueOrThrow
   */
  export type ConseilJuridiqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConseilJuridique
     */
    select?: ConseilJuridiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConseilJuridique
     */
    omit?: ConseilJuridiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConseilJuridiqueInclude<ExtArgs> | null
    /**
     * Filter, which ConseilJuridique to fetch.
     */
    where: ConseilJuridiqueWhereUniqueInput
  }

  /**
   * ConseilJuridique findFirst
   */
  export type ConseilJuridiqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConseilJuridique
     */
    select?: ConseilJuridiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConseilJuridique
     */
    omit?: ConseilJuridiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConseilJuridiqueInclude<ExtArgs> | null
    /**
     * Filter, which ConseilJuridique to fetch.
     */
    where?: ConseilJuridiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConseilJuridiques to fetch.
     */
    orderBy?: ConseilJuridiqueOrderByWithRelationInput | ConseilJuridiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConseilJuridiques.
     */
    cursor?: ConseilJuridiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConseilJuridiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConseilJuridiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConseilJuridiques.
     */
    distinct?: ConseilJuridiqueScalarFieldEnum | ConseilJuridiqueScalarFieldEnum[]
  }

  /**
   * ConseilJuridique findFirstOrThrow
   */
  export type ConseilJuridiqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConseilJuridique
     */
    select?: ConseilJuridiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConseilJuridique
     */
    omit?: ConseilJuridiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConseilJuridiqueInclude<ExtArgs> | null
    /**
     * Filter, which ConseilJuridique to fetch.
     */
    where?: ConseilJuridiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConseilJuridiques to fetch.
     */
    orderBy?: ConseilJuridiqueOrderByWithRelationInput | ConseilJuridiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConseilJuridiques.
     */
    cursor?: ConseilJuridiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConseilJuridiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConseilJuridiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConseilJuridiques.
     */
    distinct?: ConseilJuridiqueScalarFieldEnum | ConseilJuridiqueScalarFieldEnum[]
  }

  /**
   * ConseilJuridique findMany
   */
  export type ConseilJuridiqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConseilJuridique
     */
    select?: ConseilJuridiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConseilJuridique
     */
    omit?: ConseilJuridiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConseilJuridiqueInclude<ExtArgs> | null
    /**
     * Filter, which ConseilJuridiques to fetch.
     */
    where?: ConseilJuridiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConseilJuridiques to fetch.
     */
    orderBy?: ConseilJuridiqueOrderByWithRelationInput | ConseilJuridiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConseilJuridiques.
     */
    cursor?: ConseilJuridiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConseilJuridiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConseilJuridiques.
     */
    skip?: number
    distinct?: ConseilJuridiqueScalarFieldEnum | ConseilJuridiqueScalarFieldEnum[]
  }

  /**
   * ConseilJuridique create
   */
  export type ConseilJuridiqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConseilJuridique
     */
    select?: ConseilJuridiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConseilJuridique
     */
    omit?: ConseilJuridiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConseilJuridiqueInclude<ExtArgs> | null
    /**
     * The data needed to create a ConseilJuridique.
     */
    data: XOR<ConseilJuridiqueCreateInput, ConseilJuridiqueUncheckedCreateInput>
  }

  /**
   * ConseilJuridique createMany
   */
  export type ConseilJuridiqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConseilJuridiques.
     */
    data: ConseilJuridiqueCreateManyInput | ConseilJuridiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConseilJuridique update
   */
  export type ConseilJuridiqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConseilJuridique
     */
    select?: ConseilJuridiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConseilJuridique
     */
    omit?: ConseilJuridiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConseilJuridiqueInclude<ExtArgs> | null
    /**
     * The data needed to update a ConseilJuridique.
     */
    data: XOR<ConseilJuridiqueUpdateInput, ConseilJuridiqueUncheckedUpdateInput>
    /**
     * Choose, which ConseilJuridique to update.
     */
    where: ConseilJuridiqueWhereUniqueInput
  }

  /**
   * ConseilJuridique updateMany
   */
  export type ConseilJuridiqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConseilJuridiques.
     */
    data: XOR<ConseilJuridiqueUpdateManyMutationInput, ConseilJuridiqueUncheckedUpdateManyInput>
    /**
     * Filter which ConseilJuridiques to update
     */
    where?: ConseilJuridiqueWhereInput
    /**
     * Limit how many ConseilJuridiques to update.
     */
    limit?: number
  }

  /**
   * ConseilJuridique upsert
   */
  export type ConseilJuridiqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConseilJuridique
     */
    select?: ConseilJuridiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConseilJuridique
     */
    omit?: ConseilJuridiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConseilJuridiqueInclude<ExtArgs> | null
    /**
     * The filter to search for the ConseilJuridique to update in case it exists.
     */
    where: ConseilJuridiqueWhereUniqueInput
    /**
     * In case the ConseilJuridique found by the `where` argument doesn't exist, create a new ConseilJuridique with this data.
     */
    create: XOR<ConseilJuridiqueCreateInput, ConseilJuridiqueUncheckedCreateInput>
    /**
     * In case the ConseilJuridique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConseilJuridiqueUpdateInput, ConseilJuridiqueUncheckedUpdateInput>
  }

  /**
   * ConseilJuridique delete
   */
  export type ConseilJuridiqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConseilJuridique
     */
    select?: ConseilJuridiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConseilJuridique
     */
    omit?: ConseilJuridiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConseilJuridiqueInclude<ExtArgs> | null
    /**
     * Filter which ConseilJuridique to delete.
     */
    where: ConseilJuridiqueWhereUniqueInput
  }

  /**
   * ConseilJuridique deleteMany
   */
  export type ConseilJuridiqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConseilJuridiques to delete
     */
    where?: ConseilJuridiqueWhereInput
    /**
     * Limit how many ConseilJuridiques to delete.
     */
    limit?: number
  }

  /**
   * ConseilJuridique without action
   */
  export type ConseilJuridiqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConseilJuridique
     */
    select?: ConseilJuridiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConseilJuridique
     */
    omit?: ConseilJuridiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConseilJuridiqueInclude<ExtArgs> | null
  }


  /**
   * Model Redaction
   */

  export type AggregateRedaction = {
    _count: RedactionCountAggregateOutputType | null
    _min: RedactionMinAggregateOutputType | null
    _max: RedactionMaxAggregateOutputType | null
  }

  export type RedactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    desc: string | null
  }

  export type RedactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    desc: string | null
  }

  export type RedactionCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    desc: number
    _all: number
  }


  export type RedactionMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
  }

  export type RedactionMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
  }

  export type RedactionCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
    _all?: true
  }

  export type RedactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redaction to aggregate.
     */
    where?: RedactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redactions to fetch.
     */
    orderBy?: RedactionOrderByWithRelationInput | RedactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RedactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redactions
    **/
    _count?: true | RedactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RedactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RedactionMaxAggregateInputType
  }

  export type GetRedactionAggregateType<T extends RedactionAggregateArgs> = {
        [P in keyof T & keyof AggregateRedaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedaction[P]>
      : GetScalarType<T[P], AggregateRedaction[P]>
  }




  export type RedactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedactionWhereInput
    orderBy?: RedactionOrderByWithAggregationInput | RedactionOrderByWithAggregationInput[]
    by: RedactionScalarFieldEnum[] | RedactionScalarFieldEnum
    having?: RedactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RedactionCountAggregateInputType | true
    _min?: RedactionMinAggregateInputType
    _max?: RedactionMaxAggregateInputType
  }

  export type RedactionGroupByOutputType = {
    id: string
    userId: string
    title: string
    content: string
    desc: string
    _count: RedactionCountAggregateOutputType | null
    _min: RedactionMinAggregateOutputType | null
    _max: RedactionMaxAggregateOutputType | null
  }

  type GetRedactionGroupByPayload<T extends RedactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RedactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RedactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RedactionGroupByOutputType[P]>
            : GetScalarType<T[P], RedactionGroupByOutputType[P]>
        }
      >
    >


  export type RedactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    desc?: boolean
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redaction"]>



  export type RedactionSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    desc?: boolean
  }

  export type RedactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "content" | "desc", ExtArgs["result"]["redaction"]>
  export type RedactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }

  export type $RedactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redaction"
    objects: {
      lawyer: Prisma.$LawyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      content: string
      desc: string
    }, ExtArgs["result"]["redaction"]>
    composites: {}
  }

  type RedactionGetPayload<S extends boolean | null | undefined | RedactionDefaultArgs> = $Result.GetResult<Prisma.$RedactionPayload, S>

  type RedactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RedactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RedactionCountAggregateInputType | true
    }

  export interface RedactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redaction'], meta: { name: 'Redaction' } }
    /**
     * Find zero or one Redaction that matches the filter.
     * @param {RedactionFindUniqueArgs} args - Arguments to find a Redaction
     * @example
     * // Get one Redaction
     * const redaction = await prisma.redaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RedactionFindUniqueArgs>(args: SelectSubset<T, RedactionFindUniqueArgs<ExtArgs>>): Prisma__RedactionClient<$Result.GetResult<Prisma.$RedactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Redaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RedactionFindUniqueOrThrowArgs} args - Arguments to find a Redaction
     * @example
     * // Get one Redaction
     * const redaction = await prisma.redaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RedactionFindUniqueOrThrowArgs>(args: SelectSubset<T, RedactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RedactionClient<$Result.GetResult<Prisma.$RedactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Redaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedactionFindFirstArgs} args - Arguments to find a Redaction
     * @example
     * // Get one Redaction
     * const redaction = await prisma.redaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RedactionFindFirstArgs>(args?: SelectSubset<T, RedactionFindFirstArgs<ExtArgs>>): Prisma__RedactionClient<$Result.GetResult<Prisma.$RedactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Redaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedactionFindFirstOrThrowArgs} args - Arguments to find a Redaction
     * @example
     * // Get one Redaction
     * const redaction = await prisma.redaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RedactionFindFirstOrThrowArgs>(args?: SelectSubset<T, RedactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RedactionClient<$Result.GetResult<Prisma.$RedactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Redactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redactions
     * const redactions = await prisma.redaction.findMany()
     * 
     * // Get first 10 Redactions
     * const redactions = await prisma.redaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redactionWithIdOnly = await prisma.redaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RedactionFindManyArgs>(args?: SelectSubset<T, RedactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Redaction.
     * @param {RedactionCreateArgs} args - Arguments to create a Redaction.
     * @example
     * // Create one Redaction
     * const Redaction = await prisma.redaction.create({
     *   data: {
     *     // ... data to create a Redaction
     *   }
     * })
     * 
     */
    create<T extends RedactionCreateArgs>(args: SelectSubset<T, RedactionCreateArgs<ExtArgs>>): Prisma__RedactionClient<$Result.GetResult<Prisma.$RedactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Redactions.
     * @param {RedactionCreateManyArgs} args - Arguments to create many Redactions.
     * @example
     * // Create many Redactions
     * const redaction = await prisma.redaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RedactionCreateManyArgs>(args?: SelectSubset<T, RedactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redaction.
     * @param {RedactionDeleteArgs} args - Arguments to delete one Redaction.
     * @example
     * // Delete one Redaction
     * const Redaction = await prisma.redaction.delete({
     *   where: {
     *     // ... filter to delete one Redaction
     *   }
     * })
     * 
     */
    delete<T extends RedactionDeleteArgs>(args: SelectSubset<T, RedactionDeleteArgs<ExtArgs>>): Prisma__RedactionClient<$Result.GetResult<Prisma.$RedactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Redaction.
     * @param {RedactionUpdateArgs} args - Arguments to update one Redaction.
     * @example
     * // Update one Redaction
     * const redaction = await prisma.redaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RedactionUpdateArgs>(args: SelectSubset<T, RedactionUpdateArgs<ExtArgs>>): Prisma__RedactionClient<$Result.GetResult<Prisma.$RedactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Redactions.
     * @param {RedactionDeleteManyArgs} args - Arguments to filter Redactions to delete.
     * @example
     * // Delete a few Redactions
     * const { count } = await prisma.redaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RedactionDeleteManyArgs>(args?: SelectSubset<T, RedactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redactions
     * const redaction = await prisma.redaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RedactionUpdateManyArgs>(args: SelectSubset<T, RedactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redaction.
     * @param {RedactionUpsertArgs} args - Arguments to update or create a Redaction.
     * @example
     * // Update or create a Redaction
     * const redaction = await prisma.redaction.upsert({
     *   create: {
     *     // ... data to create a Redaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redaction we want to update
     *   }
     * })
     */
    upsert<T extends RedactionUpsertArgs>(args: SelectSubset<T, RedactionUpsertArgs<ExtArgs>>): Prisma__RedactionClient<$Result.GetResult<Prisma.$RedactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Redactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedactionCountArgs} args - Arguments to filter Redactions to count.
     * @example
     * // Count the number of Redactions
     * const count = await prisma.redaction.count({
     *   where: {
     *     // ... the filter for the Redactions we want to count
     *   }
     * })
    **/
    count<T extends RedactionCountArgs>(
      args?: Subset<T, RedactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RedactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RedactionAggregateArgs>(args: Subset<T, RedactionAggregateArgs>): Prisma.PrismaPromise<GetRedactionAggregateType<T>>

    /**
     * Group by Redaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RedactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RedactionGroupByArgs['orderBy'] }
        : { orderBy?: RedactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RedactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redaction model
   */
  readonly fields: RedactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RedactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lawyer<T extends LawyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LawyerDefaultArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Redaction model
   */
  interface RedactionFieldRefs {
    readonly id: FieldRef<"Redaction", 'String'>
    readonly userId: FieldRef<"Redaction", 'String'>
    readonly title: FieldRef<"Redaction", 'String'>
    readonly content: FieldRef<"Redaction", 'String'>
    readonly desc: FieldRef<"Redaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Redaction findUnique
   */
  export type RedactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redaction
     */
    select?: RedactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redaction
     */
    omit?: RedactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedactionInclude<ExtArgs> | null
    /**
     * Filter, which Redaction to fetch.
     */
    where: RedactionWhereUniqueInput
  }

  /**
   * Redaction findUniqueOrThrow
   */
  export type RedactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redaction
     */
    select?: RedactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redaction
     */
    omit?: RedactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedactionInclude<ExtArgs> | null
    /**
     * Filter, which Redaction to fetch.
     */
    where: RedactionWhereUniqueInput
  }

  /**
   * Redaction findFirst
   */
  export type RedactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redaction
     */
    select?: RedactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redaction
     */
    omit?: RedactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedactionInclude<ExtArgs> | null
    /**
     * Filter, which Redaction to fetch.
     */
    where?: RedactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redactions to fetch.
     */
    orderBy?: RedactionOrderByWithRelationInput | RedactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redactions.
     */
    cursor?: RedactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redactions.
     */
    distinct?: RedactionScalarFieldEnum | RedactionScalarFieldEnum[]
  }

  /**
   * Redaction findFirstOrThrow
   */
  export type RedactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redaction
     */
    select?: RedactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redaction
     */
    omit?: RedactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedactionInclude<ExtArgs> | null
    /**
     * Filter, which Redaction to fetch.
     */
    where?: RedactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redactions to fetch.
     */
    orderBy?: RedactionOrderByWithRelationInput | RedactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redactions.
     */
    cursor?: RedactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redactions.
     */
    distinct?: RedactionScalarFieldEnum | RedactionScalarFieldEnum[]
  }

  /**
   * Redaction findMany
   */
  export type RedactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redaction
     */
    select?: RedactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redaction
     */
    omit?: RedactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedactionInclude<ExtArgs> | null
    /**
     * Filter, which Redactions to fetch.
     */
    where?: RedactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redactions to fetch.
     */
    orderBy?: RedactionOrderByWithRelationInput | RedactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redactions.
     */
    cursor?: RedactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redactions.
     */
    skip?: number
    distinct?: RedactionScalarFieldEnum | RedactionScalarFieldEnum[]
  }

  /**
   * Redaction create
   */
  export type RedactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redaction
     */
    select?: RedactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redaction
     */
    omit?: RedactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Redaction.
     */
    data: XOR<RedactionCreateInput, RedactionUncheckedCreateInput>
  }

  /**
   * Redaction createMany
   */
  export type RedactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redactions.
     */
    data: RedactionCreateManyInput | RedactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Redaction update
   */
  export type RedactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redaction
     */
    select?: RedactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redaction
     */
    omit?: RedactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Redaction.
     */
    data: XOR<RedactionUpdateInput, RedactionUncheckedUpdateInput>
    /**
     * Choose, which Redaction to update.
     */
    where: RedactionWhereUniqueInput
  }

  /**
   * Redaction updateMany
   */
  export type RedactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redactions.
     */
    data: XOR<RedactionUpdateManyMutationInput, RedactionUncheckedUpdateManyInput>
    /**
     * Filter which Redactions to update
     */
    where?: RedactionWhereInput
    /**
     * Limit how many Redactions to update.
     */
    limit?: number
  }

  /**
   * Redaction upsert
   */
  export type RedactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redaction
     */
    select?: RedactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redaction
     */
    omit?: RedactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Redaction to update in case it exists.
     */
    where: RedactionWhereUniqueInput
    /**
     * In case the Redaction found by the `where` argument doesn't exist, create a new Redaction with this data.
     */
    create: XOR<RedactionCreateInput, RedactionUncheckedCreateInput>
    /**
     * In case the Redaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RedactionUpdateInput, RedactionUncheckedUpdateInput>
  }

  /**
   * Redaction delete
   */
  export type RedactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redaction
     */
    select?: RedactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redaction
     */
    omit?: RedactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedactionInclude<ExtArgs> | null
    /**
     * Filter which Redaction to delete.
     */
    where: RedactionWhereUniqueInput
  }

  /**
   * Redaction deleteMany
   */
  export type RedactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redactions to delete
     */
    where?: RedactionWhereInput
    /**
     * Limit how many Redactions to delete.
     */
    limit?: number
  }

  /**
   * Redaction without action
   */
  export type RedactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redaction
     */
    select?: RedactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redaction
     */
    omit?: RedactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedactionInclude<ExtArgs> | null
  }


  /**
   * Model ResolutionLitige
   */

  export type AggregateResolutionLitige = {
    _count: ResolutionLitigeCountAggregateOutputType | null
    _min: ResolutionLitigeMinAggregateOutputType | null
    _max: ResolutionLitigeMaxAggregateOutputType | null
  }

  export type ResolutionLitigeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    desc: string | null
  }

  export type ResolutionLitigeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    desc: string | null
  }

  export type ResolutionLitigeCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    desc: number
    _all: number
  }


  export type ResolutionLitigeMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
  }

  export type ResolutionLitigeMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
  }

  export type ResolutionLitigeCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
    _all?: true
  }

  export type ResolutionLitigeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResolutionLitige to aggregate.
     */
    where?: ResolutionLitigeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResolutionLitiges to fetch.
     */
    orderBy?: ResolutionLitigeOrderByWithRelationInput | ResolutionLitigeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResolutionLitigeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResolutionLitiges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResolutionLitiges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResolutionLitiges
    **/
    _count?: true | ResolutionLitigeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResolutionLitigeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResolutionLitigeMaxAggregateInputType
  }

  export type GetResolutionLitigeAggregateType<T extends ResolutionLitigeAggregateArgs> = {
        [P in keyof T & keyof AggregateResolutionLitige]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResolutionLitige[P]>
      : GetScalarType<T[P], AggregateResolutionLitige[P]>
  }




  export type ResolutionLitigeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResolutionLitigeWhereInput
    orderBy?: ResolutionLitigeOrderByWithAggregationInput | ResolutionLitigeOrderByWithAggregationInput[]
    by: ResolutionLitigeScalarFieldEnum[] | ResolutionLitigeScalarFieldEnum
    having?: ResolutionLitigeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResolutionLitigeCountAggregateInputType | true
    _min?: ResolutionLitigeMinAggregateInputType
    _max?: ResolutionLitigeMaxAggregateInputType
  }

  export type ResolutionLitigeGroupByOutputType = {
    id: string
    userId: string
    title: string
    content: string
    desc: string
    _count: ResolutionLitigeCountAggregateOutputType | null
    _min: ResolutionLitigeMinAggregateOutputType | null
    _max: ResolutionLitigeMaxAggregateOutputType | null
  }

  type GetResolutionLitigeGroupByPayload<T extends ResolutionLitigeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResolutionLitigeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResolutionLitigeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResolutionLitigeGroupByOutputType[P]>
            : GetScalarType<T[P], ResolutionLitigeGroupByOutputType[P]>
        }
      >
    >


  export type ResolutionLitigeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    desc?: boolean
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resolutionLitige"]>



  export type ResolutionLitigeSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    desc?: boolean
  }

  export type ResolutionLitigeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "content" | "desc", ExtArgs["result"]["resolutionLitige"]>
  export type ResolutionLitigeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }

  export type $ResolutionLitigePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResolutionLitige"
    objects: {
      lawyer: Prisma.$LawyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      content: string
      desc: string
    }, ExtArgs["result"]["resolutionLitige"]>
    composites: {}
  }

  type ResolutionLitigeGetPayload<S extends boolean | null | undefined | ResolutionLitigeDefaultArgs> = $Result.GetResult<Prisma.$ResolutionLitigePayload, S>

  type ResolutionLitigeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResolutionLitigeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResolutionLitigeCountAggregateInputType | true
    }

  export interface ResolutionLitigeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResolutionLitige'], meta: { name: 'ResolutionLitige' } }
    /**
     * Find zero or one ResolutionLitige that matches the filter.
     * @param {ResolutionLitigeFindUniqueArgs} args - Arguments to find a ResolutionLitige
     * @example
     * // Get one ResolutionLitige
     * const resolutionLitige = await prisma.resolutionLitige.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResolutionLitigeFindUniqueArgs>(args: SelectSubset<T, ResolutionLitigeFindUniqueArgs<ExtArgs>>): Prisma__ResolutionLitigeClient<$Result.GetResult<Prisma.$ResolutionLitigePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResolutionLitige that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResolutionLitigeFindUniqueOrThrowArgs} args - Arguments to find a ResolutionLitige
     * @example
     * // Get one ResolutionLitige
     * const resolutionLitige = await prisma.resolutionLitige.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResolutionLitigeFindUniqueOrThrowArgs>(args: SelectSubset<T, ResolutionLitigeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResolutionLitigeClient<$Result.GetResult<Prisma.$ResolutionLitigePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResolutionLitige that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResolutionLitigeFindFirstArgs} args - Arguments to find a ResolutionLitige
     * @example
     * // Get one ResolutionLitige
     * const resolutionLitige = await prisma.resolutionLitige.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResolutionLitigeFindFirstArgs>(args?: SelectSubset<T, ResolutionLitigeFindFirstArgs<ExtArgs>>): Prisma__ResolutionLitigeClient<$Result.GetResult<Prisma.$ResolutionLitigePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResolutionLitige that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResolutionLitigeFindFirstOrThrowArgs} args - Arguments to find a ResolutionLitige
     * @example
     * // Get one ResolutionLitige
     * const resolutionLitige = await prisma.resolutionLitige.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResolutionLitigeFindFirstOrThrowArgs>(args?: SelectSubset<T, ResolutionLitigeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResolutionLitigeClient<$Result.GetResult<Prisma.$ResolutionLitigePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResolutionLitiges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResolutionLitigeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResolutionLitiges
     * const resolutionLitiges = await prisma.resolutionLitige.findMany()
     * 
     * // Get first 10 ResolutionLitiges
     * const resolutionLitiges = await prisma.resolutionLitige.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resolutionLitigeWithIdOnly = await prisma.resolutionLitige.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResolutionLitigeFindManyArgs>(args?: SelectSubset<T, ResolutionLitigeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResolutionLitigePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResolutionLitige.
     * @param {ResolutionLitigeCreateArgs} args - Arguments to create a ResolutionLitige.
     * @example
     * // Create one ResolutionLitige
     * const ResolutionLitige = await prisma.resolutionLitige.create({
     *   data: {
     *     // ... data to create a ResolutionLitige
     *   }
     * })
     * 
     */
    create<T extends ResolutionLitigeCreateArgs>(args: SelectSubset<T, ResolutionLitigeCreateArgs<ExtArgs>>): Prisma__ResolutionLitigeClient<$Result.GetResult<Prisma.$ResolutionLitigePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResolutionLitiges.
     * @param {ResolutionLitigeCreateManyArgs} args - Arguments to create many ResolutionLitiges.
     * @example
     * // Create many ResolutionLitiges
     * const resolutionLitige = await prisma.resolutionLitige.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResolutionLitigeCreateManyArgs>(args?: SelectSubset<T, ResolutionLitigeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ResolutionLitige.
     * @param {ResolutionLitigeDeleteArgs} args - Arguments to delete one ResolutionLitige.
     * @example
     * // Delete one ResolutionLitige
     * const ResolutionLitige = await prisma.resolutionLitige.delete({
     *   where: {
     *     // ... filter to delete one ResolutionLitige
     *   }
     * })
     * 
     */
    delete<T extends ResolutionLitigeDeleteArgs>(args: SelectSubset<T, ResolutionLitigeDeleteArgs<ExtArgs>>): Prisma__ResolutionLitigeClient<$Result.GetResult<Prisma.$ResolutionLitigePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResolutionLitige.
     * @param {ResolutionLitigeUpdateArgs} args - Arguments to update one ResolutionLitige.
     * @example
     * // Update one ResolutionLitige
     * const resolutionLitige = await prisma.resolutionLitige.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResolutionLitigeUpdateArgs>(args: SelectSubset<T, ResolutionLitigeUpdateArgs<ExtArgs>>): Prisma__ResolutionLitigeClient<$Result.GetResult<Prisma.$ResolutionLitigePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResolutionLitiges.
     * @param {ResolutionLitigeDeleteManyArgs} args - Arguments to filter ResolutionLitiges to delete.
     * @example
     * // Delete a few ResolutionLitiges
     * const { count } = await prisma.resolutionLitige.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResolutionLitigeDeleteManyArgs>(args?: SelectSubset<T, ResolutionLitigeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResolutionLitiges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResolutionLitigeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResolutionLitiges
     * const resolutionLitige = await prisma.resolutionLitige.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResolutionLitigeUpdateManyArgs>(args: SelectSubset<T, ResolutionLitigeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResolutionLitige.
     * @param {ResolutionLitigeUpsertArgs} args - Arguments to update or create a ResolutionLitige.
     * @example
     * // Update or create a ResolutionLitige
     * const resolutionLitige = await prisma.resolutionLitige.upsert({
     *   create: {
     *     // ... data to create a ResolutionLitige
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResolutionLitige we want to update
     *   }
     * })
     */
    upsert<T extends ResolutionLitigeUpsertArgs>(args: SelectSubset<T, ResolutionLitigeUpsertArgs<ExtArgs>>): Prisma__ResolutionLitigeClient<$Result.GetResult<Prisma.$ResolutionLitigePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResolutionLitiges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResolutionLitigeCountArgs} args - Arguments to filter ResolutionLitiges to count.
     * @example
     * // Count the number of ResolutionLitiges
     * const count = await prisma.resolutionLitige.count({
     *   where: {
     *     // ... the filter for the ResolutionLitiges we want to count
     *   }
     * })
    **/
    count<T extends ResolutionLitigeCountArgs>(
      args?: Subset<T, ResolutionLitigeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResolutionLitigeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResolutionLitige.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResolutionLitigeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResolutionLitigeAggregateArgs>(args: Subset<T, ResolutionLitigeAggregateArgs>): Prisma.PrismaPromise<GetResolutionLitigeAggregateType<T>>

    /**
     * Group by ResolutionLitige.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResolutionLitigeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResolutionLitigeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResolutionLitigeGroupByArgs['orderBy'] }
        : { orderBy?: ResolutionLitigeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResolutionLitigeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResolutionLitigeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResolutionLitige model
   */
  readonly fields: ResolutionLitigeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResolutionLitige.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResolutionLitigeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lawyer<T extends LawyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LawyerDefaultArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResolutionLitige model
   */
  interface ResolutionLitigeFieldRefs {
    readonly id: FieldRef<"ResolutionLitige", 'String'>
    readonly userId: FieldRef<"ResolutionLitige", 'String'>
    readonly title: FieldRef<"ResolutionLitige", 'String'>
    readonly content: FieldRef<"ResolutionLitige", 'String'>
    readonly desc: FieldRef<"ResolutionLitige", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ResolutionLitige findUnique
   */
  export type ResolutionLitigeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResolutionLitige
     */
    select?: ResolutionLitigeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResolutionLitige
     */
    omit?: ResolutionLitigeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResolutionLitigeInclude<ExtArgs> | null
    /**
     * Filter, which ResolutionLitige to fetch.
     */
    where: ResolutionLitigeWhereUniqueInput
  }

  /**
   * ResolutionLitige findUniqueOrThrow
   */
  export type ResolutionLitigeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResolutionLitige
     */
    select?: ResolutionLitigeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResolutionLitige
     */
    omit?: ResolutionLitigeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResolutionLitigeInclude<ExtArgs> | null
    /**
     * Filter, which ResolutionLitige to fetch.
     */
    where: ResolutionLitigeWhereUniqueInput
  }

  /**
   * ResolutionLitige findFirst
   */
  export type ResolutionLitigeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResolutionLitige
     */
    select?: ResolutionLitigeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResolutionLitige
     */
    omit?: ResolutionLitigeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResolutionLitigeInclude<ExtArgs> | null
    /**
     * Filter, which ResolutionLitige to fetch.
     */
    where?: ResolutionLitigeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResolutionLitiges to fetch.
     */
    orderBy?: ResolutionLitigeOrderByWithRelationInput | ResolutionLitigeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResolutionLitiges.
     */
    cursor?: ResolutionLitigeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResolutionLitiges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResolutionLitiges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResolutionLitiges.
     */
    distinct?: ResolutionLitigeScalarFieldEnum | ResolutionLitigeScalarFieldEnum[]
  }

  /**
   * ResolutionLitige findFirstOrThrow
   */
  export type ResolutionLitigeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResolutionLitige
     */
    select?: ResolutionLitigeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResolutionLitige
     */
    omit?: ResolutionLitigeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResolutionLitigeInclude<ExtArgs> | null
    /**
     * Filter, which ResolutionLitige to fetch.
     */
    where?: ResolutionLitigeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResolutionLitiges to fetch.
     */
    orderBy?: ResolutionLitigeOrderByWithRelationInput | ResolutionLitigeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResolutionLitiges.
     */
    cursor?: ResolutionLitigeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResolutionLitiges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResolutionLitiges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResolutionLitiges.
     */
    distinct?: ResolutionLitigeScalarFieldEnum | ResolutionLitigeScalarFieldEnum[]
  }

  /**
   * ResolutionLitige findMany
   */
  export type ResolutionLitigeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResolutionLitige
     */
    select?: ResolutionLitigeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResolutionLitige
     */
    omit?: ResolutionLitigeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResolutionLitigeInclude<ExtArgs> | null
    /**
     * Filter, which ResolutionLitiges to fetch.
     */
    where?: ResolutionLitigeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResolutionLitiges to fetch.
     */
    orderBy?: ResolutionLitigeOrderByWithRelationInput | ResolutionLitigeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResolutionLitiges.
     */
    cursor?: ResolutionLitigeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResolutionLitiges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResolutionLitiges.
     */
    skip?: number
    distinct?: ResolutionLitigeScalarFieldEnum | ResolutionLitigeScalarFieldEnum[]
  }

  /**
   * ResolutionLitige create
   */
  export type ResolutionLitigeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResolutionLitige
     */
    select?: ResolutionLitigeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResolutionLitige
     */
    omit?: ResolutionLitigeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResolutionLitigeInclude<ExtArgs> | null
    /**
     * The data needed to create a ResolutionLitige.
     */
    data: XOR<ResolutionLitigeCreateInput, ResolutionLitigeUncheckedCreateInput>
  }

  /**
   * ResolutionLitige createMany
   */
  export type ResolutionLitigeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResolutionLitiges.
     */
    data: ResolutionLitigeCreateManyInput | ResolutionLitigeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResolutionLitige update
   */
  export type ResolutionLitigeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResolutionLitige
     */
    select?: ResolutionLitigeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResolutionLitige
     */
    omit?: ResolutionLitigeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResolutionLitigeInclude<ExtArgs> | null
    /**
     * The data needed to update a ResolutionLitige.
     */
    data: XOR<ResolutionLitigeUpdateInput, ResolutionLitigeUncheckedUpdateInput>
    /**
     * Choose, which ResolutionLitige to update.
     */
    where: ResolutionLitigeWhereUniqueInput
  }

  /**
   * ResolutionLitige updateMany
   */
  export type ResolutionLitigeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResolutionLitiges.
     */
    data: XOR<ResolutionLitigeUpdateManyMutationInput, ResolutionLitigeUncheckedUpdateManyInput>
    /**
     * Filter which ResolutionLitiges to update
     */
    where?: ResolutionLitigeWhereInput
    /**
     * Limit how many ResolutionLitiges to update.
     */
    limit?: number
  }

  /**
   * ResolutionLitige upsert
   */
  export type ResolutionLitigeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResolutionLitige
     */
    select?: ResolutionLitigeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResolutionLitige
     */
    omit?: ResolutionLitigeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResolutionLitigeInclude<ExtArgs> | null
    /**
     * The filter to search for the ResolutionLitige to update in case it exists.
     */
    where: ResolutionLitigeWhereUniqueInput
    /**
     * In case the ResolutionLitige found by the `where` argument doesn't exist, create a new ResolutionLitige with this data.
     */
    create: XOR<ResolutionLitigeCreateInput, ResolutionLitigeUncheckedCreateInput>
    /**
     * In case the ResolutionLitige was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResolutionLitigeUpdateInput, ResolutionLitigeUncheckedUpdateInput>
  }

  /**
   * ResolutionLitige delete
   */
  export type ResolutionLitigeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResolutionLitige
     */
    select?: ResolutionLitigeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResolutionLitige
     */
    omit?: ResolutionLitigeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResolutionLitigeInclude<ExtArgs> | null
    /**
     * Filter which ResolutionLitige to delete.
     */
    where: ResolutionLitigeWhereUniqueInput
  }

  /**
   * ResolutionLitige deleteMany
   */
  export type ResolutionLitigeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResolutionLitiges to delete
     */
    where?: ResolutionLitigeWhereInput
    /**
     * Limit how many ResolutionLitiges to delete.
     */
    limit?: number
  }

  /**
   * ResolutionLitige without action
   */
  export type ResolutionLitigeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResolutionLitige
     */
    select?: ResolutionLitigeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResolutionLitige
     */
    omit?: ResolutionLitigeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResolutionLitigeInclude<ExtArgs> | null
  }


  /**
   * Model ServiceParDomaine
   */

  export type AggregateServiceParDomaine = {
    _count: ServiceParDomaineCountAggregateOutputType | null
    _min: ServiceParDomaineMinAggregateOutputType | null
    _max: ServiceParDomaineMaxAggregateOutputType | null
  }

  export type ServiceParDomaineMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    desc: string | null
  }

  export type ServiceParDomaineMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    desc: string | null
  }

  export type ServiceParDomaineCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    desc: number
    _all: number
  }


  export type ServiceParDomaineMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
  }

  export type ServiceParDomaineMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
  }

  export type ServiceParDomaineCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
    _all?: true
  }

  export type ServiceParDomaineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceParDomaine to aggregate.
     */
    where?: ServiceParDomaineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceParDomaines to fetch.
     */
    orderBy?: ServiceParDomaineOrderByWithRelationInput | ServiceParDomaineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceParDomaineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceParDomaines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceParDomaines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceParDomaines
    **/
    _count?: true | ServiceParDomaineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceParDomaineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceParDomaineMaxAggregateInputType
  }

  export type GetServiceParDomaineAggregateType<T extends ServiceParDomaineAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceParDomaine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceParDomaine[P]>
      : GetScalarType<T[P], AggregateServiceParDomaine[P]>
  }




  export type ServiceParDomaineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceParDomaineWhereInput
    orderBy?: ServiceParDomaineOrderByWithAggregationInput | ServiceParDomaineOrderByWithAggregationInput[]
    by: ServiceParDomaineScalarFieldEnum[] | ServiceParDomaineScalarFieldEnum
    having?: ServiceParDomaineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceParDomaineCountAggregateInputType | true
    _min?: ServiceParDomaineMinAggregateInputType
    _max?: ServiceParDomaineMaxAggregateInputType
  }

  export type ServiceParDomaineGroupByOutputType = {
    id: string
    userId: string
    title: string
    content: string
    desc: string
    _count: ServiceParDomaineCountAggregateOutputType | null
    _min: ServiceParDomaineMinAggregateOutputType | null
    _max: ServiceParDomaineMaxAggregateOutputType | null
  }

  type GetServiceParDomaineGroupByPayload<T extends ServiceParDomaineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceParDomaineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceParDomaineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceParDomaineGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceParDomaineGroupByOutputType[P]>
        }
      >
    >


  export type ServiceParDomaineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    desc?: boolean
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceParDomaine"]>



  export type ServiceParDomaineSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    desc?: boolean
  }

  export type ServiceParDomaineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "content" | "desc", ExtArgs["result"]["serviceParDomaine"]>
  export type ServiceParDomaineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }

  export type $ServiceParDomainePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceParDomaine"
    objects: {
      lawyer: Prisma.$LawyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      content: string
      desc: string
    }, ExtArgs["result"]["serviceParDomaine"]>
    composites: {}
  }

  type ServiceParDomaineGetPayload<S extends boolean | null | undefined | ServiceParDomaineDefaultArgs> = $Result.GetResult<Prisma.$ServiceParDomainePayload, S>

  type ServiceParDomaineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceParDomaineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceParDomaineCountAggregateInputType | true
    }

  export interface ServiceParDomaineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceParDomaine'], meta: { name: 'ServiceParDomaine' } }
    /**
     * Find zero or one ServiceParDomaine that matches the filter.
     * @param {ServiceParDomaineFindUniqueArgs} args - Arguments to find a ServiceParDomaine
     * @example
     * // Get one ServiceParDomaine
     * const serviceParDomaine = await prisma.serviceParDomaine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceParDomaineFindUniqueArgs>(args: SelectSubset<T, ServiceParDomaineFindUniqueArgs<ExtArgs>>): Prisma__ServiceParDomaineClient<$Result.GetResult<Prisma.$ServiceParDomainePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceParDomaine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceParDomaineFindUniqueOrThrowArgs} args - Arguments to find a ServiceParDomaine
     * @example
     * // Get one ServiceParDomaine
     * const serviceParDomaine = await prisma.serviceParDomaine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceParDomaineFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceParDomaineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceParDomaineClient<$Result.GetResult<Prisma.$ServiceParDomainePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceParDomaine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceParDomaineFindFirstArgs} args - Arguments to find a ServiceParDomaine
     * @example
     * // Get one ServiceParDomaine
     * const serviceParDomaine = await prisma.serviceParDomaine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceParDomaineFindFirstArgs>(args?: SelectSubset<T, ServiceParDomaineFindFirstArgs<ExtArgs>>): Prisma__ServiceParDomaineClient<$Result.GetResult<Prisma.$ServiceParDomainePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceParDomaine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceParDomaineFindFirstOrThrowArgs} args - Arguments to find a ServiceParDomaine
     * @example
     * // Get one ServiceParDomaine
     * const serviceParDomaine = await prisma.serviceParDomaine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceParDomaineFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceParDomaineFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceParDomaineClient<$Result.GetResult<Prisma.$ServiceParDomainePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceParDomaines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceParDomaineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceParDomaines
     * const serviceParDomaines = await prisma.serviceParDomaine.findMany()
     * 
     * // Get first 10 ServiceParDomaines
     * const serviceParDomaines = await prisma.serviceParDomaine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceParDomaineWithIdOnly = await prisma.serviceParDomaine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceParDomaineFindManyArgs>(args?: SelectSubset<T, ServiceParDomaineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceParDomainePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceParDomaine.
     * @param {ServiceParDomaineCreateArgs} args - Arguments to create a ServiceParDomaine.
     * @example
     * // Create one ServiceParDomaine
     * const ServiceParDomaine = await prisma.serviceParDomaine.create({
     *   data: {
     *     // ... data to create a ServiceParDomaine
     *   }
     * })
     * 
     */
    create<T extends ServiceParDomaineCreateArgs>(args: SelectSubset<T, ServiceParDomaineCreateArgs<ExtArgs>>): Prisma__ServiceParDomaineClient<$Result.GetResult<Prisma.$ServiceParDomainePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceParDomaines.
     * @param {ServiceParDomaineCreateManyArgs} args - Arguments to create many ServiceParDomaines.
     * @example
     * // Create many ServiceParDomaines
     * const serviceParDomaine = await prisma.serviceParDomaine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceParDomaineCreateManyArgs>(args?: SelectSubset<T, ServiceParDomaineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceParDomaine.
     * @param {ServiceParDomaineDeleteArgs} args - Arguments to delete one ServiceParDomaine.
     * @example
     * // Delete one ServiceParDomaine
     * const ServiceParDomaine = await prisma.serviceParDomaine.delete({
     *   where: {
     *     // ... filter to delete one ServiceParDomaine
     *   }
     * })
     * 
     */
    delete<T extends ServiceParDomaineDeleteArgs>(args: SelectSubset<T, ServiceParDomaineDeleteArgs<ExtArgs>>): Prisma__ServiceParDomaineClient<$Result.GetResult<Prisma.$ServiceParDomainePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceParDomaine.
     * @param {ServiceParDomaineUpdateArgs} args - Arguments to update one ServiceParDomaine.
     * @example
     * // Update one ServiceParDomaine
     * const serviceParDomaine = await prisma.serviceParDomaine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceParDomaineUpdateArgs>(args: SelectSubset<T, ServiceParDomaineUpdateArgs<ExtArgs>>): Prisma__ServiceParDomaineClient<$Result.GetResult<Prisma.$ServiceParDomainePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceParDomaines.
     * @param {ServiceParDomaineDeleteManyArgs} args - Arguments to filter ServiceParDomaines to delete.
     * @example
     * // Delete a few ServiceParDomaines
     * const { count } = await prisma.serviceParDomaine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceParDomaineDeleteManyArgs>(args?: SelectSubset<T, ServiceParDomaineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceParDomaines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceParDomaineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceParDomaines
     * const serviceParDomaine = await prisma.serviceParDomaine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceParDomaineUpdateManyArgs>(args: SelectSubset<T, ServiceParDomaineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceParDomaine.
     * @param {ServiceParDomaineUpsertArgs} args - Arguments to update or create a ServiceParDomaine.
     * @example
     * // Update or create a ServiceParDomaine
     * const serviceParDomaine = await prisma.serviceParDomaine.upsert({
     *   create: {
     *     // ... data to create a ServiceParDomaine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceParDomaine we want to update
     *   }
     * })
     */
    upsert<T extends ServiceParDomaineUpsertArgs>(args: SelectSubset<T, ServiceParDomaineUpsertArgs<ExtArgs>>): Prisma__ServiceParDomaineClient<$Result.GetResult<Prisma.$ServiceParDomainePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceParDomaines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceParDomaineCountArgs} args - Arguments to filter ServiceParDomaines to count.
     * @example
     * // Count the number of ServiceParDomaines
     * const count = await prisma.serviceParDomaine.count({
     *   where: {
     *     // ... the filter for the ServiceParDomaines we want to count
     *   }
     * })
    **/
    count<T extends ServiceParDomaineCountArgs>(
      args?: Subset<T, ServiceParDomaineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceParDomaineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceParDomaine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceParDomaineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceParDomaineAggregateArgs>(args: Subset<T, ServiceParDomaineAggregateArgs>): Prisma.PrismaPromise<GetServiceParDomaineAggregateType<T>>

    /**
     * Group by ServiceParDomaine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceParDomaineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceParDomaineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceParDomaineGroupByArgs['orderBy'] }
        : { orderBy?: ServiceParDomaineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceParDomaineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceParDomaineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceParDomaine model
   */
  readonly fields: ServiceParDomaineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceParDomaine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceParDomaineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lawyer<T extends LawyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LawyerDefaultArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceParDomaine model
   */
  interface ServiceParDomaineFieldRefs {
    readonly id: FieldRef<"ServiceParDomaine", 'String'>
    readonly userId: FieldRef<"ServiceParDomaine", 'String'>
    readonly title: FieldRef<"ServiceParDomaine", 'String'>
    readonly content: FieldRef<"ServiceParDomaine", 'String'>
    readonly desc: FieldRef<"ServiceParDomaine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceParDomaine findUnique
   */
  export type ServiceParDomaineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceParDomaine
     */
    select?: ServiceParDomaineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceParDomaine
     */
    omit?: ServiceParDomaineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceParDomaineInclude<ExtArgs> | null
    /**
     * Filter, which ServiceParDomaine to fetch.
     */
    where: ServiceParDomaineWhereUniqueInput
  }

  /**
   * ServiceParDomaine findUniqueOrThrow
   */
  export type ServiceParDomaineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceParDomaine
     */
    select?: ServiceParDomaineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceParDomaine
     */
    omit?: ServiceParDomaineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceParDomaineInclude<ExtArgs> | null
    /**
     * Filter, which ServiceParDomaine to fetch.
     */
    where: ServiceParDomaineWhereUniqueInput
  }

  /**
   * ServiceParDomaine findFirst
   */
  export type ServiceParDomaineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceParDomaine
     */
    select?: ServiceParDomaineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceParDomaine
     */
    omit?: ServiceParDomaineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceParDomaineInclude<ExtArgs> | null
    /**
     * Filter, which ServiceParDomaine to fetch.
     */
    where?: ServiceParDomaineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceParDomaines to fetch.
     */
    orderBy?: ServiceParDomaineOrderByWithRelationInput | ServiceParDomaineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceParDomaines.
     */
    cursor?: ServiceParDomaineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceParDomaines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceParDomaines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceParDomaines.
     */
    distinct?: ServiceParDomaineScalarFieldEnum | ServiceParDomaineScalarFieldEnum[]
  }

  /**
   * ServiceParDomaine findFirstOrThrow
   */
  export type ServiceParDomaineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceParDomaine
     */
    select?: ServiceParDomaineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceParDomaine
     */
    omit?: ServiceParDomaineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceParDomaineInclude<ExtArgs> | null
    /**
     * Filter, which ServiceParDomaine to fetch.
     */
    where?: ServiceParDomaineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceParDomaines to fetch.
     */
    orderBy?: ServiceParDomaineOrderByWithRelationInput | ServiceParDomaineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceParDomaines.
     */
    cursor?: ServiceParDomaineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceParDomaines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceParDomaines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceParDomaines.
     */
    distinct?: ServiceParDomaineScalarFieldEnum | ServiceParDomaineScalarFieldEnum[]
  }

  /**
   * ServiceParDomaine findMany
   */
  export type ServiceParDomaineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceParDomaine
     */
    select?: ServiceParDomaineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceParDomaine
     */
    omit?: ServiceParDomaineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceParDomaineInclude<ExtArgs> | null
    /**
     * Filter, which ServiceParDomaines to fetch.
     */
    where?: ServiceParDomaineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceParDomaines to fetch.
     */
    orderBy?: ServiceParDomaineOrderByWithRelationInput | ServiceParDomaineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceParDomaines.
     */
    cursor?: ServiceParDomaineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceParDomaines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceParDomaines.
     */
    skip?: number
    distinct?: ServiceParDomaineScalarFieldEnum | ServiceParDomaineScalarFieldEnum[]
  }

  /**
   * ServiceParDomaine create
   */
  export type ServiceParDomaineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceParDomaine
     */
    select?: ServiceParDomaineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceParDomaine
     */
    omit?: ServiceParDomaineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceParDomaineInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceParDomaine.
     */
    data: XOR<ServiceParDomaineCreateInput, ServiceParDomaineUncheckedCreateInput>
  }

  /**
   * ServiceParDomaine createMany
   */
  export type ServiceParDomaineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceParDomaines.
     */
    data: ServiceParDomaineCreateManyInput | ServiceParDomaineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceParDomaine update
   */
  export type ServiceParDomaineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceParDomaine
     */
    select?: ServiceParDomaineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceParDomaine
     */
    omit?: ServiceParDomaineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceParDomaineInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceParDomaine.
     */
    data: XOR<ServiceParDomaineUpdateInput, ServiceParDomaineUncheckedUpdateInput>
    /**
     * Choose, which ServiceParDomaine to update.
     */
    where: ServiceParDomaineWhereUniqueInput
  }

  /**
   * ServiceParDomaine updateMany
   */
  export type ServiceParDomaineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceParDomaines.
     */
    data: XOR<ServiceParDomaineUpdateManyMutationInput, ServiceParDomaineUncheckedUpdateManyInput>
    /**
     * Filter which ServiceParDomaines to update
     */
    where?: ServiceParDomaineWhereInput
    /**
     * Limit how many ServiceParDomaines to update.
     */
    limit?: number
  }

  /**
   * ServiceParDomaine upsert
   */
  export type ServiceParDomaineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceParDomaine
     */
    select?: ServiceParDomaineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceParDomaine
     */
    omit?: ServiceParDomaineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceParDomaineInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceParDomaine to update in case it exists.
     */
    where: ServiceParDomaineWhereUniqueInput
    /**
     * In case the ServiceParDomaine found by the `where` argument doesn't exist, create a new ServiceParDomaine with this data.
     */
    create: XOR<ServiceParDomaineCreateInput, ServiceParDomaineUncheckedCreateInput>
    /**
     * In case the ServiceParDomaine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceParDomaineUpdateInput, ServiceParDomaineUncheckedUpdateInput>
  }

  /**
   * ServiceParDomaine delete
   */
  export type ServiceParDomaineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceParDomaine
     */
    select?: ServiceParDomaineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceParDomaine
     */
    omit?: ServiceParDomaineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceParDomaineInclude<ExtArgs> | null
    /**
     * Filter which ServiceParDomaine to delete.
     */
    where: ServiceParDomaineWhereUniqueInput
  }

  /**
   * ServiceParDomaine deleteMany
   */
  export type ServiceParDomaineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceParDomaines to delete
     */
    where?: ServiceParDomaineWhereInput
    /**
     * Limit how many ServiceParDomaines to delete.
     */
    limit?: number
  }

  /**
   * ServiceParDomaine without action
   */
  export type ServiceParDomaineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceParDomaine
     */
    select?: ServiceParDomaineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceParDomaine
     */
    omit?: ServiceParDomaineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceParDomaineInclude<ExtArgs> | null
  }


  /**
   * Model Preventifs
   */

  export type AggregatePreventifs = {
    _count: PreventifsCountAggregateOutputType | null
    _min: PreventifsMinAggregateOutputType | null
    _max: PreventifsMaxAggregateOutputType | null
  }

  export type PreventifsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    desc: string | null
  }

  export type PreventifsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    desc: string | null
  }

  export type PreventifsCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    desc: number
    _all: number
  }


  export type PreventifsMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
  }

  export type PreventifsMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
  }

  export type PreventifsCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
    _all?: true
  }

  export type PreventifsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Preventifs to aggregate.
     */
    where?: PreventifsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preventifs to fetch.
     */
    orderBy?: PreventifsOrderByWithRelationInput | PreventifsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PreventifsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preventifs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preventifs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Preventifs
    **/
    _count?: true | PreventifsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PreventifsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PreventifsMaxAggregateInputType
  }

  export type GetPreventifsAggregateType<T extends PreventifsAggregateArgs> = {
        [P in keyof T & keyof AggregatePreventifs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePreventifs[P]>
      : GetScalarType<T[P], AggregatePreventifs[P]>
  }




  export type PreventifsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PreventifsWhereInput
    orderBy?: PreventifsOrderByWithAggregationInput | PreventifsOrderByWithAggregationInput[]
    by: PreventifsScalarFieldEnum[] | PreventifsScalarFieldEnum
    having?: PreventifsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PreventifsCountAggregateInputType | true
    _min?: PreventifsMinAggregateInputType
    _max?: PreventifsMaxAggregateInputType
  }

  export type PreventifsGroupByOutputType = {
    id: string
    userId: string
    title: string
    content: string
    desc: string
    _count: PreventifsCountAggregateOutputType | null
    _min: PreventifsMinAggregateOutputType | null
    _max: PreventifsMaxAggregateOutputType | null
  }

  type GetPreventifsGroupByPayload<T extends PreventifsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PreventifsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PreventifsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PreventifsGroupByOutputType[P]>
            : GetScalarType<T[P], PreventifsGroupByOutputType[P]>
        }
      >
    >


  export type PreventifsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    desc?: boolean
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["preventifs"]>



  export type PreventifsSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    desc?: boolean
  }

  export type PreventifsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "content" | "desc", ExtArgs["result"]["preventifs"]>
  export type PreventifsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }

  export type $PreventifsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Preventifs"
    objects: {
      lawyer: Prisma.$LawyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      content: string
      desc: string
    }, ExtArgs["result"]["preventifs"]>
    composites: {}
  }

  type PreventifsGetPayload<S extends boolean | null | undefined | PreventifsDefaultArgs> = $Result.GetResult<Prisma.$PreventifsPayload, S>

  type PreventifsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PreventifsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PreventifsCountAggregateInputType | true
    }

  export interface PreventifsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Preventifs'], meta: { name: 'Preventifs' } }
    /**
     * Find zero or one Preventifs that matches the filter.
     * @param {PreventifsFindUniqueArgs} args - Arguments to find a Preventifs
     * @example
     * // Get one Preventifs
     * const preventifs = await prisma.preventifs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PreventifsFindUniqueArgs>(args: SelectSubset<T, PreventifsFindUniqueArgs<ExtArgs>>): Prisma__PreventifsClient<$Result.GetResult<Prisma.$PreventifsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Preventifs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PreventifsFindUniqueOrThrowArgs} args - Arguments to find a Preventifs
     * @example
     * // Get one Preventifs
     * const preventifs = await prisma.preventifs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PreventifsFindUniqueOrThrowArgs>(args: SelectSubset<T, PreventifsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PreventifsClient<$Result.GetResult<Prisma.$PreventifsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Preventifs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventifsFindFirstArgs} args - Arguments to find a Preventifs
     * @example
     * // Get one Preventifs
     * const preventifs = await prisma.preventifs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PreventifsFindFirstArgs>(args?: SelectSubset<T, PreventifsFindFirstArgs<ExtArgs>>): Prisma__PreventifsClient<$Result.GetResult<Prisma.$PreventifsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Preventifs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventifsFindFirstOrThrowArgs} args - Arguments to find a Preventifs
     * @example
     * // Get one Preventifs
     * const preventifs = await prisma.preventifs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PreventifsFindFirstOrThrowArgs>(args?: SelectSubset<T, PreventifsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PreventifsClient<$Result.GetResult<Prisma.$PreventifsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Preventifs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventifsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Preventifs
     * const preventifs = await prisma.preventifs.findMany()
     * 
     * // Get first 10 Preventifs
     * const preventifs = await prisma.preventifs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const preventifsWithIdOnly = await prisma.preventifs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PreventifsFindManyArgs>(args?: SelectSubset<T, PreventifsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PreventifsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Preventifs.
     * @param {PreventifsCreateArgs} args - Arguments to create a Preventifs.
     * @example
     * // Create one Preventifs
     * const Preventifs = await prisma.preventifs.create({
     *   data: {
     *     // ... data to create a Preventifs
     *   }
     * })
     * 
     */
    create<T extends PreventifsCreateArgs>(args: SelectSubset<T, PreventifsCreateArgs<ExtArgs>>): Prisma__PreventifsClient<$Result.GetResult<Prisma.$PreventifsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Preventifs.
     * @param {PreventifsCreateManyArgs} args - Arguments to create many Preventifs.
     * @example
     * // Create many Preventifs
     * const preventifs = await prisma.preventifs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PreventifsCreateManyArgs>(args?: SelectSubset<T, PreventifsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Preventifs.
     * @param {PreventifsDeleteArgs} args - Arguments to delete one Preventifs.
     * @example
     * // Delete one Preventifs
     * const Preventifs = await prisma.preventifs.delete({
     *   where: {
     *     // ... filter to delete one Preventifs
     *   }
     * })
     * 
     */
    delete<T extends PreventifsDeleteArgs>(args: SelectSubset<T, PreventifsDeleteArgs<ExtArgs>>): Prisma__PreventifsClient<$Result.GetResult<Prisma.$PreventifsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Preventifs.
     * @param {PreventifsUpdateArgs} args - Arguments to update one Preventifs.
     * @example
     * // Update one Preventifs
     * const preventifs = await prisma.preventifs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PreventifsUpdateArgs>(args: SelectSubset<T, PreventifsUpdateArgs<ExtArgs>>): Prisma__PreventifsClient<$Result.GetResult<Prisma.$PreventifsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Preventifs.
     * @param {PreventifsDeleteManyArgs} args - Arguments to filter Preventifs to delete.
     * @example
     * // Delete a few Preventifs
     * const { count } = await prisma.preventifs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PreventifsDeleteManyArgs>(args?: SelectSubset<T, PreventifsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Preventifs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventifsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Preventifs
     * const preventifs = await prisma.preventifs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PreventifsUpdateManyArgs>(args: SelectSubset<T, PreventifsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Preventifs.
     * @param {PreventifsUpsertArgs} args - Arguments to update or create a Preventifs.
     * @example
     * // Update or create a Preventifs
     * const preventifs = await prisma.preventifs.upsert({
     *   create: {
     *     // ... data to create a Preventifs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Preventifs we want to update
     *   }
     * })
     */
    upsert<T extends PreventifsUpsertArgs>(args: SelectSubset<T, PreventifsUpsertArgs<ExtArgs>>): Prisma__PreventifsClient<$Result.GetResult<Prisma.$PreventifsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Preventifs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventifsCountArgs} args - Arguments to filter Preventifs to count.
     * @example
     * // Count the number of Preventifs
     * const count = await prisma.preventifs.count({
     *   where: {
     *     // ... the filter for the Preventifs we want to count
     *   }
     * })
    **/
    count<T extends PreventifsCountArgs>(
      args?: Subset<T, PreventifsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PreventifsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Preventifs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventifsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PreventifsAggregateArgs>(args: Subset<T, PreventifsAggregateArgs>): Prisma.PrismaPromise<GetPreventifsAggregateType<T>>

    /**
     * Group by Preventifs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PreventifsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PreventifsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PreventifsGroupByArgs['orderBy'] }
        : { orderBy?: PreventifsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PreventifsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPreventifsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Preventifs model
   */
  readonly fields: PreventifsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Preventifs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PreventifsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lawyer<T extends LawyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LawyerDefaultArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Preventifs model
   */
  interface PreventifsFieldRefs {
    readonly id: FieldRef<"Preventifs", 'String'>
    readonly userId: FieldRef<"Preventifs", 'String'>
    readonly title: FieldRef<"Preventifs", 'String'>
    readonly content: FieldRef<"Preventifs", 'String'>
    readonly desc: FieldRef<"Preventifs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Preventifs findUnique
   */
  export type PreventifsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preventifs
     */
    select?: PreventifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preventifs
     */
    omit?: PreventifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreventifsInclude<ExtArgs> | null
    /**
     * Filter, which Preventifs to fetch.
     */
    where: PreventifsWhereUniqueInput
  }

  /**
   * Preventifs findUniqueOrThrow
   */
  export type PreventifsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preventifs
     */
    select?: PreventifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preventifs
     */
    omit?: PreventifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreventifsInclude<ExtArgs> | null
    /**
     * Filter, which Preventifs to fetch.
     */
    where: PreventifsWhereUniqueInput
  }

  /**
   * Preventifs findFirst
   */
  export type PreventifsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preventifs
     */
    select?: PreventifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preventifs
     */
    omit?: PreventifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreventifsInclude<ExtArgs> | null
    /**
     * Filter, which Preventifs to fetch.
     */
    where?: PreventifsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preventifs to fetch.
     */
    orderBy?: PreventifsOrderByWithRelationInput | PreventifsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preventifs.
     */
    cursor?: PreventifsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preventifs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preventifs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preventifs.
     */
    distinct?: PreventifsScalarFieldEnum | PreventifsScalarFieldEnum[]
  }

  /**
   * Preventifs findFirstOrThrow
   */
  export type PreventifsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preventifs
     */
    select?: PreventifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preventifs
     */
    omit?: PreventifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreventifsInclude<ExtArgs> | null
    /**
     * Filter, which Preventifs to fetch.
     */
    where?: PreventifsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preventifs to fetch.
     */
    orderBy?: PreventifsOrderByWithRelationInput | PreventifsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Preventifs.
     */
    cursor?: PreventifsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preventifs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preventifs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Preventifs.
     */
    distinct?: PreventifsScalarFieldEnum | PreventifsScalarFieldEnum[]
  }

  /**
   * Preventifs findMany
   */
  export type PreventifsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preventifs
     */
    select?: PreventifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preventifs
     */
    omit?: PreventifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreventifsInclude<ExtArgs> | null
    /**
     * Filter, which Preventifs to fetch.
     */
    where?: PreventifsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Preventifs to fetch.
     */
    orderBy?: PreventifsOrderByWithRelationInput | PreventifsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Preventifs.
     */
    cursor?: PreventifsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Preventifs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Preventifs.
     */
    skip?: number
    distinct?: PreventifsScalarFieldEnum | PreventifsScalarFieldEnum[]
  }

  /**
   * Preventifs create
   */
  export type PreventifsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preventifs
     */
    select?: PreventifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preventifs
     */
    omit?: PreventifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreventifsInclude<ExtArgs> | null
    /**
     * The data needed to create a Preventifs.
     */
    data: XOR<PreventifsCreateInput, PreventifsUncheckedCreateInput>
  }

  /**
   * Preventifs createMany
   */
  export type PreventifsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Preventifs.
     */
    data: PreventifsCreateManyInput | PreventifsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Preventifs update
   */
  export type PreventifsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preventifs
     */
    select?: PreventifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preventifs
     */
    omit?: PreventifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreventifsInclude<ExtArgs> | null
    /**
     * The data needed to update a Preventifs.
     */
    data: XOR<PreventifsUpdateInput, PreventifsUncheckedUpdateInput>
    /**
     * Choose, which Preventifs to update.
     */
    where: PreventifsWhereUniqueInput
  }

  /**
   * Preventifs updateMany
   */
  export type PreventifsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Preventifs.
     */
    data: XOR<PreventifsUpdateManyMutationInput, PreventifsUncheckedUpdateManyInput>
    /**
     * Filter which Preventifs to update
     */
    where?: PreventifsWhereInput
    /**
     * Limit how many Preventifs to update.
     */
    limit?: number
  }

  /**
   * Preventifs upsert
   */
  export type PreventifsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preventifs
     */
    select?: PreventifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preventifs
     */
    omit?: PreventifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreventifsInclude<ExtArgs> | null
    /**
     * The filter to search for the Preventifs to update in case it exists.
     */
    where: PreventifsWhereUniqueInput
    /**
     * In case the Preventifs found by the `where` argument doesn't exist, create a new Preventifs with this data.
     */
    create: XOR<PreventifsCreateInput, PreventifsUncheckedCreateInput>
    /**
     * In case the Preventifs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PreventifsUpdateInput, PreventifsUncheckedUpdateInput>
  }

  /**
   * Preventifs delete
   */
  export type PreventifsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preventifs
     */
    select?: PreventifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preventifs
     */
    omit?: PreventifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreventifsInclude<ExtArgs> | null
    /**
     * Filter which Preventifs to delete.
     */
    where: PreventifsWhereUniqueInput
  }

  /**
   * Preventifs deleteMany
   */
  export type PreventifsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Preventifs to delete
     */
    where?: PreventifsWhereInput
    /**
     * Limit how many Preventifs to delete.
     */
    limit?: number
  }

  /**
   * Preventifs without action
   */
  export type PreventifsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Preventifs
     */
    select?: PreventifsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Preventifs
     */
    omit?: PreventifsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PreventifsInclude<ExtArgs> | null
  }


  /**
   * Model ValeurAjouter
   */

  export type AggregateValeurAjouter = {
    _count: ValeurAjouterCountAggregateOutputType | null
    _min: ValeurAjouterMinAggregateOutputType | null
    _max: ValeurAjouterMaxAggregateOutputType | null
  }

  export type ValeurAjouterMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    desc: string | null
  }

  export type ValeurAjouterMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    content: string | null
    desc: string | null
  }

  export type ValeurAjouterCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    desc: number
    _all: number
  }


  export type ValeurAjouterMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
  }

  export type ValeurAjouterMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
  }

  export type ValeurAjouterCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    desc?: true
    _all?: true
  }

  export type ValeurAjouterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ValeurAjouter to aggregate.
     */
    where?: ValeurAjouterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValeurAjouters to fetch.
     */
    orderBy?: ValeurAjouterOrderByWithRelationInput | ValeurAjouterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ValeurAjouterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValeurAjouters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValeurAjouters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ValeurAjouters
    **/
    _count?: true | ValeurAjouterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ValeurAjouterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ValeurAjouterMaxAggregateInputType
  }

  export type GetValeurAjouterAggregateType<T extends ValeurAjouterAggregateArgs> = {
        [P in keyof T & keyof AggregateValeurAjouter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateValeurAjouter[P]>
      : GetScalarType<T[P], AggregateValeurAjouter[P]>
  }




  export type ValeurAjouterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValeurAjouterWhereInput
    orderBy?: ValeurAjouterOrderByWithAggregationInput | ValeurAjouterOrderByWithAggregationInput[]
    by: ValeurAjouterScalarFieldEnum[] | ValeurAjouterScalarFieldEnum
    having?: ValeurAjouterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ValeurAjouterCountAggregateInputType | true
    _min?: ValeurAjouterMinAggregateInputType
    _max?: ValeurAjouterMaxAggregateInputType
  }

  export type ValeurAjouterGroupByOutputType = {
    id: string
    userId: string
    title: string
    content: string
    desc: string
    _count: ValeurAjouterCountAggregateOutputType | null
    _min: ValeurAjouterMinAggregateOutputType | null
    _max: ValeurAjouterMaxAggregateOutputType | null
  }

  type GetValeurAjouterGroupByPayload<T extends ValeurAjouterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ValeurAjouterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ValeurAjouterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ValeurAjouterGroupByOutputType[P]>
            : GetScalarType<T[P], ValeurAjouterGroupByOutputType[P]>
        }
      >
    >


  export type ValeurAjouterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    desc?: boolean
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["valeurAjouter"]>



  export type ValeurAjouterSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    desc?: boolean
  }

  export type ValeurAjouterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "content" | "desc", ExtArgs["result"]["valeurAjouter"]>
  export type ValeurAjouterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }

  export type $ValeurAjouterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ValeurAjouter"
    objects: {
      lawyer: Prisma.$LawyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      content: string
      desc: string
    }, ExtArgs["result"]["valeurAjouter"]>
    composites: {}
  }

  type ValeurAjouterGetPayload<S extends boolean | null | undefined | ValeurAjouterDefaultArgs> = $Result.GetResult<Prisma.$ValeurAjouterPayload, S>

  type ValeurAjouterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ValeurAjouterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ValeurAjouterCountAggregateInputType | true
    }

  export interface ValeurAjouterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ValeurAjouter'], meta: { name: 'ValeurAjouter' } }
    /**
     * Find zero or one ValeurAjouter that matches the filter.
     * @param {ValeurAjouterFindUniqueArgs} args - Arguments to find a ValeurAjouter
     * @example
     * // Get one ValeurAjouter
     * const valeurAjouter = await prisma.valeurAjouter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ValeurAjouterFindUniqueArgs>(args: SelectSubset<T, ValeurAjouterFindUniqueArgs<ExtArgs>>): Prisma__ValeurAjouterClient<$Result.GetResult<Prisma.$ValeurAjouterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ValeurAjouter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ValeurAjouterFindUniqueOrThrowArgs} args - Arguments to find a ValeurAjouter
     * @example
     * // Get one ValeurAjouter
     * const valeurAjouter = await prisma.valeurAjouter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ValeurAjouterFindUniqueOrThrowArgs>(args: SelectSubset<T, ValeurAjouterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ValeurAjouterClient<$Result.GetResult<Prisma.$ValeurAjouterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ValeurAjouter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValeurAjouterFindFirstArgs} args - Arguments to find a ValeurAjouter
     * @example
     * // Get one ValeurAjouter
     * const valeurAjouter = await prisma.valeurAjouter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ValeurAjouterFindFirstArgs>(args?: SelectSubset<T, ValeurAjouterFindFirstArgs<ExtArgs>>): Prisma__ValeurAjouterClient<$Result.GetResult<Prisma.$ValeurAjouterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ValeurAjouter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValeurAjouterFindFirstOrThrowArgs} args - Arguments to find a ValeurAjouter
     * @example
     * // Get one ValeurAjouter
     * const valeurAjouter = await prisma.valeurAjouter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ValeurAjouterFindFirstOrThrowArgs>(args?: SelectSubset<T, ValeurAjouterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ValeurAjouterClient<$Result.GetResult<Prisma.$ValeurAjouterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ValeurAjouters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValeurAjouterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ValeurAjouters
     * const valeurAjouters = await prisma.valeurAjouter.findMany()
     * 
     * // Get first 10 ValeurAjouters
     * const valeurAjouters = await prisma.valeurAjouter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const valeurAjouterWithIdOnly = await prisma.valeurAjouter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ValeurAjouterFindManyArgs>(args?: SelectSubset<T, ValeurAjouterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValeurAjouterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ValeurAjouter.
     * @param {ValeurAjouterCreateArgs} args - Arguments to create a ValeurAjouter.
     * @example
     * // Create one ValeurAjouter
     * const ValeurAjouter = await prisma.valeurAjouter.create({
     *   data: {
     *     // ... data to create a ValeurAjouter
     *   }
     * })
     * 
     */
    create<T extends ValeurAjouterCreateArgs>(args: SelectSubset<T, ValeurAjouterCreateArgs<ExtArgs>>): Prisma__ValeurAjouterClient<$Result.GetResult<Prisma.$ValeurAjouterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ValeurAjouters.
     * @param {ValeurAjouterCreateManyArgs} args - Arguments to create many ValeurAjouters.
     * @example
     * // Create many ValeurAjouters
     * const valeurAjouter = await prisma.valeurAjouter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ValeurAjouterCreateManyArgs>(args?: SelectSubset<T, ValeurAjouterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ValeurAjouter.
     * @param {ValeurAjouterDeleteArgs} args - Arguments to delete one ValeurAjouter.
     * @example
     * // Delete one ValeurAjouter
     * const ValeurAjouter = await prisma.valeurAjouter.delete({
     *   where: {
     *     // ... filter to delete one ValeurAjouter
     *   }
     * })
     * 
     */
    delete<T extends ValeurAjouterDeleteArgs>(args: SelectSubset<T, ValeurAjouterDeleteArgs<ExtArgs>>): Prisma__ValeurAjouterClient<$Result.GetResult<Prisma.$ValeurAjouterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ValeurAjouter.
     * @param {ValeurAjouterUpdateArgs} args - Arguments to update one ValeurAjouter.
     * @example
     * // Update one ValeurAjouter
     * const valeurAjouter = await prisma.valeurAjouter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ValeurAjouterUpdateArgs>(args: SelectSubset<T, ValeurAjouterUpdateArgs<ExtArgs>>): Prisma__ValeurAjouterClient<$Result.GetResult<Prisma.$ValeurAjouterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ValeurAjouters.
     * @param {ValeurAjouterDeleteManyArgs} args - Arguments to filter ValeurAjouters to delete.
     * @example
     * // Delete a few ValeurAjouters
     * const { count } = await prisma.valeurAjouter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ValeurAjouterDeleteManyArgs>(args?: SelectSubset<T, ValeurAjouterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ValeurAjouters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValeurAjouterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ValeurAjouters
     * const valeurAjouter = await prisma.valeurAjouter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ValeurAjouterUpdateManyArgs>(args: SelectSubset<T, ValeurAjouterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ValeurAjouter.
     * @param {ValeurAjouterUpsertArgs} args - Arguments to update or create a ValeurAjouter.
     * @example
     * // Update or create a ValeurAjouter
     * const valeurAjouter = await prisma.valeurAjouter.upsert({
     *   create: {
     *     // ... data to create a ValeurAjouter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ValeurAjouter we want to update
     *   }
     * })
     */
    upsert<T extends ValeurAjouterUpsertArgs>(args: SelectSubset<T, ValeurAjouterUpsertArgs<ExtArgs>>): Prisma__ValeurAjouterClient<$Result.GetResult<Prisma.$ValeurAjouterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ValeurAjouters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValeurAjouterCountArgs} args - Arguments to filter ValeurAjouters to count.
     * @example
     * // Count the number of ValeurAjouters
     * const count = await prisma.valeurAjouter.count({
     *   where: {
     *     // ... the filter for the ValeurAjouters we want to count
     *   }
     * })
    **/
    count<T extends ValeurAjouterCountArgs>(
      args?: Subset<T, ValeurAjouterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ValeurAjouterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ValeurAjouter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValeurAjouterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ValeurAjouterAggregateArgs>(args: Subset<T, ValeurAjouterAggregateArgs>): Prisma.PrismaPromise<GetValeurAjouterAggregateType<T>>

    /**
     * Group by ValeurAjouter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValeurAjouterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ValeurAjouterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ValeurAjouterGroupByArgs['orderBy'] }
        : { orderBy?: ValeurAjouterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ValeurAjouterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetValeurAjouterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ValeurAjouter model
   */
  readonly fields: ValeurAjouterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ValeurAjouter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ValeurAjouterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lawyer<T extends LawyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LawyerDefaultArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ValeurAjouter model
   */
  interface ValeurAjouterFieldRefs {
    readonly id: FieldRef<"ValeurAjouter", 'String'>
    readonly userId: FieldRef<"ValeurAjouter", 'String'>
    readonly title: FieldRef<"ValeurAjouter", 'String'>
    readonly content: FieldRef<"ValeurAjouter", 'String'>
    readonly desc: FieldRef<"ValeurAjouter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ValeurAjouter findUnique
   */
  export type ValeurAjouterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValeurAjouter
     */
    select?: ValeurAjouterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValeurAjouter
     */
    omit?: ValeurAjouterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValeurAjouterInclude<ExtArgs> | null
    /**
     * Filter, which ValeurAjouter to fetch.
     */
    where: ValeurAjouterWhereUniqueInput
  }

  /**
   * ValeurAjouter findUniqueOrThrow
   */
  export type ValeurAjouterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValeurAjouter
     */
    select?: ValeurAjouterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValeurAjouter
     */
    omit?: ValeurAjouterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValeurAjouterInclude<ExtArgs> | null
    /**
     * Filter, which ValeurAjouter to fetch.
     */
    where: ValeurAjouterWhereUniqueInput
  }

  /**
   * ValeurAjouter findFirst
   */
  export type ValeurAjouterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValeurAjouter
     */
    select?: ValeurAjouterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValeurAjouter
     */
    omit?: ValeurAjouterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValeurAjouterInclude<ExtArgs> | null
    /**
     * Filter, which ValeurAjouter to fetch.
     */
    where?: ValeurAjouterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValeurAjouters to fetch.
     */
    orderBy?: ValeurAjouterOrderByWithRelationInput | ValeurAjouterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ValeurAjouters.
     */
    cursor?: ValeurAjouterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValeurAjouters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValeurAjouters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ValeurAjouters.
     */
    distinct?: ValeurAjouterScalarFieldEnum | ValeurAjouterScalarFieldEnum[]
  }

  /**
   * ValeurAjouter findFirstOrThrow
   */
  export type ValeurAjouterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValeurAjouter
     */
    select?: ValeurAjouterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValeurAjouter
     */
    omit?: ValeurAjouterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValeurAjouterInclude<ExtArgs> | null
    /**
     * Filter, which ValeurAjouter to fetch.
     */
    where?: ValeurAjouterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValeurAjouters to fetch.
     */
    orderBy?: ValeurAjouterOrderByWithRelationInput | ValeurAjouterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ValeurAjouters.
     */
    cursor?: ValeurAjouterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValeurAjouters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValeurAjouters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ValeurAjouters.
     */
    distinct?: ValeurAjouterScalarFieldEnum | ValeurAjouterScalarFieldEnum[]
  }

  /**
   * ValeurAjouter findMany
   */
  export type ValeurAjouterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValeurAjouter
     */
    select?: ValeurAjouterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValeurAjouter
     */
    omit?: ValeurAjouterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValeurAjouterInclude<ExtArgs> | null
    /**
     * Filter, which ValeurAjouters to fetch.
     */
    where?: ValeurAjouterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValeurAjouters to fetch.
     */
    orderBy?: ValeurAjouterOrderByWithRelationInput | ValeurAjouterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ValeurAjouters.
     */
    cursor?: ValeurAjouterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValeurAjouters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValeurAjouters.
     */
    skip?: number
    distinct?: ValeurAjouterScalarFieldEnum | ValeurAjouterScalarFieldEnum[]
  }

  /**
   * ValeurAjouter create
   */
  export type ValeurAjouterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValeurAjouter
     */
    select?: ValeurAjouterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValeurAjouter
     */
    omit?: ValeurAjouterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValeurAjouterInclude<ExtArgs> | null
    /**
     * The data needed to create a ValeurAjouter.
     */
    data: XOR<ValeurAjouterCreateInput, ValeurAjouterUncheckedCreateInput>
  }

  /**
   * ValeurAjouter createMany
   */
  export type ValeurAjouterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ValeurAjouters.
     */
    data: ValeurAjouterCreateManyInput | ValeurAjouterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ValeurAjouter update
   */
  export type ValeurAjouterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValeurAjouter
     */
    select?: ValeurAjouterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValeurAjouter
     */
    omit?: ValeurAjouterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValeurAjouterInclude<ExtArgs> | null
    /**
     * The data needed to update a ValeurAjouter.
     */
    data: XOR<ValeurAjouterUpdateInput, ValeurAjouterUncheckedUpdateInput>
    /**
     * Choose, which ValeurAjouter to update.
     */
    where: ValeurAjouterWhereUniqueInput
  }

  /**
   * ValeurAjouter updateMany
   */
  export type ValeurAjouterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ValeurAjouters.
     */
    data: XOR<ValeurAjouterUpdateManyMutationInput, ValeurAjouterUncheckedUpdateManyInput>
    /**
     * Filter which ValeurAjouters to update
     */
    where?: ValeurAjouterWhereInput
    /**
     * Limit how many ValeurAjouters to update.
     */
    limit?: number
  }

  /**
   * ValeurAjouter upsert
   */
  export type ValeurAjouterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValeurAjouter
     */
    select?: ValeurAjouterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValeurAjouter
     */
    omit?: ValeurAjouterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValeurAjouterInclude<ExtArgs> | null
    /**
     * The filter to search for the ValeurAjouter to update in case it exists.
     */
    where: ValeurAjouterWhereUniqueInput
    /**
     * In case the ValeurAjouter found by the `where` argument doesn't exist, create a new ValeurAjouter with this data.
     */
    create: XOR<ValeurAjouterCreateInput, ValeurAjouterUncheckedCreateInput>
    /**
     * In case the ValeurAjouter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ValeurAjouterUpdateInput, ValeurAjouterUncheckedUpdateInput>
  }

  /**
   * ValeurAjouter delete
   */
  export type ValeurAjouterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValeurAjouter
     */
    select?: ValeurAjouterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValeurAjouter
     */
    omit?: ValeurAjouterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValeurAjouterInclude<ExtArgs> | null
    /**
     * Filter which ValeurAjouter to delete.
     */
    where: ValeurAjouterWhereUniqueInput
  }

  /**
   * ValeurAjouter deleteMany
   */
  export type ValeurAjouterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ValeurAjouters to delete
     */
    where?: ValeurAjouterWhereInput
    /**
     * Limit how many ValeurAjouters to delete.
     */
    limit?: number
  }

  /**
   * ValeurAjouter without action
   */
  export type ValeurAjouterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValeurAjouter
     */
    select?: ValeurAjouterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ValeurAjouter
     */
    omit?: ValeurAjouterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValeurAjouterInclude<ExtArgs> | null
  }


  /**
   * Model Friends
   */

  export type AggregateFriends = {
    _count: FriendsCountAggregateOutputType | null
    _min: FriendsMinAggregateOutputType | null
    _max: FriendsMaxAggregateOutputType | null
  }

  export type FriendsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    nbrDeContrat: string | null
    key: string | null
  }

  export type FriendsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    nbrDeContrat: string | null
    key: string | null
  }

  export type FriendsCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    nbrDeContrat: number
    key: number
    _all: number
  }


  export type FriendsMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    nbrDeContrat?: true
    key?: true
  }

  export type FriendsMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    nbrDeContrat?: true
    key?: true
  }

  export type FriendsCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    nbrDeContrat?: true
    key?: true
    _all?: true
  }

  export type FriendsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friends to aggregate.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friends
    **/
    _count?: true | FriendsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendsMaxAggregateInputType
  }

  export type GetFriendsAggregateType<T extends FriendsAggregateArgs> = {
        [P in keyof T & keyof AggregateFriends]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriends[P]>
      : GetScalarType<T[P], AggregateFriends[P]>
  }




  export type FriendsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendsWhereInput
    orderBy?: FriendsOrderByWithAggregationInput | FriendsOrderByWithAggregationInput[]
    by: FriendsScalarFieldEnum[] | FriendsScalarFieldEnum
    having?: FriendsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendsCountAggregateInputType | true
    _min?: FriendsMinAggregateInputType
    _max?: FriendsMaxAggregateInputType
  }

  export type FriendsGroupByOutputType = {
    id: string
    userId: string
    name: string
    nbrDeContrat: string
    key: string
    _count: FriendsCountAggregateOutputType | null
    _min: FriendsMinAggregateOutputType | null
    _max: FriendsMaxAggregateOutputType | null
  }

  type GetFriendsGroupByPayload<T extends FriendsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendsGroupByOutputType[P]>
            : GetScalarType<T[P], FriendsGroupByOutputType[P]>
        }
      >
    >


  export type FriendsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    nbrDeContrat?: boolean
    key?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friends"]>



  export type FriendsSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    nbrDeContrat?: boolean
    key?: boolean
  }

  export type FriendsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "nbrDeContrat" | "key", ExtArgs["result"]["friends"]>
  export type FriendsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $FriendsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friends"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      nbrDeContrat: string
      key: string
    }, ExtArgs["result"]["friends"]>
    composites: {}
  }

  type FriendsGetPayload<S extends boolean | null | undefined | FriendsDefaultArgs> = $Result.GetResult<Prisma.$FriendsPayload, S>

  type FriendsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FriendsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FriendsCountAggregateInputType | true
    }

  export interface FriendsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friends'], meta: { name: 'Friends' } }
    /**
     * Find zero or one Friends that matches the filter.
     * @param {FriendsFindUniqueArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendsFindUniqueArgs>(args: SelectSubset<T, FriendsFindUniqueArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Friends that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FriendsFindUniqueOrThrowArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendsFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsFindFirstArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendsFindFirstArgs>(args?: SelectSubset<T, FriendsFindFirstArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friends that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsFindFirstOrThrowArgs} args - Arguments to find a Friends
     * @example
     * // Get one Friends
     * const friends = await prisma.friends.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendsFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Friends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friends
     * const friends = await prisma.friends.findMany()
     * 
     * // Get first 10 Friends
     * const friends = await prisma.friends.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendsWithIdOnly = await prisma.friends.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendsFindManyArgs>(args?: SelectSubset<T, FriendsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Friends.
     * @param {FriendsCreateArgs} args - Arguments to create a Friends.
     * @example
     * // Create one Friends
     * const Friends = await prisma.friends.create({
     *   data: {
     *     // ... data to create a Friends
     *   }
     * })
     * 
     */
    create<T extends FriendsCreateArgs>(args: SelectSubset<T, FriendsCreateArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Friends.
     * @param {FriendsCreateManyArgs} args - Arguments to create many Friends.
     * @example
     * // Create many Friends
     * const friends = await prisma.friends.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendsCreateManyArgs>(args?: SelectSubset<T, FriendsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Friends.
     * @param {FriendsDeleteArgs} args - Arguments to delete one Friends.
     * @example
     * // Delete one Friends
     * const Friends = await prisma.friends.delete({
     *   where: {
     *     // ... filter to delete one Friends
     *   }
     * })
     * 
     */
    delete<T extends FriendsDeleteArgs>(args: SelectSubset<T, FriendsDeleteArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Friends.
     * @param {FriendsUpdateArgs} args - Arguments to update one Friends.
     * @example
     * // Update one Friends
     * const friends = await prisma.friends.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendsUpdateArgs>(args: SelectSubset<T, FriendsUpdateArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Friends.
     * @param {FriendsDeleteManyArgs} args - Arguments to filter Friends to delete.
     * @example
     * // Delete a few Friends
     * const { count } = await prisma.friends.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendsDeleteManyArgs>(args?: SelectSubset<T, FriendsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friends
     * const friends = await prisma.friends.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendsUpdateManyArgs>(args: SelectSubset<T, FriendsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Friends.
     * @param {FriendsUpsertArgs} args - Arguments to update or create a Friends.
     * @example
     * // Update or create a Friends
     * const friends = await prisma.friends.upsert({
     *   create: {
     *     // ... data to create a Friends
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friends we want to update
     *   }
     * })
     */
    upsert<T extends FriendsUpsertArgs>(args: SelectSubset<T, FriendsUpsertArgs<ExtArgs>>): Prisma__FriendsClient<$Result.GetResult<Prisma.$FriendsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsCountArgs} args - Arguments to filter Friends to count.
     * @example
     * // Count the number of Friends
     * const count = await prisma.friends.count({
     *   where: {
     *     // ... the filter for the Friends we want to count
     *   }
     * })
    **/
    count<T extends FriendsCountArgs>(
      args?: Subset<T, FriendsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendsAggregateArgs>(args: Subset<T, FriendsAggregateArgs>): Prisma.PrismaPromise<GetFriendsAggregateType<T>>

    /**
     * Group by Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendsGroupByArgs['orderBy'] }
        : { orderBy?: FriendsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friends model
   */
  readonly fields: FriendsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friends.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friends model
   */
  interface FriendsFieldRefs {
    readonly id: FieldRef<"Friends", 'String'>
    readonly userId: FieldRef<"Friends", 'String'>
    readonly name: FieldRef<"Friends", 'String'>
    readonly nbrDeContrat: FieldRef<"Friends", 'String'>
    readonly key: FieldRef<"Friends", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Friends findUnique
   */
  export type FriendsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends findUniqueOrThrow
   */
  export type FriendsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends findFirst
   */
  export type FriendsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friends.
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friends.
     */
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Friends findFirstOrThrow
   */
  export type FriendsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friends.
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friends.
     */
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Friends findMany
   */
  export type FriendsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where?: FriendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendsOrderByWithRelationInput | FriendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friends.
     */
    cursor?: FriendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    distinct?: FriendsScalarFieldEnum | FriendsScalarFieldEnum[]
  }

  /**
   * Friends create
   */
  export type FriendsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * The data needed to create a Friends.
     */
    data: XOR<FriendsCreateInput, FriendsUncheckedCreateInput>
  }

  /**
   * Friends createMany
   */
  export type FriendsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friends.
     */
    data: FriendsCreateManyInput | FriendsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Friends update
   */
  export type FriendsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * The data needed to update a Friends.
     */
    data: XOR<FriendsUpdateInput, FriendsUncheckedUpdateInput>
    /**
     * Choose, which Friends to update.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends updateMany
   */
  export type FriendsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friends.
     */
    data: XOR<FriendsUpdateManyMutationInput, FriendsUncheckedUpdateManyInput>
    /**
     * Filter which Friends to update
     */
    where?: FriendsWhereInput
    /**
     * Limit how many Friends to update.
     */
    limit?: number
  }

  /**
   * Friends upsert
   */
  export type FriendsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * The filter to search for the Friends to update in case it exists.
     */
    where: FriendsWhereUniqueInput
    /**
     * In case the Friends found by the `where` argument doesn't exist, create a new Friends with this data.
     */
    create: XOR<FriendsCreateInput, FriendsUncheckedCreateInput>
    /**
     * In case the Friends was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendsUpdateInput, FriendsUncheckedUpdateInput>
  }

  /**
   * Friends delete
   */
  export type FriendsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
    /**
     * Filter which Friends to delete.
     */
    where: FriendsWhereUniqueInput
  }

  /**
   * Friends deleteMany
   */
  export type FriendsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friends to delete
     */
    where?: FriendsWhereInput
    /**
     * Limit how many Friends to delete.
     */
    limit?: number
  }

  /**
   * Friends without action
   */
  export type FriendsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friends
     */
    select?: FriendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friends
     */
    omit?: FriendsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendsInclude<ExtArgs> | null
  }


  /**
   * Model FriendLaw
   */

  export type AggregateFriendLaw = {
    _count: FriendLawCountAggregateOutputType | null
    _min: FriendLawMinAggregateOutputType | null
    _max: FriendLawMaxAggregateOutputType | null
  }

  export type FriendLawMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    nbrDeContrat: string | null
    key: string | null
  }

  export type FriendLawMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    nbrDeContrat: string | null
    key: string | null
  }

  export type FriendLawCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    nbrDeContrat: number
    key: number
    _all: number
  }


  export type FriendLawMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    nbrDeContrat?: true
    key?: true
  }

  export type FriendLawMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    nbrDeContrat?: true
    key?: true
  }

  export type FriendLawCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    nbrDeContrat?: true
    key?: true
    _all?: true
  }

  export type FriendLawAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FriendLaw to aggregate.
     */
    where?: FriendLawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendLaws to fetch.
     */
    orderBy?: FriendLawOrderByWithRelationInput | FriendLawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendLawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendLaws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendLaws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FriendLaws
    **/
    _count?: true | FriendLawCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendLawMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendLawMaxAggregateInputType
  }

  export type GetFriendLawAggregateType<T extends FriendLawAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendLaw]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendLaw[P]>
      : GetScalarType<T[P], AggregateFriendLaw[P]>
  }




  export type FriendLawGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendLawWhereInput
    orderBy?: FriendLawOrderByWithAggregationInput | FriendLawOrderByWithAggregationInput[]
    by: FriendLawScalarFieldEnum[] | FriendLawScalarFieldEnum
    having?: FriendLawScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendLawCountAggregateInputType | true
    _min?: FriendLawMinAggregateInputType
    _max?: FriendLawMaxAggregateInputType
  }

  export type FriendLawGroupByOutputType = {
    id: string
    userId: string
    name: string
    nbrDeContrat: string
    key: string
    _count: FriendLawCountAggregateOutputType | null
    _min: FriendLawMinAggregateOutputType | null
    _max: FriendLawMaxAggregateOutputType | null
  }

  type GetFriendLawGroupByPayload<T extends FriendLawGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendLawGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendLawGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendLawGroupByOutputType[P]>
            : GetScalarType<T[P], FriendLawGroupByOutputType[P]>
        }
      >
    >


  export type FriendLawSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    nbrDeContrat?: boolean
    key?: boolean
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendLaw"]>



  export type FriendLawSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    nbrDeContrat?: boolean
    key?: boolean
  }

  export type FriendLawOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "nbrDeContrat" | "key", ExtArgs["result"]["friendLaw"]>
  export type FriendLawInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }

  export type $FriendLawPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FriendLaw"
    objects: {
      lawyer: Prisma.$LawyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      nbrDeContrat: string
      key: string
    }, ExtArgs["result"]["friendLaw"]>
    composites: {}
  }

  type FriendLawGetPayload<S extends boolean | null | undefined | FriendLawDefaultArgs> = $Result.GetResult<Prisma.$FriendLawPayload, S>

  type FriendLawCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FriendLawFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FriendLawCountAggregateInputType | true
    }

  export interface FriendLawDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FriendLaw'], meta: { name: 'FriendLaw' } }
    /**
     * Find zero or one FriendLaw that matches the filter.
     * @param {FriendLawFindUniqueArgs} args - Arguments to find a FriendLaw
     * @example
     * // Get one FriendLaw
     * const friendLaw = await prisma.friendLaw.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendLawFindUniqueArgs>(args: SelectSubset<T, FriendLawFindUniqueArgs<ExtArgs>>): Prisma__FriendLawClient<$Result.GetResult<Prisma.$FriendLawPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FriendLaw that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FriendLawFindUniqueOrThrowArgs} args - Arguments to find a FriendLaw
     * @example
     * // Get one FriendLaw
     * const friendLaw = await prisma.friendLaw.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendLawFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendLawFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendLawClient<$Result.GetResult<Prisma.$FriendLawPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FriendLaw that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendLawFindFirstArgs} args - Arguments to find a FriendLaw
     * @example
     * // Get one FriendLaw
     * const friendLaw = await prisma.friendLaw.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendLawFindFirstArgs>(args?: SelectSubset<T, FriendLawFindFirstArgs<ExtArgs>>): Prisma__FriendLawClient<$Result.GetResult<Prisma.$FriendLawPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FriendLaw that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendLawFindFirstOrThrowArgs} args - Arguments to find a FriendLaw
     * @example
     * // Get one FriendLaw
     * const friendLaw = await prisma.friendLaw.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendLawFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendLawFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendLawClient<$Result.GetResult<Prisma.$FriendLawPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FriendLaws that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendLawFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FriendLaws
     * const friendLaws = await prisma.friendLaw.findMany()
     * 
     * // Get first 10 FriendLaws
     * const friendLaws = await prisma.friendLaw.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendLawWithIdOnly = await prisma.friendLaw.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendLawFindManyArgs>(args?: SelectSubset<T, FriendLawFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendLawPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FriendLaw.
     * @param {FriendLawCreateArgs} args - Arguments to create a FriendLaw.
     * @example
     * // Create one FriendLaw
     * const FriendLaw = await prisma.friendLaw.create({
     *   data: {
     *     // ... data to create a FriendLaw
     *   }
     * })
     * 
     */
    create<T extends FriendLawCreateArgs>(args: SelectSubset<T, FriendLawCreateArgs<ExtArgs>>): Prisma__FriendLawClient<$Result.GetResult<Prisma.$FriendLawPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FriendLaws.
     * @param {FriendLawCreateManyArgs} args - Arguments to create many FriendLaws.
     * @example
     * // Create many FriendLaws
     * const friendLaw = await prisma.friendLaw.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendLawCreateManyArgs>(args?: SelectSubset<T, FriendLawCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FriendLaw.
     * @param {FriendLawDeleteArgs} args - Arguments to delete one FriendLaw.
     * @example
     * // Delete one FriendLaw
     * const FriendLaw = await prisma.friendLaw.delete({
     *   where: {
     *     // ... filter to delete one FriendLaw
     *   }
     * })
     * 
     */
    delete<T extends FriendLawDeleteArgs>(args: SelectSubset<T, FriendLawDeleteArgs<ExtArgs>>): Prisma__FriendLawClient<$Result.GetResult<Prisma.$FriendLawPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FriendLaw.
     * @param {FriendLawUpdateArgs} args - Arguments to update one FriendLaw.
     * @example
     * // Update one FriendLaw
     * const friendLaw = await prisma.friendLaw.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendLawUpdateArgs>(args: SelectSubset<T, FriendLawUpdateArgs<ExtArgs>>): Prisma__FriendLawClient<$Result.GetResult<Prisma.$FriendLawPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FriendLaws.
     * @param {FriendLawDeleteManyArgs} args - Arguments to filter FriendLaws to delete.
     * @example
     * // Delete a few FriendLaws
     * const { count } = await prisma.friendLaw.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendLawDeleteManyArgs>(args?: SelectSubset<T, FriendLawDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FriendLaws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendLawUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FriendLaws
     * const friendLaw = await prisma.friendLaw.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendLawUpdateManyArgs>(args: SelectSubset<T, FriendLawUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FriendLaw.
     * @param {FriendLawUpsertArgs} args - Arguments to update or create a FriendLaw.
     * @example
     * // Update or create a FriendLaw
     * const friendLaw = await prisma.friendLaw.upsert({
     *   create: {
     *     // ... data to create a FriendLaw
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FriendLaw we want to update
     *   }
     * })
     */
    upsert<T extends FriendLawUpsertArgs>(args: SelectSubset<T, FriendLawUpsertArgs<ExtArgs>>): Prisma__FriendLawClient<$Result.GetResult<Prisma.$FriendLawPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FriendLaws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendLawCountArgs} args - Arguments to filter FriendLaws to count.
     * @example
     * // Count the number of FriendLaws
     * const count = await prisma.friendLaw.count({
     *   where: {
     *     // ... the filter for the FriendLaws we want to count
     *   }
     * })
    **/
    count<T extends FriendLawCountArgs>(
      args?: Subset<T, FriendLawCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendLawCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FriendLaw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendLawAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendLawAggregateArgs>(args: Subset<T, FriendLawAggregateArgs>): Prisma.PrismaPromise<GetFriendLawAggregateType<T>>

    /**
     * Group by FriendLaw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendLawGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendLawGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendLawGroupByArgs['orderBy'] }
        : { orderBy?: FriendLawGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendLawGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendLawGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FriendLaw model
   */
  readonly fields: FriendLawFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FriendLaw.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendLawClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lawyer<T extends LawyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LawyerDefaultArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FriendLaw model
   */
  interface FriendLawFieldRefs {
    readonly id: FieldRef<"FriendLaw", 'String'>
    readonly userId: FieldRef<"FriendLaw", 'String'>
    readonly name: FieldRef<"FriendLaw", 'String'>
    readonly nbrDeContrat: FieldRef<"FriendLaw", 'String'>
    readonly key: FieldRef<"FriendLaw", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FriendLaw findUnique
   */
  export type FriendLawFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendLaw
     */
    select?: FriendLawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendLaw
     */
    omit?: FriendLawOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendLawInclude<ExtArgs> | null
    /**
     * Filter, which FriendLaw to fetch.
     */
    where: FriendLawWhereUniqueInput
  }

  /**
   * FriendLaw findUniqueOrThrow
   */
  export type FriendLawFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendLaw
     */
    select?: FriendLawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendLaw
     */
    omit?: FriendLawOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendLawInclude<ExtArgs> | null
    /**
     * Filter, which FriendLaw to fetch.
     */
    where: FriendLawWhereUniqueInput
  }

  /**
   * FriendLaw findFirst
   */
  export type FriendLawFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendLaw
     */
    select?: FriendLawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendLaw
     */
    omit?: FriendLawOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendLawInclude<ExtArgs> | null
    /**
     * Filter, which FriendLaw to fetch.
     */
    where?: FriendLawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendLaws to fetch.
     */
    orderBy?: FriendLawOrderByWithRelationInput | FriendLawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendLaws.
     */
    cursor?: FriendLawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendLaws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendLaws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendLaws.
     */
    distinct?: FriendLawScalarFieldEnum | FriendLawScalarFieldEnum[]
  }

  /**
   * FriendLaw findFirstOrThrow
   */
  export type FriendLawFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendLaw
     */
    select?: FriendLawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendLaw
     */
    omit?: FriendLawOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendLawInclude<ExtArgs> | null
    /**
     * Filter, which FriendLaw to fetch.
     */
    where?: FriendLawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendLaws to fetch.
     */
    orderBy?: FriendLawOrderByWithRelationInput | FriendLawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendLaws.
     */
    cursor?: FriendLawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendLaws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendLaws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendLaws.
     */
    distinct?: FriendLawScalarFieldEnum | FriendLawScalarFieldEnum[]
  }

  /**
   * FriendLaw findMany
   */
  export type FriendLawFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendLaw
     */
    select?: FriendLawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendLaw
     */
    omit?: FriendLawOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendLawInclude<ExtArgs> | null
    /**
     * Filter, which FriendLaws to fetch.
     */
    where?: FriendLawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendLaws to fetch.
     */
    orderBy?: FriendLawOrderByWithRelationInput | FriendLawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FriendLaws.
     */
    cursor?: FriendLawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendLaws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendLaws.
     */
    skip?: number
    distinct?: FriendLawScalarFieldEnum | FriendLawScalarFieldEnum[]
  }

  /**
   * FriendLaw create
   */
  export type FriendLawCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendLaw
     */
    select?: FriendLawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendLaw
     */
    omit?: FriendLawOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendLawInclude<ExtArgs> | null
    /**
     * The data needed to create a FriendLaw.
     */
    data: XOR<FriendLawCreateInput, FriendLawUncheckedCreateInput>
  }

  /**
   * FriendLaw createMany
   */
  export type FriendLawCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FriendLaws.
     */
    data: FriendLawCreateManyInput | FriendLawCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FriendLaw update
   */
  export type FriendLawUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendLaw
     */
    select?: FriendLawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendLaw
     */
    omit?: FriendLawOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendLawInclude<ExtArgs> | null
    /**
     * The data needed to update a FriendLaw.
     */
    data: XOR<FriendLawUpdateInput, FriendLawUncheckedUpdateInput>
    /**
     * Choose, which FriendLaw to update.
     */
    where: FriendLawWhereUniqueInput
  }

  /**
   * FriendLaw updateMany
   */
  export type FriendLawUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FriendLaws.
     */
    data: XOR<FriendLawUpdateManyMutationInput, FriendLawUncheckedUpdateManyInput>
    /**
     * Filter which FriendLaws to update
     */
    where?: FriendLawWhereInput
    /**
     * Limit how many FriendLaws to update.
     */
    limit?: number
  }

  /**
   * FriendLaw upsert
   */
  export type FriendLawUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendLaw
     */
    select?: FriendLawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendLaw
     */
    omit?: FriendLawOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendLawInclude<ExtArgs> | null
    /**
     * The filter to search for the FriendLaw to update in case it exists.
     */
    where: FriendLawWhereUniqueInput
    /**
     * In case the FriendLaw found by the `where` argument doesn't exist, create a new FriendLaw with this data.
     */
    create: XOR<FriendLawCreateInput, FriendLawUncheckedCreateInput>
    /**
     * In case the FriendLaw was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendLawUpdateInput, FriendLawUncheckedUpdateInput>
  }

  /**
   * FriendLaw delete
   */
  export type FriendLawDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendLaw
     */
    select?: FriendLawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendLaw
     */
    omit?: FriendLawOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendLawInclude<ExtArgs> | null
    /**
     * Filter which FriendLaw to delete.
     */
    where: FriendLawWhereUniqueInput
  }

  /**
   * FriendLaw deleteMany
   */
  export type FriendLawDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FriendLaws to delete
     */
    where?: FriendLawWhereInput
    /**
     * Limit how many FriendLaws to delete.
     */
    limit?: number
  }

  /**
   * FriendLaw without action
   */
  export type FriendLawDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendLaw
     */
    select?: FriendLawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendLaw
     */
    omit?: FriendLawOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendLawInclude<ExtArgs> | null
  }


  /**
   * Model Contrat
   */

  export type AggregateContrat = {
    _count: ContratCountAggregateOutputType | null
    _min: ContratMinAggregateOutputType | null
    _max: ContratMaxAggregateOutputType | null
  }

  export type ContratMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    date: Date | null
    content: string | null
  }

  export type ContratMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    date: Date | null
    content: string | null
  }

  export type ContratCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    date: number
    content: number
    _all: number
  }


  export type ContratMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    date?: true
    content?: true
  }

  export type ContratMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    date?: true
    content?: true
  }

  export type ContratCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    date?: true
    content?: true
    _all?: true
  }

  export type ContratAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contrat to aggregate.
     */
    where?: ContratWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contrats to fetch.
     */
    orderBy?: ContratOrderByWithRelationInput | ContratOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContratWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contrats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contrats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contrats
    **/
    _count?: true | ContratCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContratMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContratMaxAggregateInputType
  }

  export type GetContratAggregateType<T extends ContratAggregateArgs> = {
        [P in keyof T & keyof AggregateContrat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContrat[P]>
      : GetScalarType<T[P], AggregateContrat[P]>
  }




  export type ContratGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContratWhereInput
    orderBy?: ContratOrderByWithAggregationInput | ContratOrderByWithAggregationInput[]
    by: ContratScalarFieldEnum[] | ContratScalarFieldEnum
    having?: ContratScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContratCountAggregateInputType | true
    _min?: ContratMinAggregateInputType
    _max?: ContratMaxAggregateInputType
  }

  export type ContratGroupByOutputType = {
    id: string
    userId: string
    type: string | null
    date: Date | null
    content: string | null
    _count: ContratCountAggregateOutputType | null
    _min: ContratMinAggregateOutputType | null
    _max: ContratMaxAggregateOutputType | null
  }

  type GetContratGroupByPayload<T extends ContratGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContratGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContratGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContratGroupByOutputType[P]>
            : GetScalarType<T[P], ContratGroupByOutputType[P]>
        }
      >
    >


  export type ContratSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    date?: boolean
    content?: boolean
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contrat"]>



  export type ContratSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    date?: boolean
    content?: boolean
  }

  export type ContratOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "date" | "content", ExtArgs["result"]["contrat"]>
  export type ContratInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lawyer?: boolean | LawyerDefaultArgs<ExtArgs>
  }

  export type $ContratPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contrat"
    objects: {
      lawyer: Prisma.$LawyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string | null
      date: Date | null
      content: string | null
    }, ExtArgs["result"]["contrat"]>
    composites: {}
  }

  type ContratGetPayload<S extends boolean | null | undefined | ContratDefaultArgs> = $Result.GetResult<Prisma.$ContratPayload, S>

  type ContratCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContratFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContratCountAggregateInputType | true
    }

  export interface ContratDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contrat'], meta: { name: 'Contrat' } }
    /**
     * Find zero or one Contrat that matches the filter.
     * @param {ContratFindUniqueArgs} args - Arguments to find a Contrat
     * @example
     * // Get one Contrat
     * const contrat = await prisma.contrat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContratFindUniqueArgs>(args: SelectSubset<T, ContratFindUniqueArgs<ExtArgs>>): Prisma__ContratClient<$Result.GetResult<Prisma.$ContratPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contrat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContratFindUniqueOrThrowArgs} args - Arguments to find a Contrat
     * @example
     * // Get one Contrat
     * const contrat = await prisma.contrat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContratFindUniqueOrThrowArgs>(args: SelectSubset<T, ContratFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContratClient<$Result.GetResult<Prisma.$ContratPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contrat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratFindFirstArgs} args - Arguments to find a Contrat
     * @example
     * // Get one Contrat
     * const contrat = await prisma.contrat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContratFindFirstArgs>(args?: SelectSubset<T, ContratFindFirstArgs<ExtArgs>>): Prisma__ContratClient<$Result.GetResult<Prisma.$ContratPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contrat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratFindFirstOrThrowArgs} args - Arguments to find a Contrat
     * @example
     * // Get one Contrat
     * const contrat = await prisma.contrat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContratFindFirstOrThrowArgs>(args?: SelectSubset<T, ContratFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContratClient<$Result.GetResult<Prisma.$ContratPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contrats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contrats
     * const contrats = await prisma.contrat.findMany()
     * 
     * // Get first 10 Contrats
     * const contrats = await prisma.contrat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contratWithIdOnly = await prisma.contrat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContratFindManyArgs>(args?: SelectSubset<T, ContratFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContratPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contrat.
     * @param {ContratCreateArgs} args - Arguments to create a Contrat.
     * @example
     * // Create one Contrat
     * const Contrat = await prisma.contrat.create({
     *   data: {
     *     // ... data to create a Contrat
     *   }
     * })
     * 
     */
    create<T extends ContratCreateArgs>(args: SelectSubset<T, ContratCreateArgs<ExtArgs>>): Prisma__ContratClient<$Result.GetResult<Prisma.$ContratPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contrats.
     * @param {ContratCreateManyArgs} args - Arguments to create many Contrats.
     * @example
     * // Create many Contrats
     * const contrat = await prisma.contrat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContratCreateManyArgs>(args?: SelectSubset<T, ContratCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contrat.
     * @param {ContratDeleteArgs} args - Arguments to delete one Contrat.
     * @example
     * // Delete one Contrat
     * const Contrat = await prisma.contrat.delete({
     *   where: {
     *     // ... filter to delete one Contrat
     *   }
     * })
     * 
     */
    delete<T extends ContratDeleteArgs>(args: SelectSubset<T, ContratDeleteArgs<ExtArgs>>): Prisma__ContratClient<$Result.GetResult<Prisma.$ContratPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contrat.
     * @param {ContratUpdateArgs} args - Arguments to update one Contrat.
     * @example
     * // Update one Contrat
     * const contrat = await prisma.contrat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContratUpdateArgs>(args: SelectSubset<T, ContratUpdateArgs<ExtArgs>>): Prisma__ContratClient<$Result.GetResult<Prisma.$ContratPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contrats.
     * @param {ContratDeleteManyArgs} args - Arguments to filter Contrats to delete.
     * @example
     * // Delete a few Contrats
     * const { count } = await prisma.contrat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContratDeleteManyArgs>(args?: SelectSubset<T, ContratDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contrats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contrats
     * const contrat = await prisma.contrat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContratUpdateManyArgs>(args: SelectSubset<T, ContratUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contrat.
     * @param {ContratUpsertArgs} args - Arguments to update or create a Contrat.
     * @example
     * // Update or create a Contrat
     * const contrat = await prisma.contrat.upsert({
     *   create: {
     *     // ... data to create a Contrat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contrat we want to update
     *   }
     * })
     */
    upsert<T extends ContratUpsertArgs>(args: SelectSubset<T, ContratUpsertArgs<ExtArgs>>): Prisma__ContratClient<$Result.GetResult<Prisma.$ContratPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contrats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratCountArgs} args - Arguments to filter Contrats to count.
     * @example
     * // Count the number of Contrats
     * const count = await prisma.contrat.count({
     *   where: {
     *     // ... the filter for the Contrats we want to count
     *   }
     * })
    **/
    count<T extends ContratCountArgs>(
      args?: Subset<T, ContratCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContratCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contrat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContratAggregateArgs>(args: Subset<T, ContratAggregateArgs>): Prisma.PrismaPromise<GetContratAggregateType<T>>

    /**
     * Group by Contrat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContratGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContratGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContratGroupByArgs['orderBy'] }
        : { orderBy?: ContratGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContratGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContratGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contrat model
   */
  readonly fields: ContratFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contrat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContratClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lawyer<T extends LawyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LawyerDefaultArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contrat model
   */
  interface ContratFieldRefs {
    readonly id: FieldRef<"Contrat", 'String'>
    readonly userId: FieldRef<"Contrat", 'String'>
    readonly type: FieldRef<"Contrat", 'String'>
    readonly date: FieldRef<"Contrat", 'DateTime'>
    readonly content: FieldRef<"Contrat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contrat findUnique
   */
  export type ContratFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrat
     */
    select?: ContratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contrat
     */
    omit?: ContratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratInclude<ExtArgs> | null
    /**
     * Filter, which Contrat to fetch.
     */
    where: ContratWhereUniqueInput
  }

  /**
   * Contrat findUniqueOrThrow
   */
  export type ContratFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrat
     */
    select?: ContratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contrat
     */
    omit?: ContratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratInclude<ExtArgs> | null
    /**
     * Filter, which Contrat to fetch.
     */
    where: ContratWhereUniqueInput
  }

  /**
   * Contrat findFirst
   */
  export type ContratFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrat
     */
    select?: ContratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contrat
     */
    omit?: ContratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratInclude<ExtArgs> | null
    /**
     * Filter, which Contrat to fetch.
     */
    where?: ContratWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contrats to fetch.
     */
    orderBy?: ContratOrderByWithRelationInput | ContratOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contrats.
     */
    cursor?: ContratWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contrats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contrats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contrats.
     */
    distinct?: ContratScalarFieldEnum | ContratScalarFieldEnum[]
  }

  /**
   * Contrat findFirstOrThrow
   */
  export type ContratFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrat
     */
    select?: ContratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contrat
     */
    omit?: ContratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratInclude<ExtArgs> | null
    /**
     * Filter, which Contrat to fetch.
     */
    where?: ContratWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contrats to fetch.
     */
    orderBy?: ContratOrderByWithRelationInput | ContratOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contrats.
     */
    cursor?: ContratWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contrats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contrats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contrats.
     */
    distinct?: ContratScalarFieldEnum | ContratScalarFieldEnum[]
  }

  /**
   * Contrat findMany
   */
  export type ContratFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrat
     */
    select?: ContratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contrat
     */
    omit?: ContratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratInclude<ExtArgs> | null
    /**
     * Filter, which Contrats to fetch.
     */
    where?: ContratWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contrats to fetch.
     */
    orderBy?: ContratOrderByWithRelationInput | ContratOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contrats.
     */
    cursor?: ContratWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contrats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contrats.
     */
    skip?: number
    distinct?: ContratScalarFieldEnum | ContratScalarFieldEnum[]
  }

  /**
   * Contrat create
   */
  export type ContratCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrat
     */
    select?: ContratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contrat
     */
    omit?: ContratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratInclude<ExtArgs> | null
    /**
     * The data needed to create a Contrat.
     */
    data: XOR<ContratCreateInput, ContratUncheckedCreateInput>
  }

  /**
   * Contrat createMany
   */
  export type ContratCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contrats.
     */
    data: ContratCreateManyInput | ContratCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contrat update
   */
  export type ContratUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrat
     */
    select?: ContratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contrat
     */
    omit?: ContratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratInclude<ExtArgs> | null
    /**
     * The data needed to update a Contrat.
     */
    data: XOR<ContratUpdateInput, ContratUncheckedUpdateInput>
    /**
     * Choose, which Contrat to update.
     */
    where: ContratWhereUniqueInput
  }

  /**
   * Contrat updateMany
   */
  export type ContratUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contrats.
     */
    data: XOR<ContratUpdateManyMutationInput, ContratUncheckedUpdateManyInput>
    /**
     * Filter which Contrats to update
     */
    where?: ContratWhereInput
    /**
     * Limit how many Contrats to update.
     */
    limit?: number
  }

  /**
   * Contrat upsert
   */
  export type ContratUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrat
     */
    select?: ContratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contrat
     */
    omit?: ContratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratInclude<ExtArgs> | null
    /**
     * The filter to search for the Contrat to update in case it exists.
     */
    where: ContratWhereUniqueInput
    /**
     * In case the Contrat found by the `where` argument doesn't exist, create a new Contrat with this data.
     */
    create: XOR<ContratCreateInput, ContratUncheckedCreateInput>
    /**
     * In case the Contrat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContratUpdateInput, ContratUncheckedUpdateInput>
  }

  /**
   * Contrat delete
   */
  export type ContratDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrat
     */
    select?: ContratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contrat
     */
    omit?: ContratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratInclude<ExtArgs> | null
    /**
     * Filter which Contrat to delete.
     */
    where: ContratWhereUniqueInput
  }

  /**
   * Contrat deleteMany
   */
  export type ContratDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contrats to delete
     */
    where?: ContratWhereInput
    /**
     * Limit how many Contrats to delete.
     */
    limit?: number
  }

  /**
   * Contrat without action
   */
  export type ContratDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contrat
     */
    select?: ContratSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contrat
     */
    omit?: ContratOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContratInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    TimeToReceive: Date | null
    vue: boolean | null
    type: string | null
    key: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    TimeToReceive: Date | null
    vue: boolean | null
    type: string | null
    key: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    TimeToReceive: number
    vue: number
    type: number
    key: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    TimeToReceive?: true
    vue?: true
    type?: true
    key?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    TimeToReceive?: true
    vue?: true
    type?: true
    key?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    TimeToReceive?: true
    vue?: true
    type?: true
    key?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    content: string | null
    TimeToReceive: Date | null
    vue: boolean | null
    type: string
    key: string | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    TimeToReceive?: boolean
    vue?: boolean
    type?: boolean
    key?: boolean
    lawyer?: boolean | Notification$lawyerArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    content?: boolean
    TimeToReceive?: boolean
    vue?: boolean
    type?: boolean
    key?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "content" | "TimeToReceive" | "vue" | "type" | "key", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lawyer?: boolean | Notification$lawyerArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      lawyer: Prisma.$LawyerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      content: string | null
      TimeToReceive: Date | null
      vue: boolean | null
      type: string
      key: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lawyer<T extends Notification$lawyerArgs<ExtArgs> = {}>(args?: Subset<T, Notification$lawyerArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly TimeToReceive: FieldRef<"Notification", 'DateTime'>
    readonly vue: FieldRef<"Notification", 'Boolean'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly key: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.lawyer
   */
  export type Notification$lawyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    where?: LawyerWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ClientNotification
   */

  export type AggregateClientNotification = {
    _count: ClientNotificationCountAggregateOutputType | null
    _min: ClientNotificationMinAggregateOutputType | null
    _max: ClientNotificationMaxAggregateOutputType | null
  }

  export type ClientNotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    TimeToReceive: Date | null
    vue: boolean | null
    type: string | null
    key: string | null
  }

  export type ClientNotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    content: string | null
    TimeToReceive: Date | null
    vue: boolean | null
    type: string | null
    key: string | null
  }

  export type ClientNotificationCountAggregateOutputType = {
    id: number
    userId: number
    content: number
    TimeToReceive: number
    vue: number
    type: number
    key: number
    _all: number
  }


  export type ClientNotificationMinAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    TimeToReceive?: true
    vue?: true
    type?: true
    key?: true
  }

  export type ClientNotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    TimeToReceive?: true
    vue?: true
    type?: true
    key?: true
  }

  export type ClientNotificationCountAggregateInputType = {
    id?: true
    userId?: true
    content?: true
    TimeToReceive?: true
    vue?: true
    type?: true
    key?: true
    _all?: true
  }

  export type ClientNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientNotification to aggregate.
     */
    where?: ClientNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientNotifications to fetch.
     */
    orderBy?: ClientNotificationOrderByWithRelationInput | ClientNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientNotifications
    **/
    _count?: true | ClientNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientNotificationMaxAggregateInputType
  }

  export type GetClientNotificationAggregateType<T extends ClientNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateClientNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientNotification[P]>
      : GetScalarType<T[P], AggregateClientNotification[P]>
  }




  export type ClientNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientNotificationWhereInput
    orderBy?: ClientNotificationOrderByWithAggregationInput | ClientNotificationOrderByWithAggregationInput[]
    by: ClientNotificationScalarFieldEnum[] | ClientNotificationScalarFieldEnum
    having?: ClientNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientNotificationCountAggregateInputType | true
    _min?: ClientNotificationMinAggregateInputType
    _max?: ClientNotificationMaxAggregateInputType
  }

  export type ClientNotificationGroupByOutputType = {
    id: string
    userId: string
    content: string | null
    TimeToReceive: Date | null
    vue: boolean | null
    type: string
    key: string
    _count: ClientNotificationCountAggregateOutputType | null
    _min: ClientNotificationMinAggregateOutputType | null
    _max: ClientNotificationMaxAggregateOutputType | null
  }

  type GetClientNotificationGroupByPayload<T extends ClientNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], ClientNotificationGroupByOutputType[P]>
        }
      >
    >


  export type ClientNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    content?: boolean
    TimeToReceive?: boolean
    vue?: boolean
    type?: boolean
    key?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientNotification"]>



  export type ClientNotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    content?: boolean
    TimeToReceive?: boolean
    vue?: boolean
    type?: boolean
    key?: boolean
  }

  export type ClientNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "content" | "TimeToReceive" | "vue" | "type" | "key", ExtArgs["result"]["clientNotification"]>
  export type ClientNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ClientNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientNotification"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      content: string | null
      TimeToReceive: Date | null
      vue: boolean | null
      type: string
      key: string
    }, ExtArgs["result"]["clientNotification"]>
    composites: {}
  }

  type ClientNotificationGetPayload<S extends boolean | null | undefined | ClientNotificationDefaultArgs> = $Result.GetResult<Prisma.$ClientNotificationPayload, S>

  type ClientNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientNotificationCountAggregateInputType | true
    }

  export interface ClientNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientNotification'], meta: { name: 'ClientNotification' } }
    /**
     * Find zero or one ClientNotification that matches the filter.
     * @param {ClientNotificationFindUniqueArgs} args - Arguments to find a ClientNotification
     * @example
     * // Get one ClientNotification
     * const clientNotification = await prisma.clientNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientNotificationFindUniqueArgs>(args: SelectSubset<T, ClientNotificationFindUniqueArgs<ExtArgs>>): Prisma__ClientNotificationClient<$Result.GetResult<Prisma.$ClientNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientNotificationFindUniqueOrThrowArgs} args - Arguments to find a ClientNotification
     * @example
     * // Get one ClientNotification
     * const clientNotification = await prisma.clientNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientNotificationClient<$Result.GetResult<Prisma.$ClientNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientNotificationFindFirstArgs} args - Arguments to find a ClientNotification
     * @example
     * // Get one ClientNotification
     * const clientNotification = await prisma.clientNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientNotificationFindFirstArgs>(args?: SelectSubset<T, ClientNotificationFindFirstArgs<ExtArgs>>): Prisma__ClientNotificationClient<$Result.GetResult<Prisma.$ClientNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientNotificationFindFirstOrThrowArgs} args - Arguments to find a ClientNotification
     * @example
     * // Get one ClientNotification
     * const clientNotification = await prisma.clientNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientNotificationClient<$Result.GetResult<Prisma.$ClientNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientNotifications
     * const clientNotifications = await prisma.clientNotification.findMany()
     * 
     * // Get first 10 ClientNotifications
     * const clientNotifications = await prisma.clientNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientNotificationWithIdOnly = await prisma.clientNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientNotificationFindManyArgs>(args?: SelectSubset<T, ClientNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientNotification.
     * @param {ClientNotificationCreateArgs} args - Arguments to create a ClientNotification.
     * @example
     * // Create one ClientNotification
     * const ClientNotification = await prisma.clientNotification.create({
     *   data: {
     *     // ... data to create a ClientNotification
     *   }
     * })
     * 
     */
    create<T extends ClientNotificationCreateArgs>(args: SelectSubset<T, ClientNotificationCreateArgs<ExtArgs>>): Prisma__ClientNotificationClient<$Result.GetResult<Prisma.$ClientNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientNotifications.
     * @param {ClientNotificationCreateManyArgs} args - Arguments to create many ClientNotifications.
     * @example
     * // Create many ClientNotifications
     * const clientNotification = await prisma.clientNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientNotificationCreateManyArgs>(args?: SelectSubset<T, ClientNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientNotification.
     * @param {ClientNotificationDeleteArgs} args - Arguments to delete one ClientNotification.
     * @example
     * // Delete one ClientNotification
     * const ClientNotification = await prisma.clientNotification.delete({
     *   where: {
     *     // ... filter to delete one ClientNotification
     *   }
     * })
     * 
     */
    delete<T extends ClientNotificationDeleteArgs>(args: SelectSubset<T, ClientNotificationDeleteArgs<ExtArgs>>): Prisma__ClientNotificationClient<$Result.GetResult<Prisma.$ClientNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientNotification.
     * @param {ClientNotificationUpdateArgs} args - Arguments to update one ClientNotification.
     * @example
     * // Update one ClientNotification
     * const clientNotification = await prisma.clientNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientNotificationUpdateArgs>(args: SelectSubset<T, ClientNotificationUpdateArgs<ExtArgs>>): Prisma__ClientNotificationClient<$Result.GetResult<Prisma.$ClientNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientNotifications.
     * @param {ClientNotificationDeleteManyArgs} args - Arguments to filter ClientNotifications to delete.
     * @example
     * // Delete a few ClientNotifications
     * const { count } = await prisma.clientNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientNotificationDeleteManyArgs>(args?: SelectSubset<T, ClientNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientNotifications
     * const clientNotification = await prisma.clientNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientNotificationUpdateManyArgs>(args: SelectSubset<T, ClientNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientNotification.
     * @param {ClientNotificationUpsertArgs} args - Arguments to update or create a ClientNotification.
     * @example
     * // Update or create a ClientNotification
     * const clientNotification = await prisma.clientNotification.upsert({
     *   create: {
     *     // ... data to create a ClientNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientNotification we want to update
     *   }
     * })
     */
    upsert<T extends ClientNotificationUpsertArgs>(args: SelectSubset<T, ClientNotificationUpsertArgs<ExtArgs>>): Prisma__ClientNotificationClient<$Result.GetResult<Prisma.$ClientNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientNotificationCountArgs} args - Arguments to filter ClientNotifications to count.
     * @example
     * // Count the number of ClientNotifications
     * const count = await prisma.clientNotification.count({
     *   where: {
     *     // ... the filter for the ClientNotifications we want to count
     *   }
     * })
    **/
    count<T extends ClientNotificationCountArgs>(
      args?: Subset<T, ClientNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientNotificationAggregateArgs>(args: Subset<T, ClientNotificationAggregateArgs>): Prisma.PrismaPromise<GetClientNotificationAggregateType<T>>

    /**
     * Group by ClientNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientNotificationGroupByArgs['orderBy'] }
        : { orderBy?: ClientNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientNotification model
   */
  readonly fields: ClientNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientNotification model
   */
  interface ClientNotificationFieldRefs {
    readonly id: FieldRef<"ClientNotification", 'String'>
    readonly userId: FieldRef<"ClientNotification", 'String'>
    readonly content: FieldRef<"ClientNotification", 'String'>
    readonly TimeToReceive: FieldRef<"ClientNotification", 'DateTime'>
    readonly vue: FieldRef<"ClientNotification", 'Boolean'>
    readonly type: FieldRef<"ClientNotification", 'String'>
    readonly key: FieldRef<"ClientNotification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClientNotification findUnique
   */
  export type ClientNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientNotification
     */
    select?: ClientNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientNotification
     */
    omit?: ClientNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ClientNotification to fetch.
     */
    where: ClientNotificationWhereUniqueInput
  }

  /**
   * ClientNotification findUniqueOrThrow
   */
  export type ClientNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientNotification
     */
    select?: ClientNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientNotification
     */
    omit?: ClientNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ClientNotification to fetch.
     */
    where: ClientNotificationWhereUniqueInput
  }

  /**
   * ClientNotification findFirst
   */
  export type ClientNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientNotification
     */
    select?: ClientNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientNotification
     */
    omit?: ClientNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ClientNotification to fetch.
     */
    where?: ClientNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientNotifications to fetch.
     */
    orderBy?: ClientNotificationOrderByWithRelationInput | ClientNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientNotifications.
     */
    cursor?: ClientNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientNotifications.
     */
    distinct?: ClientNotificationScalarFieldEnum | ClientNotificationScalarFieldEnum[]
  }

  /**
   * ClientNotification findFirstOrThrow
   */
  export type ClientNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientNotification
     */
    select?: ClientNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientNotification
     */
    omit?: ClientNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ClientNotification to fetch.
     */
    where?: ClientNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientNotifications to fetch.
     */
    orderBy?: ClientNotificationOrderByWithRelationInput | ClientNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientNotifications.
     */
    cursor?: ClientNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientNotifications.
     */
    distinct?: ClientNotificationScalarFieldEnum | ClientNotificationScalarFieldEnum[]
  }

  /**
   * ClientNotification findMany
   */
  export type ClientNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientNotification
     */
    select?: ClientNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientNotification
     */
    omit?: ClientNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ClientNotifications to fetch.
     */
    where?: ClientNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientNotifications to fetch.
     */
    orderBy?: ClientNotificationOrderByWithRelationInput | ClientNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientNotifications.
     */
    cursor?: ClientNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientNotifications.
     */
    skip?: number
    distinct?: ClientNotificationScalarFieldEnum | ClientNotificationScalarFieldEnum[]
  }

  /**
   * ClientNotification create
   */
  export type ClientNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientNotification
     */
    select?: ClientNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientNotification
     */
    omit?: ClientNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientNotification.
     */
    data: XOR<ClientNotificationCreateInput, ClientNotificationUncheckedCreateInput>
  }

  /**
   * ClientNotification createMany
   */
  export type ClientNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientNotifications.
     */
    data: ClientNotificationCreateManyInput | ClientNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientNotification update
   */
  export type ClientNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientNotification
     */
    select?: ClientNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientNotification
     */
    omit?: ClientNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientNotification.
     */
    data: XOR<ClientNotificationUpdateInput, ClientNotificationUncheckedUpdateInput>
    /**
     * Choose, which ClientNotification to update.
     */
    where: ClientNotificationWhereUniqueInput
  }

  /**
   * ClientNotification updateMany
   */
  export type ClientNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientNotifications.
     */
    data: XOR<ClientNotificationUpdateManyMutationInput, ClientNotificationUncheckedUpdateManyInput>
    /**
     * Filter which ClientNotifications to update
     */
    where?: ClientNotificationWhereInput
    /**
     * Limit how many ClientNotifications to update.
     */
    limit?: number
  }

  /**
   * ClientNotification upsert
   */
  export type ClientNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientNotification
     */
    select?: ClientNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientNotification
     */
    omit?: ClientNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientNotification to update in case it exists.
     */
    where: ClientNotificationWhereUniqueInput
    /**
     * In case the ClientNotification found by the `where` argument doesn't exist, create a new ClientNotification with this data.
     */
    create: XOR<ClientNotificationCreateInput, ClientNotificationUncheckedCreateInput>
    /**
     * In case the ClientNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientNotificationUpdateInput, ClientNotificationUncheckedUpdateInput>
  }

  /**
   * ClientNotification delete
   */
  export type ClientNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientNotification
     */
    select?: ClientNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientNotification
     */
    omit?: ClientNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientNotificationInclude<ExtArgs> | null
    /**
     * Filter which ClientNotification to delete.
     */
    where: ClientNotificationWhereUniqueInput
  }

  /**
   * ClientNotification deleteMany
   */
  export type ClientNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientNotifications to delete
     */
    where?: ClientNotificationWhereInput
    /**
     * Limit how many ClientNotifications to delete.
     */
    limit?: number
  }

  /**
   * ClientNotification without action
   */
  export type ClientNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientNotification
     */
    select?: ClientNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientNotification
     */
    omit?: ClientNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientNotificationInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    contenu: string | null
    date: Date | null
    key: string | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    contenu: string | null
    date: Date | null
    key: string | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    contenu: number
    date: number
    key: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    contenu?: true
    date?: true
    key?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    contenu?: true
    date?: true
    key?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    contenu?: true
    date?: true
    key?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    userId: string
    name: string
    contenu: string
    date: Date
    key: string
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    contenu?: boolean
    date?: boolean
    key?: boolean
    lawyer?: boolean | Contact$lawyerArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>



  export type ContactSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    contenu?: boolean
    date?: boolean
    key?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "contenu" | "date" | "key", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lawyer?: boolean | Contact$lawyerArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      lawyer: Prisma.$LawyerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      contenu: string
      date: Date
      key: string
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lawyer<T extends Contact$lawyerArgs<ExtArgs> = {}>(args?: Subset<T, Contact$lawyerArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly userId: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly contenu: FieldRef<"Contact", 'String'>
    readonly date: FieldRef<"Contact", 'DateTime'>
    readonly key: FieldRef<"Contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.lawyer
   */
  export type Contact$lawyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    where?: LawyerWhereInput
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model ClientContact
   */

  export type AggregateClientContact = {
    _count: ClientContactCountAggregateOutputType | null
    _min: ClientContactMinAggregateOutputType | null
    _max: ClientContactMaxAggregateOutputType | null
  }

  export type ClientContactMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    contenu: string | null
    date: Date | null
    key: string | null
  }

  export type ClientContactMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    contenu: string | null
    date: Date | null
    key: string | null
  }

  export type ClientContactCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    contenu: number
    date: number
    key: number
    _all: number
  }


  export type ClientContactMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    contenu?: true
    date?: true
    key?: true
  }

  export type ClientContactMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    contenu?: true
    date?: true
    key?: true
  }

  export type ClientContactCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    contenu?: true
    date?: true
    key?: true
    _all?: true
  }

  export type ClientContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContact to aggregate.
     */
    where?: ClientContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContacts to fetch.
     */
    orderBy?: ClientContactOrderByWithRelationInput | ClientContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientContacts
    **/
    _count?: true | ClientContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientContactMaxAggregateInputType
  }

  export type GetClientContactAggregateType<T extends ClientContactAggregateArgs> = {
        [P in keyof T & keyof AggregateClientContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientContact[P]>
      : GetScalarType<T[P], AggregateClientContact[P]>
  }




  export type ClientContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientContactWhereInput
    orderBy?: ClientContactOrderByWithAggregationInput | ClientContactOrderByWithAggregationInput[]
    by: ClientContactScalarFieldEnum[] | ClientContactScalarFieldEnum
    having?: ClientContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientContactCountAggregateInputType | true
    _min?: ClientContactMinAggregateInputType
    _max?: ClientContactMaxAggregateInputType
  }

  export type ClientContactGroupByOutputType = {
    id: string
    userId: string
    name: string
    contenu: string
    date: Date
    key: string
    _count: ClientContactCountAggregateOutputType | null
    _min: ClientContactMinAggregateOutputType | null
    _max: ClientContactMaxAggregateOutputType | null
  }

  type GetClientContactGroupByPayload<T extends ClientContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientContactGroupByOutputType[P]>
            : GetScalarType<T[P], ClientContactGroupByOutputType[P]>
        }
      >
    >


  export type ClientContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    contenu?: boolean
    date?: boolean
    key?: boolean
    client?: boolean | ClientContact$clientArgs<ExtArgs>
  }, ExtArgs["result"]["clientContact"]>



  export type ClientContactSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    contenu?: boolean
    date?: boolean
    key?: boolean
  }

  export type ClientContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "contenu" | "date" | "key", ExtArgs["result"]["clientContact"]>
  export type ClientContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientContact$clientArgs<ExtArgs>
  }

  export type $ClientContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientContact"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      contenu: string
      date: Date
      key: string
    }, ExtArgs["result"]["clientContact"]>
    composites: {}
  }

  type ClientContactGetPayload<S extends boolean | null | undefined | ClientContactDefaultArgs> = $Result.GetResult<Prisma.$ClientContactPayload, S>

  type ClientContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientContactCountAggregateInputType | true
    }

  export interface ClientContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientContact'], meta: { name: 'ClientContact' } }
    /**
     * Find zero or one ClientContact that matches the filter.
     * @param {ClientContactFindUniqueArgs} args - Arguments to find a ClientContact
     * @example
     * // Get one ClientContact
     * const clientContact = await prisma.clientContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientContactFindUniqueArgs>(args: SelectSubset<T, ClientContactFindUniqueArgs<ExtArgs>>): Prisma__ClientContactClient<$Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientContactFindUniqueOrThrowArgs} args - Arguments to find a ClientContact
     * @example
     * // Get one ClientContact
     * const clientContact = await prisma.clientContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientContactClient<$Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactFindFirstArgs} args - Arguments to find a ClientContact
     * @example
     * // Get one ClientContact
     * const clientContact = await prisma.clientContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientContactFindFirstArgs>(args?: SelectSubset<T, ClientContactFindFirstArgs<ExtArgs>>): Prisma__ClientContactClient<$Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactFindFirstOrThrowArgs} args - Arguments to find a ClientContact
     * @example
     * // Get one ClientContact
     * const clientContact = await prisma.clientContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientContactClient<$Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientContacts
     * const clientContacts = await prisma.clientContact.findMany()
     * 
     * // Get first 10 ClientContacts
     * const clientContacts = await prisma.clientContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientContactWithIdOnly = await prisma.clientContact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientContactFindManyArgs>(args?: SelectSubset<T, ClientContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientContact.
     * @param {ClientContactCreateArgs} args - Arguments to create a ClientContact.
     * @example
     * // Create one ClientContact
     * const ClientContact = await prisma.clientContact.create({
     *   data: {
     *     // ... data to create a ClientContact
     *   }
     * })
     * 
     */
    create<T extends ClientContactCreateArgs>(args: SelectSubset<T, ClientContactCreateArgs<ExtArgs>>): Prisma__ClientContactClient<$Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientContacts.
     * @param {ClientContactCreateManyArgs} args - Arguments to create many ClientContacts.
     * @example
     * // Create many ClientContacts
     * const clientContact = await prisma.clientContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientContactCreateManyArgs>(args?: SelectSubset<T, ClientContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientContact.
     * @param {ClientContactDeleteArgs} args - Arguments to delete one ClientContact.
     * @example
     * // Delete one ClientContact
     * const ClientContact = await prisma.clientContact.delete({
     *   where: {
     *     // ... filter to delete one ClientContact
     *   }
     * })
     * 
     */
    delete<T extends ClientContactDeleteArgs>(args: SelectSubset<T, ClientContactDeleteArgs<ExtArgs>>): Prisma__ClientContactClient<$Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientContact.
     * @param {ClientContactUpdateArgs} args - Arguments to update one ClientContact.
     * @example
     * // Update one ClientContact
     * const clientContact = await prisma.clientContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientContactUpdateArgs>(args: SelectSubset<T, ClientContactUpdateArgs<ExtArgs>>): Prisma__ClientContactClient<$Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientContacts.
     * @param {ClientContactDeleteManyArgs} args - Arguments to filter ClientContacts to delete.
     * @example
     * // Delete a few ClientContacts
     * const { count } = await prisma.clientContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientContactDeleteManyArgs>(args?: SelectSubset<T, ClientContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientContacts
     * const clientContact = await prisma.clientContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientContactUpdateManyArgs>(args: SelectSubset<T, ClientContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientContact.
     * @param {ClientContactUpsertArgs} args - Arguments to update or create a ClientContact.
     * @example
     * // Update or create a ClientContact
     * const clientContact = await prisma.clientContact.upsert({
     *   create: {
     *     // ... data to create a ClientContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientContact we want to update
     *   }
     * })
     */
    upsert<T extends ClientContactUpsertArgs>(args: SelectSubset<T, ClientContactUpsertArgs<ExtArgs>>): Prisma__ClientContactClient<$Result.GetResult<Prisma.$ClientContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactCountArgs} args - Arguments to filter ClientContacts to count.
     * @example
     * // Count the number of ClientContacts
     * const count = await prisma.clientContact.count({
     *   where: {
     *     // ... the filter for the ClientContacts we want to count
     *   }
     * })
    **/
    count<T extends ClientContactCountArgs>(
      args?: Subset<T, ClientContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientContactAggregateArgs>(args: Subset<T, ClientContactAggregateArgs>): Prisma.PrismaPromise<GetClientContactAggregateType<T>>

    /**
     * Group by ClientContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientContactGroupByArgs['orderBy'] }
        : { orderBy?: ClientContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientContact model
   */
  readonly fields: ClientContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientContact$clientArgs<ExtArgs> = {}>(args?: Subset<T, ClientContact$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientContact model
   */
  interface ClientContactFieldRefs {
    readonly id: FieldRef<"ClientContact", 'String'>
    readonly userId: FieldRef<"ClientContact", 'String'>
    readonly name: FieldRef<"ClientContact", 'String'>
    readonly contenu: FieldRef<"ClientContact", 'String'>
    readonly date: FieldRef<"ClientContact", 'DateTime'>
    readonly key: FieldRef<"ClientContact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClientContact findUnique
   */
  export type ClientContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null
    /**
     * Filter, which ClientContact to fetch.
     */
    where: ClientContactWhereUniqueInput
  }

  /**
   * ClientContact findUniqueOrThrow
   */
  export type ClientContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null
    /**
     * Filter, which ClientContact to fetch.
     */
    where: ClientContactWhereUniqueInput
  }

  /**
   * ClientContact findFirst
   */
  export type ClientContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null
    /**
     * Filter, which ClientContact to fetch.
     */
    where?: ClientContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContacts to fetch.
     */
    orderBy?: ClientContactOrderByWithRelationInput | ClientContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContacts.
     */
    cursor?: ClientContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContacts.
     */
    distinct?: ClientContactScalarFieldEnum | ClientContactScalarFieldEnum[]
  }

  /**
   * ClientContact findFirstOrThrow
   */
  export type ClientContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null
    /**
     * Filter, which ClientContact to fetch.
     */
    where?: ClientContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContacts to fetch.
     */
    orderBy?: ClientContactOrderByWithRelationInput | ClientContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientContacts.
     */
    cursor?: ClientContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientContacts.
     */
    distinct?: ClientContactScalarFieldEnum | ClientContactScalarFieldEnum[]
  }

  /**
   * ClientContact findMany
   */
  export type ClientContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null
    /**
     * Filter, which ClientContacts to fetch.
     */
    where?: ClientContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientContacts to fetch.
     */
    orderBy?: ClientContactOrderByWithRelationInput | ClientContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientContacts.
     */
    cursor?: ClientContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientContacts.
     */
    skip?: number
    distinct?: ClientContactScalarFieldEnum | ClientContactScalarFieldEnum[]
  }

  /**
   * ClientContact create
   */
  export type ClientContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientContact.
     */
    data: XOR<ClientContactCreateInput, ClientContactUncheckedCreateInput>
  }

  /**
   * ClientContact createMany
   */
  export type ClientContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientContacts.
     */
    data: ClientContactCreateManyInput | ClientContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientContact update
   */
  export type ClientContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientContact.
     */
    data: XOR<ClientContactUpdateInput, ClientContactUncheckedUpdateInput>
    /**
     * Choose, which ClientContact to update.
     */
    where: ClientContactWhereUniqueInput
  }

  /**
   * ClientContact updateMany
   */
  export type ClientContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientContacts.
     */
    data: XOR<ClientContactUpdateManyMutationInput, ClientContactUncheckedUpdateManyInput>
    /**
     * Filter which ClientContacts to update
     */
    where?: ClientContactWhereInput
    /**
     * Limit how many ClientContacts to update.
     */
    limit?: number
  }

  /**
   * ClientContact upsert
   */
  export type ClientContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientContact to update in case it exists.
     */
    where: ClientContactWhereUniqueInput
    /**
     * In case the ClientContact found by the `where` argument doesn't exist, create a new ClientContact with this data.
     */
    create: XOR<ClientContactCreateInput, ClientContactUncheckedCreateInput>
    /**
     * In case the ClientContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientContactUpdateInput, ClientContactUncheckedUpdateInput>
  }

  /**
   * ClientContact delete
   */
  export type ClientContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null
    /**
     * Filter which ClientContact to delete.
     */
    where: ClientContactWhereUniqueInput
  }

  /**
   * ClientContact deleteMany
   */
  export type ClientContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientContacts to delete
     */
    where?: ClientContactWhereInput
    /**
     * Limit how many ClientContacts to delete.
     */
    limit?: number
  }

  /**
   * ClientContact.client
   */
  export type ClientContact$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * ClientContact without action
   */
  export type ClientContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientContact
     */
    select?: ClientContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientContact
     */
    omit?: ClientContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientContactInclude<ExtArgs> | null
  }


  /**
   * Model Diplome
   */

  export type AggregateDiplome = {
    _count: DiplomeCountAggregateOutputType | null
    _min: DiplomeMinAggregateOutputType | null
    _max: DiplomeMaxAggregateOutputType | null
  }

  export type DiplomeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    ecole: string | null
    anne: string | null
    nom: string | null
  }

  export type DiplomeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    ecole: string | null
    anne: string | null
    nom: string | null
  }

  export type DiplomeCountAggregateOutputType = {
    id: number
    userId: number
    ecole: number
    anne: number
    nom: number
    _all: number
  }


  export type DiplomeMinAggregateInputType = {
    id?: true
    userId?: true
    ecole?: true
    anne?: true
    nom?: true
  }

  export type DiplomeMaxAggregateInputType = {
    id?: true
    userId?: true
    ecole?: true
    anne?: true
    nom?: true
  }

  export type DiplomeCountAggregateInputType = {
    id?: true
    userId?: true
    ecole?: true
    anne?: true
    nom?: true
    _all?: true
  }

  export type DiplomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diplome to aggregate.
     */
    where?: DiplomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diplomes to fetch.
     */
    orderBy?: DiplomeOrderByWithRelationInput | DiplomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiplomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diplomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diplomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diplomes
    **/
    _count?: true | DiplomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiplomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiplomeMaxAggregateInputType
  }

  export type GetDiplomeAggregateType<T extends DiplomeAggregateArgs> = {
        [P in keyof T & keyof AggregateDiplome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiplome[P]>
      : GetScalarType<T[P], AggregateDiplome[P]>
  }




  export type DiplomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiplomeWhereInput
    orderBy?: DiplomeOrderByWithAggregationInput | DiplomeOrderByWithAggregationInput[]
    by: DiplomeScalarFieldEnum[] | DiplomeScalarFieldEnum
    having?: DiplomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiplomeCountAggregateInputType | true
    _min?: DiplomeMinAggregateInputType
    _max?: DiplomeMaxAggregateInputType
  }

  export type DiplomeGroupByOutputType = {
    id: string
    userId: string
    ecole: string
    anne: string
    nom: string
    _count: DiplomeCountAggregateOutputType | null
    _min: DiplomeMinAggregateOutputType | null
    _max: DiplomeMaxAggregateOutputType | null
  }

  type GetDiplomeGroupByPayload<T extends DiplomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiplomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiplomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiplomeGroupByOutputType[P]>
            : GetScalarType<T[P], DiplomeGroupByOutputType[P]>
        }
      >
    >


  export type DiplomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    ecole?: boolean
    anne?: boolean
    nom?: boolean
    lawyer?: boolean | Diplome$lawyerArgs<ExtArgs>
  }, ExtArgs["result"]["diplome"]>



  export type DiplomeSelectScalar = {
    id?: boolean
    userId?: boolean
    ecole?: boolean
    anne?: boolean
    nom?: boolean
  }

  export type DiplomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "ecole" | "anne" | "nom", ExtArgs["result"]["diplome"]>
  export type DiplomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lawyer?: boolean | Diplome$lawyerArgs<ExtArgs>
  }

  export type $DiplomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diplome"
    objects: {
      lawyer: Prisma.$LawyerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      ecole: string
      anne: string
      nom: string
    }, ExtArgs["result"]["diplome"]>
    composites: {}
  }

  type DiplomeGetPayload<S extends boolean | null | undefined | DiplomeDefaultArgs> = $Result.GetResult<Prisma.$DiplomePayload, S>

  type DiplomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiplomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiplomeCountAggregateInputType | true
    }

  export interface DiplomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diplome'], meta: { name: 'Diplome' } }
    /**
     * Find zero or one Diplome that matches the filter.
     * @param {DiplomeFindUniqueArgs} args - Arguments to find a Diplome
     * @example
     * // Get one Diplome
     * const diplome = await prisma.diplome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiplomeFindUniqueArgs>(args: SelectSubset<T, DiplomeFindUniqueArgs<ExtArgs>>): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Diplome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiplomeFindUniqueOrThrowArgs} args - Arguments to find a Diplome
     * @example
     * // Get one Diplome
     * const diplome = await prisma.diplome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiplomeFindUniqueOrThrowArgs>(args: SelectSubset<T, DiplomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diplome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeFindFirstArgs} args - Arguments to find a Diplome
     * @example
     * // Get one Diplome
     * const diplome = await prisma.diplome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiplomeFindFirstArgs>(args?: SelectSubset<T, DiplomeFindFirstArgs<ExtArgs>>): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diplome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeFindFirstOrThrowArgs} args - Arguments to find a Diplome
     * @example
     * // Get one Diplome
     * const diplome = await prisma.diplome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiplomeFindFirstOrThrowArgs>(args?: SelectSubset<T, DiplomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Diplomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diplomes
     * const diplomes = await prisma.diplome.findMany()
     * 
     * // Get first 10 Diplomes
     * const diplomes = await prisma.diplome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diplomeWithIdOnly = await prisma.diplome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiplomeFindManyArgs>(args?: SelectSubset<T, DiplomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Diplome.
     * @param {DiplomeCreateArgs} args - Arguments to create a Diplome.
     * @example
     * // Create one Diplome
     * const Diplome = await prisma.diplome.create({
     *   data: {
     *     // ... data to create a Diplome
     *   }
     * })
     * 
     */
    create<T extends DiplomeCreateArgs>(args: SelectSubset<T, DiplomeCreateArgs<ExtArgs>>): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Diplomes.
     * @param {DiplomeCreateManyArgs} args - Arguments to create many Diplomes.
     * @example
     * // Create many Diplomes
     * const diplome = await prisma.diplome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiplomeCreateManyArgs>(args?: SelectSubset<T, DiplomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Diplome.
     * @param {DiplomeDeleteArgs} args - Arguments to delete one Diplome.
     * @example
     * // Delete one Diplome
     * const Diplome = await prisma.diplome.delete({
     *   where: {
     *     // ... filter to delete one Diplome
     *   }
     * })
     * 
     */
    delete<T extends DiplomeDeleteArgs>(args: SelectSubset<T, DiplomeDeleteArgs<ExtArgs>>): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Diplome.
     * @param {DiplomeUpdateArgs} args - Arguments to update one Diplome.
     * @example
     * // Update one Diplome
     * const diplome = await prisma.diplome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiplomeUpdateArgs>(args: SelectSubset<T, DiplomeUpdateArgs<ExtArgs>>): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Diplomes.
     * @param {DiplomeDeleteManyArgs} args - Arguments to filter Diplomes to delete.
     * @example
     * // Delete a few Diplomes
     * const { count } = await prisma.diplome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiplomeDeleteManyArgs>(args?: SelectSubset<T, DiplomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diplomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diplomes
     * const diplome = await prisma.diplome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiplomeUpdateManyArgs>(args: SelectSubset<T, DiplomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diplome.
     * @param {DiplomeUpsertArgs} args - Arguments to update or create a Diplome.
     * @example
     * // Update or create a Diplome
     * const diplome = await prisma.diplome.upsert({
     *   create: {
     *     // ... data to create a Diplome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diplome we want to update
     *   }
     * })
     */
    upsert<T extends DiplomeUpsertArgs>(args: SelectSubset<T, DiplomeUpsertArgs<ExtArgs>>): Prisma__DiplomeClient<$Result.GetResult<Prisma.$DiplomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Diplomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeCountArgs} args - Arguments to filter Diplomes to count.
     * @example
     * // Count the number of Diplomes
     * const count = await prisma.diplome.count({
     *   where: {
     *     // ... the filter for the Diplomes we want to count
     *   }
     * })
    **/
    count<T extends DiplomeCountArgs>(
      args?: Subset<T, DiplomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiplomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diplome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiplomeAggregateArgs>(args: Subset<T, DiplomeAggregateArgs>): Prisma.PrismaPromise<GetDiplomeAggregateType<T>>

    /**
     * Group by Diplome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiplomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiplomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiplomeGroupByArgs['orderBy'] }
        : { orderBy?: DiplomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiplomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiplomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diplome model
   */
  readonly fields: DiplomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diplome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiplomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lawyer<T extends Diplome$lawyerArgs<ExtArgs> = {}>(args?: Subset<T, Diplome$lawyerArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Diplome model
   */
  interface DiplomeFieldRefs {
    readonly id: FieldRef<"Diplome", 'String'>
    readonly userId: FieldRef<"Diplome", 'String'>
    readonly ecole: FieldRef<"Diplome", 'String'>
    readonly anne: FieldRef<"Diplome", 'String'>
    readonly nom: FieldRef<"Diplome", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Diplome findUnique
   */
  export type DiplomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diplome
     */
    omit?: DiplomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * Filter, which Diplome to fetch.
     */
    where: DiplomeWhereUniqueInput
  }

  /**
   * Diplome findUniqueOrThrow
   */
  export type DiplomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diplome
     */
    omit?: DiplomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * Filter, which Diplome to fetch.
     */
    where: DiplomeWhereUniqueInput
  }

  /**
   * Diplome findFirst
   */
  export type DiplomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diplome
     */
    omit?: DiplomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * Filter, which Diplome to fetch.
     */
    where?: DiplomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diplomes to fetch.
     */
    orderBy?: DiplomeOrderByWithRelationInput | DiplomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diplomes.
     */
    cursor?: DiplomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diplomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diplomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diplomes.
     */
    distinct?: DiplomeScalarFieldEnum | DiplomeScalarFieldEnum[]
  }

  /**
   * Diplome findFirstOrThrow
   */
  export type DiplomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diplome
     */
    omit?: DiplomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * Filter, which Diplome to fetch.
     */
    where?: DiplomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diplomes to fetch.
     */
    orderBy?: DiplomeOrderByWithRelationInput | DiplomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diplomes.
     */
    cursor?: DiplomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diplomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diplomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diplomes.
     */
    distinct?: DiplomeScalarFieldEnum | DiplomeScalarFieldEnum[]
  }

  /**
   * Diplome findMany
   */
  export type DiplomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diplome
     */
    omit?: DiplomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * Filter, which Diplomes to fetch.
     */
    where?: DiplomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diplomes to fetch.
     */
    orderBy?: DiplomeOrderByWithRelationInput | DiplomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diplomes.
     */
    cursor?: DiplomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diplomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diplomes.
     */
    skip?: number
    distinct?: DiplomeScalarFieldEnum | DiplomeScalarFieldEnum[]
  }

  /**
   * Diplome create
   */
  export type DiplomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diplome
     */
    omit?: DiplomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * The data needed to create a Diplome.
     */
    data: XOR<DiplomeCreateInput, DiplomeUncheckedCreateInput>
  }

  /**
   * Diplome createMany
   */
  export type DiplomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diplomes.
     */
    data: DiplomeCreateManyInput | DiplomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diplome update
   */
  export type DiplomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diplome
     */
    omit?: DiplomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * The data needed to update a Diplome.
     */
    data: XOR<DiplomeUpdateInput, DiplomeUncheckedUpdateInput>
    /**
     * Choose, which Diplome to update.
     */
    where: DiplomeWhereUniqueInput
  }

  /**
   * Diplome updateMany
   */
  export type DiplomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diplomes.
     */
    data: XOR<DiplomeUpdateManyMutationInput, DiplomeUncheckedUpdateManyInput>
    /**
     * Filter which Diplomes to update
     */
    where?: DiplomeWhereInput
    /**
     * Limit how many Diplomes to update.
     */
    limit?: number
  }

  /**
   * Diplome upsert
   */
  export type DiplomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diplome
     */
    omit?: DiplomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * The filter to search for the Diplome to update in case it exists.
     */
    where: DiplomeWhereUniqueInput
    /**
     * In case the Diplome found by the `where` argument doesn't exist, create a new Diplome with this data.
     */
    create: XOR<DiplomeCreateInput, DiplomeUncheckedCreateInput>
    /**
     * In case the Diplome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiplomeUpdateInput, DiplomeUncheckedUpdateInput>
  }

  /**
   * Diplome delete
   */
  export type DiplomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diplome
     */
    omit?: DiplomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiplomeInclude<ExtArgs> | null
    /**
     * Filter which Diplome to delete.
     */
    where: DiplomeWhereUniqueInput
  }

  /**
   * Diplome deleteMany
   */
  export type DiplomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diplomes to delete
     */
    where?: DiplomeWhereInput
    /**
     * Limit how many Diplomes to delete.
     */
    limit?: number
  }

  /**
   * Diplome.lawyer
   */
  export type Diplome$lawyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    where?: LawyerWhereInput
  }

  /**
   * Diplome without action
   */
  export type DiplomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diplome
     */
    select?: DiplomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diplome
     */
    omit?: DiplomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiplomeInclude<ExtArgs> | null
  }


  /**
   * Model Experience
   */

  export type AggregateExperience = {
    _count: ExperienceCountAggregateOutputType | null
    _min: ExperienceMinAggregateOutputType | null
    _max: ExperienceMaxAggregateOutputType | null
  }

  export type ExperienceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    poste: string | null
    durant: string | null
  }

  export type ExperienceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    poste: string | null
    durant: string | null
  }

  export type ExperienceCountAggregateOutputType = {
    id: number
    userId: number
    poste: number
    durant: number
    _all: number
  }


  export type ExperienceMinAggregateInputType = {
    id?: true
    userId?: true
    poste?: true
    durant?: true
  }

  export type ExperienceMaxAggregateInputType = {
    id?: true
    userId?: true
    poste?: true
    durant?: true
  }

  export type ExperienceCountAggregateInputType = {
    id?: true
    userId?: true
    poste?: true
    durant?: true
    _all?: true
  }

  export type ExperienceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Experience to aggregate.
     */
    where?: ExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiences to fetch.
     */
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Experiences
    **/
    _count?: true | ExperienceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExperienceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExperienceMaxAggregateInputType
  }

  export type GetExperienceAggregateType<T extends ExperienceAggregateArgs> = {
        [P in keyof T & keyof AggregateExperience]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExperience[P]>
      : GetScalarType<T[P], AggregateExperience[P]>
  }




  export type ExperienceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExperienceWhereInput
    orderBy?: ExperienceOrderByWithAggregationInput | ExperienceOrderByWithAggregationInput[]
    by: ExperienceScalarFieldEnum[] | ExperienceScalarFieldEnum
    having?: ExperienceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExperienceCountAggregateInputType | true
    _min?: ExperienceMinAggregateInputType
    _max?: ExperienceMaxAggregateInputType
  }

  export type ExperienceGroupByOutputType = {
    id: string
    userId: string
    poste: string
    durant: string
    _count: ExperienceCountAggregateOutputType | null
    _min: ExperienceMinAggregateOutputType | null
    _max: ExperienceMaxAggregateOutputType | null
  }

  type GetExperienceGroupByPayload<T extends ExperienceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExperienceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExperienceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExperienceGroupByOutputType[P]>
            : GetScalarType<T[P], ExperienceGroupByOutputType[P]>
        }
      >
    >


  export type ExperienceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    poste?: boolean
    durant?: boolean
    lawyer?: boolean | Experience$lawyerArgs<ExtArgs>
  }, ExtArgs["result"]["experience"]>



  export type ExperienceSelectScalar = {
    id?: boolean
    userId?: boolean
    poste?: boolean
    durant?: boolean
  }

  export type ExperienceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "poste" | "durant", ExtArgs["result"]["experience"]>
  export type ExperienceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lawyer?: boolean | Experience$lawyerArgs<ExtArgs>
  }

  export type $ExperiencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Experience"
    objects: {
      lawyer: Prisma.$LawyerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      poste: string
      durant: string
    }, ExtArgs["result"]["experience"]>
    composites: {}
  }

  type ExperienceGetPayload<S extends boolean | null | undefined | ExperienceDefaultArgs> = $Result.GetResult<Prisma.$ExperiencePayload, S>

  type ExperienceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExperienceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExperienceCountAggregateInputType | true
    }

  export interface ExperienceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Experience'], meta: { name: 'Experience' } }
    /**
     * Find zero or one Experience that matches the filter.
     * @param {ExperienceFindUniqueArgs} args - Arguments to find a Experience
     * @example
     * // Get one Experience
     * const experience = await prisma.experience.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExperienceFindUniqueArgs>(args: SelectSubset<T, ExperienceFindUniqueArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Experience that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExperienceFindUniqueOrThrowArgs} args - Arguments to find a Experience
     * @example
     * // Get one Experience
     * const experience = await prisma.experience.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExperienceFindUniqueOrThrowArgs>(args: SelectSubset<T, ExperienceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Experience that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceFindFirstArgs} args - Arguments to find a Experience
     * @example
     * // Get one Experience
     * const experience = await prisma.experience.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExperienceFindFirstArgs>(args?: SelectSubset<T, ExperienceFindFirstArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Experience that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceFindFirstOrThrowArgs} args - Arguments to find a Experience
     * @example
     * // Get one Experience
     * const experience = await prisma.experience.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExperienceFindFirstOrThrowArgs>(args?: SelectSubset<T, ExperienceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Experiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Experiences
     * const experiences = await prisma.experience.findMany()
     * 
     * // Get first 10 Experiences
     * const experiences = await prisma.experience.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const experienceWithIdOnly = await prisma.experience.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExperienceFindManyArgs>(args?: SelectSubset<T, ExperienceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Experience.
     * @param {ExperienceCreateArgs} args - Arguments to create a Experience.
     * @example
     * // Create one Experience
     * const Experience = await prisma.experience.create({
     *   data: {
     *     // ... data to create a Experience
     *   }
     * })
     * 
     */
    create<T extends ExperienceCreateArgs>(args: SelectSubset<T, ExperienceCreateArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Experiences.
     * @param {ExperienceCreateManyArgs} args - Arguments to create many Experiences.
     * @example
     * // Create many Experiences
     * const experience = await prisma.experience.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExperienceCreateManyArgs>(args?: SelectSubset<T, ExperienceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Experience.
     * @param {ExperienceDeleteArgs} args - Arguments to delete one Experience.
     * @example
     * // Delete one Experience
     * const Experience = await prisma.experience.delete({
     *   where: {
     *     // ... filter to delete one Experience
     *   }
     * })
     * 
     */
    delete<T extends ExperienceDeleteArgs>(args: SelectSubset<T, ExperienceDeleteArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Experience.
     * @param {ExperienceUpdateArgs} args - Arguments to update one Experience.
     * @example
     * // Update one Experience
     * const experience = await prisma.experience.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExperienceUpdateArgs>(args: SelectSubset<T, ExperienceUpdateArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Experiences.
     * @param {ExperienceDeleteManyArgs} args - Arguments to filter Experiences to delete.
     * @example
     * // Delete a few Experiences
     * const { count } = await prisma.experience.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExperienceDeleteManyArgs>(args?: SelectSubset<T, ExperienceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Experiences
     * const experience = await prisma.experience.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExperienceUpdateManyArgs>(args: SelectSubset<T, ExperienceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Experience.
     * @param {ExperienceUpsertArgs} args - Arguments to update or create a Experience.
     * @example
     * // Update or create a Experience
     * const experience = await prisma.experience.upsert({
     *   create: {
     *     // ... data to create a Experience
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Experience we want to update
     *   }
     * })
     */
    upsert<T extends ExperienceUpsertArgs>(args: SelectSubset<T, ExperienceUpsertArgs<ExtArgs>>): Prisma__ExperienceClient<$Result.GetResult<Prisma.$ExperiencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceCountArgs} args - Arguments to filter Experiences to count.
     * @example
     * // Count the number of Experiences
     * const count = await prisma.experience.count({
     *   where: {
     *     // ... the filter for the Experiences we want to count
     *   }
     * })
    **/
    count<T extends ExperienceCountArgs>(
      args?: Subset<T, ExperienceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExperienceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Experience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExperienceAggregateArgs>(args: Subset<T, ExperienceAggregateArgs>): Prisma.PrismaPromise<GetExperienceAggregateType<T>>

    /**
     * Group by Experience.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperienceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExperienceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExperienceGroupByArgs['orderBy'] }
        : { orderBy?: ExperienceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExperienceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExperienceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Experience model
   */
  readonly fields: ExperienceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Experience.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExperienceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lawyer<T extends Experience$lawyerArgs<ExtArgs> = {}>(args?: Subset<T, Experience$lawyerArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Experience model
   */
  interface ExperienceFieldRefs {
    readonly id: FieldRef<"Experience", 'String'>
    readonly userId: FieldRef<"Experience", 'String'>
    readonly poste: FieldRef<"Experience", 'String'>
    readonly durant: FieldRef<"Experience", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Experience findUnique
   */
  export type ExperienceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experience to fetch.
     */
    where: ExperienceWhereUniqueInput
  }

  /**
   * Experience findUniqueOrThrow
   */
  export type ExperienceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experience to fetch.
     */
    where: ExperienceWhereUniqueInput
  }

  /**
   * Experience findFirst
   */
  export type ExperienceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experience to fetch.
     */
    where?: ExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiences to fetch.
     */
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Experiences.
     */
    cursor?: ExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Experiences.
     */
    distinct?: ExperienceScalarFieldEnum | ExperienceScalarFieldEnum[]
  }

  /**
   * Experience findFirstOrThrow
   */
  export type ExperienceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experience to fetch.
     */
    where?: ExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiences to fetch.
     */
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Experiences.
     */
    cursor?: ExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Experiences.
     */
    distinct?: ExperienceScalarFieldEnum | ExperienceScalarFieldEnum[]
  }

  /**
   * Experience findMany
   */
  export type ExperienceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter, which Experiences to fetch.
     */
    where?: ExperienceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Experiences to fetch.
     */
    orderBy?: ExperienceOrderByWithRelationInput | ExperienceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Experiences.
     */
    cursor?: ExperienceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Experiences.
     */
    skip?: number
    distinct?: ExperienceScalarFieldEnum | ExperienceScalarFieldEnum[]
  }

  /**
   * Experience create
   */
  export type ExperienceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * The data needed to create a Experience.
     */
    data: XOR<ExperienceCreateInput, ExperienceUncheckedCreateInput>
  }

  /**
   * Experience createMany
   */
  export type ExperienceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Experiences.
     */
    data: ExperienceCreateManyInput | ExperienceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Experience update
   */
  export type ExperienceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * The data needed to update a Experience.
     */
    data: XOR<ExperienceUpdateInput, ExperienceUncheckedUpdateInput>
    /**
     * Choose, which Experience to update.
     */
    where: ExperienceWhereUniqueInput
  }

  /**
   * Experience updateMany
   */
  export type ExperienceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Experiences.
     */
    data: XOR<ExperienceUpdateManyMutationInput, ExperienceUncheckedUpdateManyInput>
    /**
     * Filter which Experiences to update
     */
    where?: ExperienceWhereInput
    /**
     * Limit how many Experiences to update.
     */
    limit?: number
  }

  /**
   * Experience upsert
   */
  export type ExperienceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * The filter to search for the Experience to update in case it exists.
     */
    where: ExperienceWhereUniqueInput
    /**
     * In case the Experience found by the `where` argument doesn't exist, create a new Experience with this data.
     */
    create: XOR<ExperienceCreateInput, ExperienceUncheckedCreateInput>
    /**
     * In case the Experience was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExperienceUpdateInput, ExperienceUncheckedUpdateInput>
  }

  /**
   * Experience delete
   */
  export type ExperienceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
    /**
     * Filter which Experience to delete.
     */
    where: ExperienceWhereUniqueInput
  }

  /**
   * Experience deleteMany
   */
  export type ExperienceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Experiences to delete
     */
    where?: ExperienceWhereInput
    /**
     * Limit how many Experiences to delete.
     */
    limit?: number
  }

  /**
   * Experience.lawyer
   */
  export type Experience$lawyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    where?: LawyerWhereInput
  }

  /**
   * Experience without action
   */
  export type ExperienceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Experience
     */
    select?: ExperienceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Experience
     */
    omit?: ExperienceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExperienceInclude<ExtArgs> | null
  }


  /**
   * Model Calendar
   */

  export type AggregateCalendar = {
    _count: CalendarCountAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  export type CalendarMinAggregateOutputType = {
    id: string | null
    userId: string | null
    client: string | null
    moment: Date | null
  }

  export type CalendarMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    client: string | null
    moment: Date | null
  }

  export type CalendarCountAggregateOutputType = {
    id: number
    userId: number
    client: number
    moment: number
    _all: number
  }


  export type CalendarMinAggregateInputType = {
    id?: true
    userId?: true
    client?: true
    moment?: true
  }

  export type CalendarMaxAggregateInputType = {
    id?: true
    userId?: true
    client?: true
    moment?: true
  }

  export type CalendarCountAggregateInputType = {
    id?: true
    userId?: true
    client?: true
    moment?: true
    _all?: true
  }

  export type CalendarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calendar to aggregate.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Calendars
    **/
    _count?: true | CalendarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarMaxAggregateInputType
  }

  export type GetCalendarAggregateType<T extends CalendarAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendar[P]>
      : GetScalarType<T[P], AggregateCalendar[P]>
  }




  export type CalendarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarWhereInput
    orderBy?: CalendarOrderByWithAggregationInput | CalendarOrderByWithAggregationInput[]
    by: CalendarScalarFieldEnum[] | CalendarScalarFieldEnum
    having?: CalendarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarCountAggregateInputType | true
    _min?: CalendarMinAggregateInputType
    _max?: CalendarMaxAggregateInputType
  }

  export type CalendarGroupByOutputType = {
    id: string
    userId: string
    client: string
    moment: Date
    _count: CalendarCountAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  type GetCalendarGroupByPayload<T extends CalendarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarGroupByOutputType[P]>
        }
      >
    >


  export type CalendarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    client?: boolean
    moment?: boolean
    lawyer?: boolean | Calendar$lawyerArgs<ExtArgs>
  }, ExtArgs["result"]["calendar"]>



  export type CalendarSelectScalar = {
    id?: boolean
    userId?: boolean
    client?: boolean
    moment?: boolean
  }

  export type CalendarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "client" | "moment", ExtArgs["result"]["calendar"]>
  export type CalendarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lawyer?: boolean | Calendar$lawyerArgs<ExtArgs>
  }

  export type $CalendarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Calendar"
    objects: {
      lawyer: Prisma.$LawyerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      client: string
      moment: Date
    }, ExtArgs["result"]["calendar"]>
    composites: {}
  }

  type CalendarGetPayload<S extends boolean | null | undefined | CalendarDefaultArgs> = $Result.GetResult<Prisma.$CalendarPayload, S>

  type CalendarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarCountAggregateInputType | true
    }

  export interface CalendarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Calendar'], meta: { name: 'Calendar' } }
    /**
     * Find zero or one Calendar that matches the filter.
     * @param {CalendarFindUniqueArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarFindUniqueArgs>(args: SelectSubset<T, CalendarFindUniqueArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Calendar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarFindUniqueOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calendar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindFirstArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarFindFirstArgs>(args?: SelectSubset<T, CalendarFindFirstArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calendar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindFirstOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Calendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calendars
     * const calendars = await prisma.calendar.findMany()
     * 
     * // Get first 10 Calendars
     * const calendars = await prisma.calendar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarWithIdOnly = await prisma.calendar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarFindManyArgs>(args?: SelectSubset<T, CalendarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Calendar.
     * @param {CalendarCreateArgs} args - Arguments to create a Calendar.
     * @example
     * // Create one Calendar
     * const Calendar = await prisma.calendar.create({
     *   data: {
     *     // ... data to create a Calendar
     *   }
     * })
     * 
     */
    create<T extends CalendarCreateArgs>(args: SelectSubset<T, CalendarCreateArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Calendars.
     * @param {CalendarCreateManyArgs} args - Arguments to create many Calendars.
     * @example
     * // Create many Calendars
     * const calendar = await prisma.calendar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarCreateManyArgs>(args?: SelectSubset<T, CalendarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Calendar.
     * @param {CalendarDeleteArgs} args - Arguments to delete one Calendar.
     * @example
     * // Delete one Calendar
     * const Calendar = await prisma.calendar.delete({
     *   where: {
     *     // ... filter to delete one Calendar
     *   }
     * })
     * 
     */
    delete<T extends CalendarDeleteArgs>(args: SelectSubset<T, CalendarDeleteArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Calendar.
     * @param {CalendarUpdateArgs} args - Arguments to update one Calendar.
     * @example
     * // Update one Calendar
     * const calendar = await prisma.calendar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarUpdateArgs>(args: SelectSubset<T, CalendarUpdateArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Calendars.
     * @param {CalendarDeleteManyArgs} args - Arguments to filter Calendars to delete.
     * @example
     * // Delete a few Calendars
     * const { count } = await prisma.calendar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarDeleteManyArgs>(args?: SelectSubset<T, CalendarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calendars
     * const calendar = await prisma.calendar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarUpdateManyArgs>(args: SelectSubset<T, CalendarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Calendar.
     * @param {CalendarUpsertArgs} args - Arguments to update or create a Calendar.
     * @example
     * // Update or create a Calendar
     * const calendar = await prisma.calendar.upsert({
     *   create: {
     *     // ... data to create a Calendar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Calendar we want to update
     *   }
     * })
     */
    upsert<T extends CalendarUpsertArgs>(args: SelectSubset<T, CalendarUpsertArgs<ExtArgs>>): Prisma__CalendarClient<$Result.GetResult<Prisma.$CalendarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarCountArgs} args - Arguments to filter Calendars to count.
     * @example
     * // Count the number of Calendars
     * const count = await prisma.calendar.count({
     *   where: {
     *     // ... the filter for the Calendars we want to count
     *   }
     * })
    **/
    count<T extends CalendarCountArgs>(
      args?: Subset<T, CalendarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarAggregateArgs>(args: Subset<T, CalendarAggregateArgs>): Prisma.PrismaPromise<GetCalendarAggregateType<T>>

    /**
     * Group by Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarGroupByArgs['orderBy'] }
        : { orderBy?: CalendarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Calendar model
   */
  readonly fields: CalendarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Calendar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lawyer<T extends Calendar$lawyerArgs<ExtArgs> = {}>(args?: Subset<T, Calendar$lawyerArgs<ExtArgs>>): Prisma__LawyerClient<$Result.GetResult<Prisma.$LawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Calendar model
   */
  interface CalendarFieldRefs {
    readonly id: FieldRef<"Calendar", 'String'>
    readonly userId: FieldRef<"Calendar", 'String'>
    readonly client: FieldRef<"Calendar", 'String'>
    readonly moment: FieldRef<"Calendar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Calendar findUnique
   */
  export type CalendarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar findUniqueOrThrow
   */
  export type CalendarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar findFirst
   */
  export type CalendarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calendars.
     */
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Calendar findFirstOrThrow
   */
  export type CalendarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendar to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calendars.
     */
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Calendar findMany
   */
  export type CalendarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter, which Calendars to fetch.
     */
    where?: CalendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calendars to fetch.
     */
    orderBy?: CalendarOrderByWithRelationInput | CalendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Calendars.
     */
    cursor?: CalendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calendars.
     */
    skip?: number
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * Calendar create
   */
  export type CalendarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * The data needed to create a Calendar.
     */
    data: XOR<CalendarCreateInput, CalendarUncheckedCreateInput>
  }

  /**
   * Calendar createMany
   */
  export type CalendarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Calendars.
     */
    data: CalendarCreateManyInput | CalendarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Calendar update
   */
  export type CalendarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * The data needed to update a Calendar.
     */
    data: XOR<CalendarUpdateInput, CalendarUncheckedUpdateInput>
    /**
     * Choose, which Calendar to update.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar updateMany
   */
  export type CalendarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Calendars.
     */
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyInput>
    /**
     * Filter which Calendars to update
     */
    where?: CalendarWhereInput
    /**
     * Limit how many Calendars to update.
     */
    limit?: number
  }

  /**
   * Calendar upsert
   */
  export type CalendarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * The filter to search for the Calendar to update in case it exists.
     */
    where: CalendarWhereUniqueInput
    /**
     * In case the Calendar found by the `where` argument doesn't exist, create a new Calendar with this data.
     */
    create: XOR<CalendarCreateInput, CalendarUncheckedCreateInput>
    /**
     * In case the Calendar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarUpdateInput, CalendarUncheckedUpdateInput>
  }

  /**
   * Calendar delete
   */
  export type CalendarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
    /**
     * Filter which Calendar to delete.
     */
    where: CalendarWhereUniqueInput
  }

  /**
   * Calendar deleteMany
   */
  export type CalendarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Calendars to delete
     */
    where?: CalendarWhereInput
    /**
     * Limit how many Calendars to delete.
     */
    limit?: number
  }

  /**
   * Calendar.lawyer
   */
  export type Calendar$lawyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lawyer
     */
    select?: LawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lawyer
     */
    omit?: LawyerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LawyerInclude<ExtArgs> | null
    where?: LawyerWhereInput
  }

  /**
   * Calendar without action
   */
  export type CalendarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Calendar
     */
    select?: CalendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Calendar
     */
    omit?: CalendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
    refresh_token_expires_in: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
    refresh_token_expires_in: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    refresh_token_expires_in: number | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    refresh_token_expires_in: number | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    refresh_token_expires_in: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
    refresh_token_expires_in?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
    refresh_token_expires_in?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    refresh_token_expires_in?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    refresh_token_expires_in?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    refresh_token_expires_in?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    refresh_token_expires_in: number | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    refresh_token_expires_in?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>



  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    refresh_token_expires_in?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "refresh_token_expires_in", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      refresh_token_expires_in: number | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly refresh_token_expires_in: FieldRef<"Account", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>



  export type PostSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'Int'>
    readonly name: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
    readonly createdById: FieldRef<"Post", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>



  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    emailVerified: 'emailVerified',
    image: 'image'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    profession: 'profession',
    age: 'age',
    gender: 'gender',
    localisation: 'localisation'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const LawyerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    age: 'age',
    localisation: 'localisation',
    budget: 'budget',
    gender: 'gender',
    specialité: 'specialité',
    Star: 'Star'
  };

  export type LawyerScalarFieldEnum = (typeof LawyerScalarFieldEnum)[keyof typeof LawyerScalarFieldEnum]


  export const ConseilJuridiqueScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    desc: 'desc'
  };

  export type ConseilJuridiqueScalarFieldEnum = (typeof ConseilJuridiqueScalarFieldEnum)[keyof typeof ConseilJuridiqueScalarFieldEnum]


  export const RedactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    desc: 'desc'
  };

  export type RedactionScalarFieldEnum = (typeof RedactionScalarFieldEnum)[keyof typeof RedactionScalarFieldEnum]


  export const ResolutionLitigeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    desc: 'desc'
  };

  export type ResolutionLitigeScalarFieldEnum = (typeof ResolutionLitigeScalarFieldEnum)[keyof typeof ResolutionLitigeScalarFieldEnum]


  export const ServiceParDomaineScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    desc: 'desc'
  };

  export type ServiceParDomaineScalarFieldEnum = (typeof ServiceParDomaineScalarFieldEnum)[keyof typeof ServiceParDomaineScalarFieldEnum]


  export const PreventifsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    desc: 'desc'
  };

  export type PreventifsScalarFieldEnum = (typeof PreventifsScalarFieldEnum)[keyof typeof PreventifsScalarFieldEnum]


  export const ValeurAjouterScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    desc: 'desc'
  };

  export type ValeurAjouterScalarFieldEnum = (typeof ValeurAjouterScalarFieldEnum)[keyof typeof ValeurAjouterScalarFieldEnum]


  export const FriendsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    nbrDeContrat: 'nbrDeContrat',
    key: 'key'
  };

  export type FriendsScalarFieldEnum = (typeof FriendsScalarFieldEnum)[keyof typeof FriendsScalarFieldEnum]


  export const FriendLawScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    nbrDeContrat: 'nbrDeContrat',
    key: 'key'
  };

  export type FriendLawScalarFieldEnum = (typeof FriendLawScalarFieldEnum)[keyof typeof FriendLawScalarFieldEnum]


  export const ContratScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    date: 'date',
    content: 'content'
  };

  export type ContratScalarFieldEnum = (typeof ContratScalarFieldEnum)[keyof typeof ContratScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    TimeToReceive: 'TimeToReceive',
    vue: 'vue',
    type: 'type',
    key: 'key'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ClientNotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    TimeToReceive: 'TimeToReceive',
    vue: 'vue',
    type: 'type',
    key: 'key'
  };

  export type ClientNotificationScalarFieldEnum = (typeof ClientNotificationScalarFieldEnum)[keyof typeof ClientNotificationScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    contenu: 'contenu',
    date: 'date',
    key: 'key'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ClientContactScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    contenu: 'contenu',
    date: 'date',
    key: 'key'
  };

  export type ClientContactScalarFieldEnum = (typeof ClientContactScalarFieldEnum)[keyof typeof ClientContactScalarFieldEnum]


  export const DiplomeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    ecole: 'ecole',
    anne: 'anne',
    nom: 'nom'
  };

  export type DiplomeScalarFieldEnum = (typeof DiplomeScalarFieldEnum)[keyof typeof DiplomeScalarFieldEnum]


  export const ExperienceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    poste: 'poste',
    durant: 'durant'
  };

  export type ExperienceScalarFieldEnum = (typeof ExperienceScalarFieldEnum)[keyof typeof ExperienceScalarFieldEnum]


  export const CalendarScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    client: 'client',
    moment: 'moment'
  };

  export type CalendarScalarFieldEnum = (typeof CalendarScalarFieldEnum)[keyof typeof CalendarScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    refresh_token_expires_in: 'refresh_token_expires_in'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    image: 'image'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const ClientOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    profession: 'profession',
    gender: 'gender',
    localisation: 'localisation'
  };

  export type ClientOrderByRelevanceFieldEnum = (typeof ClientOrderByRelevanceFieldEnum)[keyof typeof ClientOrderByRelevanceFieldEnum]


  export const LawyerOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    localisation: 'localisation',
    budget: 'budget',
    gender: 'gender',
    specialité: 'specialité'
  };

  export type LawyerOrderByRelevanceFieldEnum = (typeof LawyerOrderByRelevanceFieldEnum)[keyof typeof LawyerOrderByRelevanceFieldEnum]


  export const ConseilJuridiqueOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    desc: 'desc'
  };

  export type ConseilJuridiqueOrderByRelevanceFieldEnum = (typeof ConseilJuridiqueOrderByRelevanceFieldEnum)[keyof typeof ConseilJuridiqueOrderByRelevanceFieldEnum]


  export const RedactionOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    desc: 'desc'
  };

  export type RedactionOrderByRelevanceFieldEnum = (typeof RedactionOrderByRelevanceFieldEnum)[keyof typeof RedactionOrderByRelevanceFieldEnum]


  export const ResolutionLitigeOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    desc: 'desc'
  };

  export type ResolutionLitigeOrderByRelevanceFieldEnum = (typeof ResolutionLitigeOrderByRelevanceFieldEnum)[keyof typeof ResolutionLitigeOrderByRelevanceFieldEnum]


  export const ServiceParDomaineOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    desc: 'desc'
  };

  export type ServiceParDomaineOrderByRelevanceFieldEnum = (typeof ServiceParDomaineOrderByRelevanceFieldEnum)[keyof typeof ServiceParDomaineOrderByRelevanceFieldEnum]


  export const PreventifsOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    desc: 'desc'
  };

  export type PreventifsOrderByRelevanceFieldEnum = (typeof PreventifsOrderByRelevanceFieldEnum)[keyof typeof PreventifsOrderByRelevanceFieldEnum]


  export const ValeurAjouterOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    desc: 'desc'
  };

  export type ValeurAjouterOrderByRelevanceFieldEnum = (typeof ValeurAjouterOrderByRelevanceFieldEnum)[keyof typeof ValeurAjouterOrderByRelevanceFieldEnum]


  export const FriendsOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    nbrDeContrat: 'nbrDeContrat',
    key: 'key'
  };

  export type FriendsOrderByRelevanceFieldEnum = (typeof FriendsOrderByRelevanceFieldEnum)[keyof typeof FriendsOrderByRelevanceFieldEnum]


  export const FriendLawOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    nbrDeContrat: 'nbrDeContrat',
    key: 'key'
  };

  export type FriendLawOrderByRelevanceFieldEnum = (typeof FriendLawOrderByRelevanceFieldEnum)[keyof typeof FriendLawOrderByRelevanceFieldEnum]


  export const ContratOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    content: 'content'
  };

  export type ContratOrderByRelevanceFieldEnum = (typeof ContratOrderByRelevanceFieldEnum)[keyof typeof ContratOrderByRelevanceFieldEnum]


  export const NotificationOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    type: 'type',
    key: 'key'
  };

  export type NotificationOrderByRelevanceFieldEnum = (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]


  export const ClientNotificationOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    content: 'content',
    type: 'type',
    key: 'key'
  };

  export type ClientNotificationOrderByRelevanceFieldEnum = (typeof ClientNotificationOrderByRelevanceFieldEnum)[keyof typeof ClientNotificationOrderByRelevanceFieldEnum]


  export const ContactOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    contenu: 'contenu',
    key: 'key'
  };

  export type ContactOrderByRelevanceFieldEnum = (typeof ContactOrderByRelevanceFieldEnum)[keyof typeof ContactOrderByRelevanceFieldEnum]


  export const ClientContactOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    contenu: 'contenu',
    key: 'key'
  };

  export type ClientContactOrderByRelevanceFieldEnum = (typeof ClientContactOrderByRelevanceFieldEnum)[keyof typeof ClientContactOrderByRelevanceFieldEnum]


  export const DiplomeOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    ecole: 'ecole',
    anne: 'anne',
    nom: 'nom'
  };

  export type DiplomeOrderByRelevanceFieldEnum = (typeof DiplomeOrderByRelevanceFieldEnum)[keyof typeof DiplomeOrderByRelevanceFieldEnum]


  export const ExperienceOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    poste: 'poste',
    durant: 'durant'
  };

  export type ExperienceOrderByRelevanceFieldEnum = (typeof ExperienceOrderByRelevanceFieldEnum)[keyof typeof ExperienceOrderByRelevanceFieldEnum]


  export const CalendarOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    client: 'client'
  };

  export type CalendarOrderByRelevanceFieldEnum = (typeof CalendarOrderByRelevanceFieldEnum)[keyof typeof CalendarOrderByRelevanceFieldEnum]


  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const SessionOrderByRelevanceFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  export const PostOrderByRelevanceFieldEnum: {
    name: 'name',
    createdById: 'createdById'
  };

  export type PostOrderByRelevanceFieldEnum = (typeof PostOrderByRelevanceFieldEnum)[keyof typeof PostOrderByRelevanceFieldEnum]


  export const VerificationTokenOrderByRelevanceFieldEnum: {
    identifier: 'identifier',
    token: 'token'
  };

  export type VerificationTokenOrderByRelevanceFieldEnum = (typeof VerificationTokenOrderByRelevanceFieldEnum)[keyof typeof VerificationTokenOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    client?: ClientListRelationFilter
    lawyer?: LawyerListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    posts?: PostListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    client?: ClientOrderByRelationAggregateInput
    lawyer?: LawyerOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    client?: ClientListRelationFilter
    lawyer?: LawyerListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    posts?: PostListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    userId?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    profession?: StringFilter<"Client"> | string
    age?: IntFilter<"Client"> | number
    gender?: StringFilter<"Client"> | string
    localisation?: StringFilter<"Client"> | string
    friend?: FriendsListRelationFilter
    notification?: ClientNotificationListRelationFilter
    client?: ClientContactListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    profession?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    localisation?: SortOrder
    friend?: FriendsOrderByRelationAggregateInput
    notification?: ClientNotificationOrderByRelationAggregateInput
    client?: ClientContactOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    _relevance?: ClientOrderByRelevanceInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    userId?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    profession?: StringFilter<"Client"> | string
    age?: IntFilter<"Client"> | number
    gender?: StringFilter<"Client"> | string
    localisation?: StringFilter<"Client"> | string
    friend?: FriendsListRelationFilter
    notification?: ClientNotificationListRelationFilter
    client?: ClientContactListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    profession?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    localisation?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    userId?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    profession?: StringWithAggregatesFilter<"Client"> | string
    age?: IntWithAggregatesFilter<"Client"> | number
    gender?: StringWithAggregatesFilter<"Client"> | string
    localisation?: StringWithAggregatesFilter<"Client"> | string
  }

  export type LawyerWhereInput = {
    AND?: LawyerWhereInput | LawyerWhereInput[]
    OR?: LawyerWhereInput[]
    NOT?: LawyerWhereInput | LawyerWhereInput[]
    id?: StringFilter<"Lawyer"> | string
    userId?: StringFilter<"Lawyer"> | string
    name?: StringNullableFilter<"Lawyer"> | string | null
    age?: IntNullableFilter<"Lawyer"> | number | null
    localisation?: StringNullableFilter<"Lawyer"> | string | null
    budget?: StringNullableFilter<"Lawyer"> | string | null
    gender?: StringNullableFilter<"Lawyer"> | string | null
    specialité?: StringNullableFilter<"Lawyer"> | string | null
    Star?: IntNullableFilter<"Lawyer"> | number | null
    diplome?: DiplomeListRelationFilter
    experience?: ExperienceListRelationFilter
    Notification?: NotificationListRelationFilter
    contrat?: ContratListRelationFilter
    calendar?: CalendarListRelationFilter
    friendLaw?: FriendLawListRelationFilter
    contact?: ContactListRelationFilter
    conseil?: ConseilJuridiqueListRelationFilter
    redaction?: RedactionListRelationFilter
    resolution?: ResolutionLitigeListRelationFilter
    services?: ServiceParDomaineListRelationFilter
    preventifs?: PreventifsListRelationFilter
    valuer?: ValeurAjouterListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LawyerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    localisation?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    specialité?: SortOrderInput | SortOrder
    Star?: SortOrderInput | SortOrder
    diplome?: DiplomeOrderByRelationAggregateInput
    experience?: ExperienceOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    contrat?: ContratOrderByRelationAggregateInput
    calendar?: CalendarOrderByRelationAggregateInput
    friendLaw?: FriendLawOrderByRelationAggregateInput
    contact?: ContactOrderByRelationAggregateInput
    conseil?: ConseilJuridiqueOrderByRelationAggregateInput
    redaction?: RedactionOrderByRelationAggregateInput
    resolution?: ResolutionLitigeOrderByRelationAggregateInput
    services?: ServiceParDomaineOrderByRelationAggregateInput
    preventifs?: PreventifsOrderByRelationAggregateInput
    valuer?: ValeurAjouterOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    _relevance?: LawyerOrderByRelevanceInput
  }

  export type LawyerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LawyerWhereInput | LawyerWhereInput[]
    OR?: LawyerWhereInput[]
    NOT?: LawyerWhereInput | LawyerWhereInput[]
    userId?: StringFilter<"Lawyer"> | string
    name?: StringNullableFilter<"Lawyer"> | string | null
    age?: IntNullableFilter<"Lawyer"> | number | null
    localisation?: StringNullableFilter<"Lawyer"> | string | null
    budget?: StringNullableFilter<"Lawyer"> | string | null
    gender?: StringNullableFilter<"Lawyer"> | string | null
    specialité?: StringNullableFilter<"Lawyer"> | string | null
    Star?: IntNullableFilter<"Lawyer"> | number | null
    diplome?: DiplomeListRelationFilter
    experience?: ExperienceListRelationFilter
    Notification?: NotificationListRelationFilter
    contrat?: ContratListRelationFilter
    calendar?: CalendarListRelationFilter
    friendLaw?: FriendLawListRelationFilter
    contact?: ContactListRelationFilter
    conseil?: ConseilJuridiqueListRelationFilter
    redaction?: RedactionListRelationFilter
    resolution?: ResolutionLitigeListRelationFilter
    services?: ServiceParDomaineListRelationFilter
    preventifs?: PreventifsListRelationFilter
    valuer?: ValeurAjouterListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LawyerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    localisation?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    specialité?: SortOrderInput | SortOrder
    Star?: SortOrderInput | SortOrder
    _count?: LawyerCountOrderByAggregateInput
    _avg?: LawyerAvgOrderByAggregateInput
    _max?: LawyerMaxOrderByAggregateInput
    _min?: LawyerMinOrderByAggregateInput
    _sum?: LawyerSumOrderByAggregateInput
  }

  export type LawyerScalarWhereWithAggregatesInput = {
    AND?: LawyerScalarWhereWithAggregatesInput | LawyerScalarWhereWithAggregatesInput[]
    OR?: LawyerScalarWhereWithAggregatesInput[]
    NOT?: LawyerScalarWhereWithAggregatesInput | LawyerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lawyer"> | string
    userId?: StringWithAggregatesFilter<"Lawyer"> | string
    name?: StringNullableWithAggregatesFilter<"Lawyer"> | string | null
    age?: IntNullableWithAggregatesFilter<"Lawyer"> | number | null
    localisation?: StringNullableWithAggregatesFilter<"Lawyer"> | string | null
    budget?: StringNullableWithAggregatesFilter<"Lawyer"> | string | null
    gender?: StringNullableWithAggregatesFilter<"Lawyer"> | string | null
    specialité?: StringNullableWithAggregatesFilter<"Lawyer"> | string | null
    Star?: IntNullableWithAggregatesFilter<"Lawyer"> | number | null
  }

  export type ConseilJuridiqueWhereInput = {
    AND?: ConseilJuridiqueWhereInput | ConseilJuridiqueWhereInput[]
    OR?: ConseilJuridiqueWhereInput[]
    NOT?: ConseilJuridiqueWhereInput | ConseilJuridiqueWhereInput[]
    id?: StringFilter<"ConseilJuridique"> | string
    userId?: StringFilter<"ConseilJuridique"> | string
    title?: StringFilter<"ConseilJuridique"> | string
    content?: StringFilter<"ConseilJuridique"> | string
    desc?: StringFilter<"ConseilJuridique"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }

  export type ConseilJuridiqueOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
    lawyer?: LawyerOrderByWithRelationInput
    _relevance?: ConseilJuridiqueOrderByRelevanceInput
  }

  export type ConseilJuridiqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConseilJuridiqueWhereInput | ConseilJuridiqueWhereInput[]
    OR?: ConseilJuridiqueWhereInput[]
    NOT?: ConseilJuridiqueWhereInput | ConseilJuridiqueWhereInput[]
    userId?: StringFilter<"ConseilJuridique"> | string
    title?: StringFilter<"ConseilJuridique"> | string
    content?: StringFilter<"ConseilJuridique"> | string
    desc?: StringFilter<"ConseilJuridique"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }, "id">

  export type ConseilJuridiqueOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
    _count?: ConseilJuridiqueCountOrderByAggregateInput
    _max?: ConseilJuridiqueMaxOrderByAggregateInput
    _min?: ConseilJuridiqueMinOrderByAggregateInput
  }

  export type ConseilJuridiqueScalarWhereWithAggregatesInput = {
    AND?: ConseilJuridiqueScalarWhereWithAggregatesInput | ConseilJuridiqueScalarWhereWithAggregatesInput[]
    OR?: ConseilJuridiqueScalarWhereWithAggregatesInput[]
    NOT?: ConseilJuridiqueScalarWhereWithAggregatesInput | ConseilJuridiqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConseilJuridique"> | string
    userId?: StringWithAggregatesFilter<"ConseilJuridique"> | string
    title?: StringWithAggregatesFilter<"ConseilJuridique"> | string
    content?: StringWithAggregatesFilter<"ConseilJuridique"> | string
    desc?: StringWithAggregatesFilter<"ConseilJuridique"> | string
  }

  export type RedactionWhereInput = {
    AND?: RedactionWhereInput | RedactionWhereInput[]
    OR?: RedactionWhereInput[]
    NOT?: RedactionWhereInput | RedactionWhereInput[]
    id?: StringFilter<"Redaction"> | string
    userId?: StringFilter<"Redaction"> | string
    title?: StringFilter<"Redaction"> | string
    content?: StringFilter<"Redaction"> | string
    desc?: StringFilter<"Redaction"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }

  export type RedactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
    lawyer?: LawyerOrderByWithRelationInput
    _relevance?: RedactionOrderByRelevanceInput
  }

  export type RedactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RedactionWhereInput | RedactionWhereInput[]
    OR?: RedactionWhereInput[]
    NOT?: RedactionWhereInput | RedactionWhereInput[]
    userId?: StringFilter<"Redaction"> | string
    title?: StringFilter<"Redaction"> | string
    content?: StringFilter<"Redaction"> | string
    desc?: StringFilter<"Redaction"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }, "id">

  export type RedactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
    _count?: RedactionCountOrderByAggregateInput
    _max?: RedactionMaxOrderByAggregateInput
    _min?: RedactionMinOrderByAggregateInput
  }

  export type RedactionScalarWhereWithAggregatesInput = {
    AND?: RedactionScalarWhereWithAggregatesInput | RedactionScalarWhereWithAggregatesInput[]
    OR?: RedactionScalarWhereWithAggregatesInput[]
    NOT?: RedactionScalarWhereWithAggregatesInput | RedactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redaction"> | string
    userId?: StringWithAggregatesFilter<"Redaction"> | string
    title?: StringWithAggregatesFilter<"Redaction"> | string
    content?: StringWithAggregatesFilter<"Redaction"> | string
    desc?: StringWithAggregatesFilter<"Redaction"> | string
  }

  export type ResolutionLitigeWhereInput = {
    AND?: ResolutionLitigeWhereInput | ResolutionLitigeWhereInput[]
    OR?: ResolutionLitigeWhereInput[]
    NOT?: ResolutionLitigeWhereInput | ResolutionLitigeWhereInput[]
    id?: StringFilter<"ResolutionLitige"> | string
    userId?: StringFilter<"ResolutionLitige"> | string
    title?: StringFilter<"ResolutionLitige"> | string
    content?: StringFilter<"ResolutionLitige"> | string
    desc?: StringFilter<"ResolutionLitige"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }

  export type ResolutionLitigeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
    lawyer?: LawyerOrderByWithRelationInput
    _relevance?: ResolutionLitigeOrderByRelevanceInput
  }

  export type ResolutionLitigeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResolutionLitigeWhereInput | ResolutionLitigeWhereInput[]
    OR?: ResolutionLitigeWhereInput[]
    NOT?: ResolutionLitigeWhereInput | ResolutionLitigeWhereInput[]
    userId?: StringFilter<"ResolutionLitige"> | string
    title?: StringFilter<"ResolutionLitige"> | string
    content?: StringFilter<"ResolutionLitige"> | string
    desc?: StringFilter<"ResolutionLitige"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }, "id">

  export type ResolutionLitigeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
    _count?: ResolutionLitigeCountOrderByAggregateInput
    _max?: ResolutionLitigeMaxOrderByAggregateInput
    _min?: ResolutionLitigeMinOrderByAggregateInput
  }

  export type ResolutionLitigeScalarWhereWithAggregatesInput = {
    AND?: ResolutionLitigeScalarWhereWithAggregatesInput | ResolutionLitigeScalarWhereWithAggregatesInput[]
    OR?: ResolutionLitigeScalarWhereWithAggregatesInput[]
    NOT?: ResolutionLitigeScalarWhereWithAggregatesInput | ResolutionLitigeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResolutionLitige"> | string
    userId?: StringWithAggregatesFilter<"ResolutionLitige"> | string
    title?: StringWithAggregatesFilter<"ResolutionLitige"> | string
    content?: StringWithAggregatesFilter<"ResolutionLitige"> | string
    desc?: StringWithAggregatesFilter<"ResolutionLitige"> | string
  }

  export type ServiceParDomaineWhereInput = {
    AND?: ServiceParDomaineWhereInput | ServiceParDomaineWhereInput[]
    OR?: ServiceParDomaineWhereInput[]
    NOT?: ServiceParDomaineWhereInput | ServiceParDomaineWhereInput[]
    id?: StringFilter<"ServiceParDomaine"> | string
    userId?: StringFilter<"ServiceParDomaine"> | string
    title?: StringFilter<"ServiceParDomaine"> | string
    content?: StringFilter<"ServiceParDomaine"> | string
    desc?: StringFilter<"ServiceParDomaine"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }

  export type ServiceParDomaineOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
    lawyer?: LawyerOrderByWithRelationInput
    _relevance?: ServiceParDomaineOrderByRelevanceInput
  }

  export type ServiceParDomaineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceParDomaineWhereInput | ServiceParDomaineWhereInput[]
    OR?: ServiceParDomaineWhereInput[]
    NOT?: ServiceParDomaineWhereInput | ServiceParDomaineWhereInput[]
    userId?: StringFilter<"ServiceParDomaine"> | string
    title?: StringFilter<"ServiceParDomaine"> | string
    content?: StringFilter<"ServiceParDomaine"> | string
    desc?: StringFilter<"ServiceParDomaine"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }, "id">

  export type ServiceParDomaineOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
    _count?: ServiceParDomaineCountOrderByAggregateInput
    _max?: ServiceParDomaineMaxOrderByAggregateInput
    _min?: ServiceParDomaineMinOrderByAggregateInput
  }

  export type ServiceParDomaineScalarWhereWithAggregatesInput = {
    AND?: ServiceParDomaineScalarWhereWithAggregatesInput | ServiceParDomaineScalarWhereWithAggregatesInput[]
    OR?: ServiceParDomaineScalarWhereWithAggregatesInput[]
    NOT?: ServiceParDomaineScalarWhereWithAggregatesInput | ServiceParDomaineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceParDomaine"> | string
    userId?: StringWithAggregatesFilter<"ServiceParDomaine"> | string
    title?: StringWithAggregatesFilter<"ServiceParDomaine"> | string
    content?: StringWithAggregatesFilter<"ServiceParDomaine"> | string
    desc?: StringWithAggregatesFilter<"ServiceParDomaine"> | string
  }

  export type PreventifsWhereInput = {
    AND?: PreventifsWhereInput | PreventifsWhereInput[]
    OR?: PreventifsWhereInput[]
    NOT?: PreventifsWhereInput | PreventifsWhereInput[]
    id?: StringFilter<"Preventifs"> | string
    userId?: StringFilter<"Preventifs"> | string
    title?: StringFilter<"Preventifs"> | string
    content?: StringFilter<"Preventifs"> | string
    desc?: StringFilter<"Preventifs"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }

  export type PreventifsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
    lawyer?: LawyerOrderByWithRelationInput
    _relevance?: PreventifsOrderByRelevanceInput
  }

  export type PreventifsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PreventifsWhereInput | PreventifsWhereInput[]
    OR?: PreventifsWhereInput[]
    NOT?: PreventifsWhereInput | PreventifsWhereInput[]
    userId?: StringFilter<"Preventifs"> | string
    title?: StringFilter<"Preventifs"> | string
    content?: StringFilter<"Preventifs"> | string
    desc?: StringFilter<"Preventifs"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }, "id">

  export type PreventifsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
    _count?: PreventifsCountOrderByAggregateInput
    _max?: PreventifsMaxOrderByAggregateInput
    _min?: PreventifsMinOrderByAggregateInput
  }

  export type PreventifsScalarWhereWithAggregatesInput = {
    AND?: PreventifsScalarWhereWithAggregatesInput | PreventifsScalarWhereWithAggregatesInput[]
    OR?: PreventifsScalarWhereWithAggregatesInput[]
    NOT?: PreventifsScalarWhereWithAggregatesInput | PreventifsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Preventifs"> | string
    userId?: StringWithAggregatesFilter<"Preventifs"> | string
    title?: StringWithAggregatesFilter<"Preventifs"> | string
    content?: StringWithAggregatesFilter<"Preventifs"> | string
    desc?: StringWithAggregatesFilter<"Preventifs"> | string
  }

  export type ValeurAjouterWhereInput = {
    AND?: ValeurAjouterWhereInput | ValeurAjouterWhereInput[]
    OR?: ValeurAjouterWhereInput[]
    NOT?: ValeurAjouterWhereInput | ValeurAjouterWhereInput[]
    id?: StringFilter<"ValeurAjouter"> | string
    userId?: StringFilter<"ValeurAjouter"> | string
    title?: StringFilter<"ValeurAjouter"> | string
    content?: StringFilter<"ValeurAjouter"> | string
    desc?: StringFilter<"ValeurAjouter"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }

  export type ValeurAjouterOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
    lawyer?: LawyerOrderByWithRelationInput
    _relevance?: ValeurAjouterOrderByRelevanceInput
  }

  export type ValeurAjouterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ValeurAjouterWhereInput | ValeurAjouterWhereInput[]
    OR?: ValeurAjouterWhereInput[]
    NOT?: ValeurAjouterWhereInput | ValeurAjouterWhereInput[]
    userId?: StringFilter<"ValeurAjouter"> | string
    title?: StringFilter<"ValeurAjouter"> | string
    content?: StringFilter<"ValeurAjouter"> | string
    desc?: StringFilter<"ValeurAjouter"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }, "id">

  export type ValeurAjouterOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
    _count?: ValeurAjouterCountOrderByAggregateInput
    _max?: ValeurAjouterMaxOrderByAggregateInput
    _min?: ValeurAjouterMinOrderByAggregateInput
  }

  export type ValeurAjouterScalarWhereWithAggregatesInput = {
    AND?: ValeurAjouterScalarWhereWithAggregatesInput | ValeurAjouterScalarWhereWithAggregatesInput[]
    OR?: ValeurAjouterScalarWhereWithAggregatesInput[]
    NOT?: ValeurAjouterScalarWhereWithAggregatesInput | ValeurAjouterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ValeurAjouter"> | string
    userId?: StringWithAggregatesFilter<"ValeurAjouter"> | string
    title?: StringWithAggregatesFilter<"ValeurAjouter"> | string
    content?: StringWithAggregatesFilter<"ValeurAjouter"> | string
    desc?: StringWithAggregatesFilter<"ValeurAjouter"> | string
  }

  export type FriendsWhereInput = {
    AND?: FriendsWhereInput | FriendsWhereInput[]
    OR?: FriendsWhereInput[]
    NOT?: FriendsWhereInput | FriendsWhereInput[]
    id?: StringFilter<"Friends"> | string
    userId?: StringFilter<"Friends"> | string
    name?: StringFilter<"Friends"> | string
    nbrDeContrat?: StringFilter<"Friends"> | string
    key?: StringFilter<"Friends"> | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type FriendsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    nbrDeContrat?: SortOrder
    key?: SortOrder
    client?: ClientOrderByWithRelationInput
    _relevance?: FriendsOrderByRelevanceInput
  }

  export type FriendsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FriendsWhereInput | FriendsWhereInput[]
    OR?: FriendsWhereInput[]
    NOT?: FriendsWhereInput | FriendsWhereInput[]
    userId?: StringFilter<"Friends"> | string
    name?: StringFilter<"Friends"> | string
    nbrDeContrat?: StringFilter<"Friends"> | string
    key?: StringFilter<"Friends"> | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type FriendsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    nbrDeContrat?: SortOrder
    key?: SortOrder
    _count?: FriendsCountOrderByAggregateInput
    _max?: FriendsMaxOrderByAggregateInput
    _min?: FriendsMinOrderByAggregateInput
  }

  export type FriendsScalarWhereWithAggregatesInput = {
    AND?: FriendsScalarWhereWithAggregatesInput | FriendsScalarWhereWithAggregatesInput[]
    OR?: FriendsScalarWhereWithAggregatesInput[]
    NOT?: FriendsScalarWhereWithAggregatesInput | FriendsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Friends"> | string
    userId?: StringWithAggregatesFilter<"Friends"> | string
    name?: StringWithAggregatesFilter<"Friends"> | string
    nbrDeContrat?: StringWithAggregatesFilter<"Friends"> | string
    key?: StringWithAggregatesFilter<"Friends"> | string
  }

  export type FriendLawWhereInput = {
    AND?: FriendLawWhereInput | FriendLawWhereInput[]
    OR?: FriendLawWhereInput[]
    NOT?: FriendLawWhereInput | FriendLawWhereInput[]
    id?: StringFilter<"FriendLaw"> | string
    userId?: StringFilter<"FriendLaw"> | string
    name?: StringFilter<"FriendLaw"> | string
    nbrDeContrat?: StringFilter<"FriendLaw"> | string
    key?: StringFilter<"FriendLaw"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }

  export type FriendLawOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    nbrDeContrat?: SortOrder
    key?: SortOrder
    lawyer?: LawyerOrderByWithRelationInput
    _relevance?: FriendLawOrderByRelevanceInput
  }

  export type FriendLawWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FriendLawWhereInput | FriendLawWhereInput[]
    OR?: FriendLawWhereInput[]
    NOT?: FriendLawWhereInput | FriendLawWhereInput[]
    userId?: StringFilter<"FriendLaw"> | string
    name?: StringFilter<"FriendLaw"> | string
    nbrDeContrat?: StringFilter<"FriendLaw"> | string
    key?: StringFilter<"FriendLaw"> | string
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }, "id">

  export type FriendLawOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    nbrDeContrat?: SortOrder
    key?: SortOrder
    _count?: FriendLawCountOrderByAggregateInput
    _max?: FriendLawMaxOrderByAggregateInput
    _min?: FriendLawMinOrderByAggregateInput
  }

  export type FriendLawScalarWhereWithAggregatesInput = {
    AND?: FriendLawScalarWhereWithAggregatesInput | FriendLawScalarWhereWithAggregatesInput[]
    OR?: FriendLawScalarWhereWithAggregatesInput[]
    NOT?: FriendLawScalarWhereWithAggregatesInput | FriendLawScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FriendLaw"> | string
    userId?: StringWithAggregatesFilter<"FriendLaw"> | string
    name?: StringWithAggregatesFilter<"FriendLaw"> | string
    nbrDeContrat?: StringWithAggregatesFilter<"FriendLaw"> | string
    key?: StringWithAggregatesFilter<"FriendLaw"> | string
  }

  export type ContratWhereInput = {
    AND?: ContratWhereInput | ContratWhereInput[]
    OR?: ContratWhereInput[]
    NOT?: ContratWhereInput | ContratWhereInput[]
    id?: StringFilter<"Contrat"> | string
    userId?: StringFilter<"Contrat"> | string
    type?: StringNullableFilter<"Contrat"> | string | null
    date?: DateTimeNullableFilter<"Contrat"> | Date | string | null
    content?: StringNullableFilter<"Contrat"> | string | null
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }

  export type ContratOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    lawyer?: LawyerOrderByWithRelationInput
    _relevance?: ContratOrderByRelevanceInput
  }

  export type ContratWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContratWhereInput | ContratWhereInput[]
    OR?: ContratWhereInput[]
    NOT?: ContratWhereInput | ContratWhereInput[]
    userId?: StringFilter<"Contrat"> | string
    type?: StringNullableFilter<"Contrat"> | string | null
    date?: DateTimeNullableFilter<"Contrat"> | Date | string | null
    content?: StringNullableFilter<"Contrat"> | string | null
    lawyer?: XOR<LawyerScalarRelationFilter, LawyerWhereInput>
  }, "id">

  export type ContratOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    _count?: ContratCountOrderByAggregateInput
    _max?: ContratMaxOrderByAggregateInput
    _min?: ContratMinOrderByAggregateInput
  }

  export type ContratScalarWhereWithAggregatesInput = {
    AND?: ContratScalarWhereWithAggregatesInput | ContratScalarWhereWithAggregatesInput[]
    OR?: ContratScalarWhereWithAggregatesInput[]
    NOT?: ContratScalarWhereWithAggregatesInput | ContratScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contrat"> | string
    userId?: StringWithAggregatesFilter<"Contrat"> | string
    type?: StringNullableWithAggregatesFilter<"Contrat"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"Contrat"> | Date | string | null
    content?: StringNullableWithAggregatesFilter<"Contrat"> | string | null
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    content?: StringNullableFilter<"Notification"> | string | null
    TimeToReceive?: DateTimeNullableFilter<"Notification"> | Date | string | null
    vue?: BoolNullableFilter<"Notification"> | boolean | null
    type?: StringFilter<"Notification"> | string
    key?: StringNullableFilter<"Notification"> | string | null
    lawyer?: XOR<LawyerNullableScalarRelationFilter, LawyerWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrderInput | SortOrder
    TimeToReceive?: SortOrderInput | SortOrder
    vue?: SortOrderInput | SortOrder
    type?: SortOrder
    key?: SortOrderInput | SortOrder
    lawyer?: LawyerOrderByWithRelationInput
    _relevance?: NotificationOrderByRelevanceInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    content?: StringNullableFilter<"Notification"> | string | null
    TimeToReceive?: DateTimeNullableFilter<"Notification"> | Date | string | null
    vue?: BoolNullableFilter<"Notification"> | boolean | null
    type?: StringFilter<"Notification"> | string
    key?: StringNullableFilter<"Notification"> | string | null
    lawyer?: XOR<LawyerNullableScalarRelationFilter, LawyerWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrderInput | SortOrder
    TimeToReceive?: SortOrderInput | SortOrder
    vue?: SortOrderInput | SortOrder
    type?: SortOrder
    key?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    TimeToReceive?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    vue?: BoolNullableWithAggregatesFilter<"Notification"> | boolean | null
    type?: StringWithAggregatesFilter<"Notification"> | string
    key?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type ClientNotificationWhereInput = {
    AND?: ClientNotificationWhereInput | ClientNotificationWhereInput[]
    OR?: ClientNotificationWhereInput[]
    NOT?: ClientNotificationWhereInput | ClientNotificationWhereInput[]
    id?: StringFilter<"ClientNotification"> | string
    userId?: StringFilter<"ClientNotification"> | string
    content?: StringNullableFilter<"ClientNotification"> | string | null
    TimeToReceive?: DateTimeNullableFilter<"ClientNotification"> | Date | string | null
    vue?: BoolNullableFilter<"ClientNotification"> | boolean | null
    type?: StringFilter<"ClientNotification"> | string
    key?: StringFilter<"ClientNotification"> | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type ClientNotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrderInput | SortOrder
    TimeToReceive?: SortOrderInput | SortOrder
    vue?: SortOrderInput | SortOrder
    type?: SortOrder
    key?: SortOrder
    client?: ClientOrderByWithRelationInput
    _relevance?: ClientNotificationOrderByRelevanceInput
  }

  export type ClientNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientNotificationWhereInput | ClientNotificationWhereInput[]
    OR?: ClientNotificationWhereInput[]
    NOT?: ClientNotificationWhereInput | ClientNotificationWhereInput[]
    userId?: StringFilter<"ClientNotification"> | string
    content?: StringNullableFilter<"ClientNotification"> | string | null
    TimeToReceive?: DateTimeNullableFilter<"ClientNotification"> | Date | string | null
    vue?: BoolNullableFilter<"ClientNotification"> | boolean | null
    type?: StringFilter<"ClientNotification"> | string
    key?: StringFilter<"ClientNotification"> | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type ClientNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrderInput | SortOrder
    TimeToReceive?: SortOrderInput | SortOrder
    vue?: SortOrderInput | SortOrder
    type?: SortOrder
    key?: SortOrder
    _count?: ClientNotificationCountOrderByAggregateInput
    _max?: ClientNotificationMaxOrderByAggregateInput
    _min?: ClientNotificationMinOrderByAggregateInput
  }

  export type ClientNotificationScalarWhereWithAggregatesInput = {
    AND?: ClientNotificationScalarWhereWithAggregatesInput | ClientNotificationScalarWhereWithAggregatesInput[]
    OR?: ClientNotificationScalarWhereWithAggregatesInput[]
    NOT?: ClientNotificationScalarWhereWithAggregatesInput | ClientNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientNotification"> | string
    userId?: StringWithAggregatesFilter<"ClientNotification"> | string
    content?: StringNullableWithAggregatesFilter<"ClientNotification"> | string | null
    TimeToReceive?: DateTimeNullableWithAggregatesFilter<"ClientNotification"> | Date | string | null
    vue?: BoolNullableWithAggregatesFilter<"ClientNotification"> | boolean | null
    type?: StringWithAggregatesFilter<"ClientNotification"> | string
    key?: StringWithAggregatesFilter<"ClientNotification"> | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    userId?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    contenu?: StringFilter<"Contact"> | string
    date?: DateTimeFilter<"Contact"> | Date | string
    key?: StringFilter<"Contact"> | string
    lawyer?: XOR<LawyerNullableScalarRelationFilter, LawyerWhereInput> | null
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contenu?: SortOrder
    date?: SortOrder
    key?: SortOrder
    lawyer?: LawyerOrderByWithRelationInput
    _relevance?: ContactOrderByRelevanceInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    userId?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    contenu?: StringFilter<"Contact"> | string
    date?: DateTimeFilter<"Contact"> | Date | string
    key?: StringFilter<"Contact"> | string
    lawyer?: XOR<LawyerNullableScalarRelationFilter, LawyerWhereInput> | null
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contenu?: SortOrder
    date?: SortOrder
    key?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    userId?: StringWithAggregatesFilter<"Contact"> | string
    name?: StringWithAggregatesFilter<"Contact"> | string
    contenu?: StringWithAggregatesFilter<"Contact"> | string
    date?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    key?: StringWithAggregatesFilter<"Contact"> | string
  }

  export type ClientContactWhereInput = {
    AND?: ClientContactWhereInput | ClientContactWhereInput[]
    OR?: ClientContactWhereInput[]
    NOT?: ClientContactWhereInput | ClientContactWhereInput[]
    id?: StringFilter<"ClientContact"> | string
    userId?: StringFilter<"ClientContact"> | string
    name?: StringFilter<"ClientContact"> | string
    contenu?: StringFilter<"ClientContact"> | string
    date?: DateTimeFilter<"ClientContact"> | Date | string
    key?: StringFilter<"ClientContact"> | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type ClientContactOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contenu?: SortOrder
    date?: SortOrder
    key?: SortOrder
    client?: ClientOrderByWithRelationInput
    _relevance?: ClientContactOrderByRelevanceInput
  }

  export type ClientContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientContactWhereInput | ClientContactWhereInput[]
    OR?: ClientContactWhereInput[]
    NOT?: ClientContactWhereInput | ClientContactWhereInput[]
    userId?: StringFilter<"ClientContact"> | string
    name?: StringFilter<"ClientContact"> | string
    contenu?: StringFilter<"ClientContact"> | string
    date?: DateTimeFilter<"ClientContact"> | Date | string
    key?: StringFilter<"ClientContact"> | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type ClientContactOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contenu?: SortOrder
    date?: SortOrder
    key?: SortOrder
    _count?: ClientContactCountOrderByAggregateInput
    _max?: ClientContactMaxOrderByAggregateInput
    _min?: ClientContactMinOrderByAggregateInput
  }

  export type ClientContactScalarWhereWithAggregatesInput = {
    AND?: ClientContactScalarWhereWithAggregatesInput | ClientContactScalarWhereWithAggregatesInput[]
    OR?: ClientContactScalarWhereWithAggregatesInput[]
    NOT?: ClientContactScalarWhereWithAggregatesInput | ClientContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientContact"> | string
    userId?: StringWithAggregatesFilter<"ClientContact"> | string
    name?: StringWithAggregatesFilter<"ClientContact"> | string
    contenu?: StringWithAggregatesFilter<"ClientContact"> | string
    date?: DateTimeWithAggregatesFilter<"ClientContact"> | Date | string
    key?: StringWithAggregatesFilter<"ClientContact"> | string
  }

  export type DiplomeWhereInput = {
    AND?: DiplomeWhereInput | DiplomeWhereInput[]
    OR?: DiplomeWhereInput[]
    NOT?: DiplomeWhereInput | DiplomeWhereInput[]
    id?: StringFilter<"Diplome"> | string
    userId?: StringFilter<"Diplome"> | string
    ecole?: StringFilter<"Diplome"> | string
    anne?: StringFilter<"Diplome"> | string
    nom?: StringFilter<"Diplome"> | string
    lawyer?: XOR<LawyerNullableScalarRelationFilter, LawyerWhereInput> | null
  }

  export type DiplomeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    ecole?: SortOrder
    anne?: SortOrder
    nom?: SortOrder
    lawyer?: LawyerOrderByWithRelationInput
    _relevance?: DiplomeOrderByRelevanceInput
  }

  export type DiplomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiplomeWhereInput | DiplomeWhereInput[]
    OR?: DiplomeWhereInput[]
    NOT?: DiplomeWhereInput | DiplomeWhereInput[]
    userId?: StringFilter<"Diplome"> | string
    ecole?: StringFilter<"Diplome"> | string
    anne?: StringFilter<"Diplome"> | string
    nom?: StringFilter<"Diplome"> | string
    lawyer?: XOR<LawyerNullableScalarRelationFilter, LawyerWhereInput> | null
  }, "id">

  export type DiplomeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    ecole?: SortOrder
    anne?: SortOrder
    nom?: SortOrder
    _count?: DiplomeCountOrderByAggregateInput
    _max?: DiplomeMaxOrderByAggregateInput
    _min?: DiplomeMinOrderByAggregateInput
  }

  export type DiplomeScalarWhereWithAggregatesInput = {
    AND?: DiplomeScalarWhereWithAggregatesInput | DiplomeScalarWhereWithAggregatesInput[]
    OR?: DiplomeScalarWhereWithAggregatesInput[]
    NOT?: DiplomeScalarWhereWithAggregatesInput | DiplomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Diplome"> | string
    userId?: StringWithAggregatesFilter<"Diplome"> | string
    ecole?: StringWithAggregatesFilter<"Diplome"> | string
    anne?: StringWithAggregatesFilter<"Diplome"> | string
    nom?: StringWithAggregatesFilter<"Diplome"> | string
  }

  export type ExperienceWhereInput = {
    AND?: ExperienceWhereInput | ExperienceWhereInput[]
    OR?: ExperienceWhereInput[]
    NOT?: ExperienceWhereInput | ExperienceWhereInput[]
    id?: StringFilter<"Experience"> | string
    userId?: StringFilter<"Experience"> | string
    poste?: StringFilter<"Experience"> | string
    durant?: StringFilter<"Experience"> | string
    lawyer?: XOR<LawyerNullableScalarRelationFilter, LawyerWhereInput> | null
  }

  export type ExperienceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    poste?: SortOrder
    durant?: SortOrder
    lawyer?: LawyerOrderByWithRelationInput
    _relevance?: ExperienceOrderByRelevanceInput
  }

  export type ExperienceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExperienceWhereInput | ExperienceWhereInput[]
    OR?: ExperienceWhereInput[]
    NOT?: ExperienceWhereInput | ExperienceWhereInput[]
    userId?: StringFilter<"Experience"> | string
    poste?: StringFilter<"Experience"> | string
    durant?: StringFilter<"Experience"> | string
    lawyer?: XOR<LawyerNullableScalarRelationFilter, LawyerWhereInput> | null
  }, "id">

  export type ExperienceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    poste?: SortOrder
    durant?: SortOrder
    _count?: ExperienceCountOrderByAggregateInput
    _max?: ExperienceMaxOrderByAggregateInput
    _min?: ExperienceMinOrderByAggregateInput
  }

  export type ExperienceScalarWhereWithAggregatesInput = {
    AND?: ExperienceScalarWhereWithAggregatesInput | ExperienceScalarWhereWithAggregatesInput[]
    OR?: ExperienceScalarWhereWithAggregatesInput[]
    NOT?: ExperienceScalarWhereWithAggregatesInput | ExperienceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Experience"> | string
    userId?: StringWithAggregatesFilter<"Experience"> | string
    poste?: StringWithAggregatesFilter<"Experience"> | string
    durant?: StringWithAggregatesFilter<"Experience"> | string
  }

  export type CalendarWhereInput = {
    AND?: CalendarWhereInput | CalendarWhereInput[]
    OR?: CalendarWhereInput[]
    NOT?: CalendarWhereInput | CalendarWhereInput[]
    id?: StringFilter<"Calendar"> | string
    userId?: StringFilter<"Calendar"> | string
    client?: StringFilter<"Calendar"> | string
    moment?: DateTimeFilter<"Calendar"> | Date | string
    lawyer?: XOR<LawyerNullableScalarRelationFilter, LawyerWhereInput> | null
  }

  export type CalendarOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    client?: SortOrder
    moment?: SortOrder
    lawyer?: LawyerOrderByWithRelationInput
    _relevance?: CalendarOrderByRelevanceInput
  }

  export type CalendarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CalendarWhereInput | CalendarWhereInput[]
    OR?: CalendarWhereInput[]
    NOT?: CalendarWhereInput | CalendarWhereInput[]
    userId?: StringFilter<"Calendar"> | string
    client?: StringFilter<"Calendar"> | string
    moment?: DateTimeFilter<"Calendar"> | Date | string
    lawyer?: XOR<LawyerNullableScalarRelationFilter, LawyerWhereInput> | null
  }, "id">

  export type CalendarOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    client?: SortOrder
    moment?: SortOrder
    _count?: CalendarCountOrderByAggregateInput
    _max?: CalendarMaxOrderByAggregateInput
    _min?: CalendarMinOrderByAggregateInput
  }

  export type CalendarScalarWhereWithAggregatesInput = {
    AND?: CalendarScalarWhereWithAggregatesInput | CalendarScalarWhereWithAggregatesInput[]
    OR?: CalendarScalarWhereWithAggregatesInput[]
    NOT?: CalendarScalarWhereWithAggregatesInput | CalendarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Calendar"> | string
    userId?: StringWithAggregatesFilter<"Calendar"> | string
    client?: StringWithAggregatesFilter<"Calendar"> | string
    moment?: DateTimeWithAggregatesFilter<"Calendar"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableFilter<"Account"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    refresh_token_expires_in?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableFilter<"Account"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    refresh_token_expires_in?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableWithAggregatesFilter<"Account"> | number | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: IntFilter<"Post"> | number
    name?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    createdById?: StringFilter<"Post"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    _relevance?: PostOrderByRelevanceInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    name?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    createdById?: StringFilter<"Post"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Post"> | number
    name?: StringWithAggregatesFilter<"Post"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    createdById?: StringWithAggregatesFilter<"Post"> | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _relevance?: VerificationTokenOrderByRelevanceInput
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    role: string
    emailVerified?: Date | string | null
    image?: string | null
    client?: ClientCreateNestedManyWithoutUserInput
    lawyer?: LawyerCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    role: string
    emailVerified?: Date | string | null
    image?: string | null
    client?: ClientUncheckedCreateNestedManyWithoutUserInput
    lawyer?: LawyerUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateManyWithoutUserNestedInput
    lawyer?: LawyerUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUncheckedUpdateManyWithoutUserNestedInput
    lawyer?: LawyerUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    role: string
    emailVerified?: Date | string | null
    image?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    profession: string
    age: number
    gender: string
    localisation: string
    friend?: FriendsCreateNestedManyWithoutClientInput
    notification?: ClientNotificationCreateNestedManyWithoutClientInput
    client?: ClientContactCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    profession: string
    age: number
    gender: string
    localisation: string
    friend?: FriendsUncheckedCreateNestedManyWithoutClientInput
    notification?: ClientNotificationUncheckedCreateNestedManyWithoutClientInput
    client?: ClientContactUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
    friend?: FriendsUpdateManyWithoutClientNestedInput
    notification?: ClientNotificationUpdateManyWithoutClientNestedInput
    client?: ClientContactUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
    friend?: FriendsUncheckedUpdateManyWithoutClientNestedInput
    notification?: ClientNotificationUncheckedUpdateManyWithoutClientNestedInput
    client?: ClientContactUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    userId: string
    name: string
    profession: string
    age: number
    gender: string
    localisation: string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
  }

  export type LawyerCreateInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type LawyerCreateManyInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
  }

  export type LawyerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LawyerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ConseilJuridiqueCreateInput = {
    id?: string
    title: string
    content: string
    desc: string
    lawyer: LawyerCreateNestedOneWithoutConseilInput
  }

  export type ConseilJuridiqueUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    content: string
    desc: string
  }

  export type ConseilJuridiqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    lawyer?: LawyerUpdateOneRequiredWithoutConseilNestedInput
  }

  export type ConseilJuridiqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ConseilJuridiqueCreateManyInput = {
    id?: string
    userId: string
    title: string
    content: string
    desc: string
  }

  export type ConseilJuridiqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ConseilJuridiqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type RedactionCreateInput = {
    id?: string
    title: string
    content: string
    desc: string
    lawyer: LawyerCreateNestedOneWithoutRedactionInput
  }

  export type RedactionUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    content: string
    desc: string
  }

  export type RedactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    lawyer?: LawyerUpdateOneRequiredWithoutRedactionNestedInput
  }

  export type RedactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type RedactionCreateManyInput = {
    id?: string
    userId: string
    title: string
    content: string
    desc: string
  }

  export type RedactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type RedactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ResolutionLitigeCreateInput = {
    id?: string
    title: string
    content: string
    desc: string
    lawyer: LawyerCreateNestedOneWithoutResolutionInput
  }

  export type ResolutionLitigeUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    content: string
    desc: string
  }

  export type ResolutionLitigeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    lawyer?: LawyerUpdateOneRequiredWithoutResolutionNestedInput
  }

  export type ResolutionLitigeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ResolutionLitigeCreateManyInput = {
    id?: string
    userId: string
    title: string
    content: string
    desc: string
  }

  export type ResolutionLitigeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ResolutionLitigeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceParDomaineCreateInput = {
    id?: string
    title: string
    content: string
    desc: string
    lawyer: LawyerCreateNestedOneWithoutServicesInput
  }

  export type ServiceParDomaineUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    content: string
    desc: string
  }

  export type ServiceParDomaineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    lawyer?: LawyerUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceParDomaineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceParDomaineCreateManyInput = {
    id?: string
    userId: string
    title: string
    content: string
    desc: string
  }

  export type ServiceParDomaineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceParDomaineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type PreventifsCreateInput = {
    id?: string
    title: string
    content: string
    desc: string
    lawyer: LawyerCreateNestedOneWithoutPreventifsInput
  }

  export type PreventifsUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    content: string
    desc: string
  }

  export type PreventifsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    lawyer?: LawyerUpdateOneRequiredWithoutPreventifsNestedInput
  }

  export type PreventifsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type PreventifsCreateManyInput = {
    id?: string
    userId: string
    title: string
    content: string
    desc: string
  }

  export type PreventifsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type PreventifsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ValeurAjouterCreateInput = {
    id?: string
    title: string
    content: string
    desc: string
    lawyer: LawyerCreateNestedOneWithoutValuerInput
  }

  export type ValeurAjouterUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    content: string
    desc: string
  }

  export type ValeurAjouterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    lawyer?: LawyerUpdateOneRequiredWithoutValuerNestedInput
  }

  export type ValeurAjouterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ValeurAjouterCreateManyInput = {
    id?: string
    userId: string
    title: string
    content: string
    desc: string
  }

  export type ValeurAjouterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ValeurAjouterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type FriendsCreateInput = {
    id?: string
    name: string
    nbrDeContrat: string
    key: string
    client: ClientCreateNestedOneWithoutFriendInput
  }

  export type FriendsUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    nbrDeContrat: string
    key: string
  }

  export type FriendsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    client?: ClientUpdateOneRequiredWithoutFriendNestedInput
  }

  export type FriendsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type FriendsCreateManyInput = {
    id?: string
    userId: string
    name: string
    nbrDeContrat: string
    key: string
  }

  export type FriendsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type FriendsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type FriendLawCreateInput = {
    id?: string
    name: string
    nbrDeContrat: string
    key: string
    lawyer: LawyerCreateNestedOneWithoutFriendLawInput
  }

  export type FriendLawUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    nbrDeContrat: string
    key: string
  }

  export type FriendLawUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    lawyer?: LawyerUpdateOneRequiredWithoutFriendLawNestedInput
  }

  export type FriendLawUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type FriendLawCreateManyInput = {
    id?: string
    userId: string
    name: string
    nbrDeContrat: string
    key: string
  }

  export type FriendLawUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type FriendLawUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ContratCreateInput = {
    id?: string
    type?: string | null
    date?: Date | string | null
    content?: string | null
    lawyer: LawyerCreateNestedOneWithoutContratInput
  }

  export type ContratUncheckedCreateInput = {
    id?: string
    userId: string
    type?: string | null
    date?: Date | string | null
    content?: string | null
  }

  export type ContratUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer?: LawyerUpdateOneRequiredWithoutContratNestedInput
  }

  export type ContratUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContratCreateManyInput = {
    id?: string
    userId: string
    type?: string | null
    date?: Date | string | null
    content?: string | null
  }

  export type ContratUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContratUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateInput = {
    id?: string
    content?: string | null
    TimeToReceive?: Date | string | null
    vue?: boolean | null
    type: string
    key?: string | null
    lawyer?: LawyerCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    content?: string | null
    TimeToReceive?: Date | string | null
    vue?: boolean | null
    type: string
    key?: string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer?: LawyerUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    content?: string | null
    TimeToReceive?: Date | string | null
    vue?: boolean | null
    type: string
    key?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientNotificationCreateInput = {
    id?: string
    content?: string | null
    TimeToReceive?: Date | string | null
    vue?: boolean | null
    type: string
    key: string
    client: ClientCreateNestedOneWithoutNotificationInput
  }

  export type ClientNotificationUncheckedCreateInput = {
    id?: string
    userId: string
    content?: string | null
    TimeToReceive?: Date | string | null
    vue?: boolean | null
    type: string
    key: string
  }

  export type ClientNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    client?: ClientUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type ClientNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ClientNotificationCreateManyInput = {
    id?: string
    userId: string
    content?: string | null
    TimeToReceive?: Date | string | null
    vue?: boolean | null
    type: string
    key: string
  }

  export type ClientNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ClientNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ContactCreateInput = {
    id?: string
    name: string
    contenu: string
    date?: Date | string
    key: string
    lawyer?: LawyerCreateNestedOneWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    contenu: string
    date?: Date | string
    key: string
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
    lawyer?: LawyerUpdateOneWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ContactCreateManyInput = {
    id?: string
    userId: string
    name: string
    contenu: string
    date?: Date | string
    key: string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ClientContactCreateInput = {
    id?: string
    name: string
    contenu: string
    date?: Date | string
    key: string
    client?: ClientCreateNestedOneWithoutClientInput
  }

  export type ClientContactUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    contenu: string
    date?: Date | string
    key: string
  }

  export type ClientContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
    client?: ClientUpdateOneWithoutClientNestedInput
  }

  export type ClientContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ClientContactCreateManyInput = {
    id?: string
    userId: string
    name: string
    contenu: string
    date?: Date | string
    key: string
  }

  export type ClientContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ClientContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type DiplomeCreateInput = {
    id?: string
    ecole: string
    anne: string
    nom: string
    lawyer?: LawyerCreateNestedOneWithoutDiplomeInput
  }

  export type DiplomeUncheckedCreateInput = {
    id?: string
    userId: string
    ecole: string
    anne: string
    nom: string
  }

  export type DiplomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ecole?: StringFieldUpdateOperationsInput | string
    anne?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    lawyer?: LawyerUpdateOneWithoutDiplomeNestedInput
  }

  export type DiplomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ecole?: StringFieldUpdateOperationsInput | string
    anne?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type DiplomeCreateManyInput = {
    id?: string
    userId: string
    ecole: string
    anne: string
    nom: string
  }

  export type DiplomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ecole?: StringFieldUpdateOperationsInput | string
    anne?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type DiplomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ecole?: StringFieldUpdateOperationsInput | string
    anne?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type ExperienceCreateInput = {
    id?: string
    poste: string
    durant: string
    lawyer?: LawyerCreateNestedOneWithoutExperienceInput
  }

  export type ExperienceUncheckedCreateInput = {
    id?: string
    userId: string
    poste: string
    durant: string
  }

  export type ExperienceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    durant?: StringFieldUpdateOperationsInput | string
    lawyer?: LawyerUpdateOneWithoutExperienceNestedInput
  }

  export type ExperienceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    durant?: StringFieldUpdateOperationsInput | string
  }

  export type ExperienceCreateManyInput = {
    id?: string
    userId: string
    poste: string
    durant: string
  }

  export type ExperienceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    durant?: StringFieldUpdateOperationsInput | string
  }

  export type ExperienceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    durant?: StringFieldUpdateOperationsInput | string
  }

  export type CalendarCreateInput = {
    id?: string
    client: string
    moment: Date | string
    lawyer?: LawyerCreateNestedOneWithoutCalendarInput
  }

  export type CalendarUncheckedCreateInput = {
    id?: string
    userId: string
    client: string
    moment: Date | string
  }

  export type CalendarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    moment?: DateTimeFieldUpdateOperationsInput | Date | string
    lawyer?: LawyerUpdateOneWithoutCalendarNestedInput
  }

  export type CalendarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    moment?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarCreateManyInput = {
    id?: string
    userId: string
    client: string
    moment: Date | string
  }

  export type CalendarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    moment?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    moment?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type PostUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type PostUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type LawyerListRelationFilter = {
    every?: LawyerWhereInput
    some?: LawyerWhereInput
    none?: LawyerWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LawyerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FriendsListRelationFilter = {
    every?: FriendsWhereInput
    some?: FriendsWhereInput
    none?: FriendsWhereInput
  }

  export type ClientNotificationListRelationFilter = {
    every?: ClientNotificationWhereInput
    some?: ClientNotificationWhereInput
    none?: ClientNotificationWhereInput
  }

  export type ClientContactListRelationFilter = {
    every?: ClientContactWhereInput
    some?: ClientContactWhereInput
    none?: ClientContactWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FriendsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelevanceInput = {
    fields: ClientOrderByRelevanceFieldEnum | ClientOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    profession?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    localisation?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    profession?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    localisation?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    profession?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    localisation?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DiplomeListRelationFilter = {
    every?: DiplomeWhereInput
    some?: DiplomeWhereInput
    none?: DiplomeWhereInput
  }

  export type ExperienceListRelationFilter = {
    every?: ExperienceWhereInput
    some?: ExperienceWhereInput
    none?: ExperienceWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ContratListRelationFilter = {
    every?: ContratWhereInput
    some?: ContratWhereInput
    none?: ContratWhereInput
  }

  export type CalendarListRelationFilter = {
    every?: CalendarWhereInput
    some?: CalendarWhereInput
    none?: CalendarWhereInput
  }

  export type FriendLawListRelationFilter = {
    every?: FriendLawWhereInput
    some?: FriendLawWhereInput
    none?: FriendLawWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type ConseilJuridiqueListRelationFilter = {
    every?: ConseilJuridiqueWhereInput
    some?: ConseilJuridiqueWhereInput
    none?: ConseilJuridiqueWhereInput
  }

  export type RedactionListRelationFilter = {
    every?: RedactionWhereInput
    some?: RedactionWhereInput
    none?: RedactionWhereInput
  }

  export type ResolutionLitigeListRelationFilter = {
    every?: ResolutionLitigeWhereInput
    some?: ResolutionLitigeWhereInput
    none?: ResolutionLitigeWhereInput
  }

  export type ServiceParDomaineListRelationFilter = {
    every?: ServiceParDomaineWhereInput
    some?: ServiceParDomaineWhereInput
    none?: ServiceParDomaineWhereInput
  }

  export type PreventifsListRelationFilter = {
    every?: PreventifsWhereInput
    some?: PreventifsWhereInput
    none?: PreventifsWhereInput
  }

  export type ValeurAjouterListRelationFilter = {
    every?: ValeurAjouterWhereInput
    some?: ValeurAjouterWhereInput
    none?: ValeurAjouterWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type DiplomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExperienceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContratOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalendarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendLawOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConseilJuridiqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RedactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResolutionLitigeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceParDomaineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PreventifsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ValeurAjouterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LawyerOrderByRelevanceInput = {
    fields: LawyerOrderByRelevanceFieldEnum | LawyerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LawyerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    age?: SortOrder
    localisation?: SortOrder
    budget?: SortOrder
    gender?: SortOrder
    specialité?: SortOrder
    Star?: SortOrder
  }

  export type LawyerAvgOrderByAggregateInput = {
    age?: SortOrder
    Star?: SortOrder
  }

  export type LawyerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    age?: SortOrder
    localisation?: SortOrder
    budget?: SortOrder
    gender?: SortOrder
    specialité?: SortOrder
    Star?: SortOrder
  }

  export type LawyerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    age?: SortOrder
    localisation?: SortOrder
    budget?: SortOrder
    gender?: SortOrder
    specialité?: SortOrder
    Star?: SortOrder
  }

  export type LawyerSumOrderByAggregateInput = {
    age?: SortOrder
    Star?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type LawyerScalarRelationFilter = {
    is?: LawyerWhereInput
    isNot?: LawyerWhereInput
  }

  export type ConseilJuridiqueOrderByRelevanceInput = {
    fields: ConseilJuridiqueOrderByRelevanceFieldEnum | ConseilJuridiqueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ConseilJuridiqueCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type ConseilJuridiqueMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type ConseilJuridiqueMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type RedactionOrderByRelevanceInput = {
    fields: RedactionOrderByRelevanceFieldEnum | RedactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RedactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type RedactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type RedactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type ResolutionLitigeOrderByRelevanceInput = {
    fields: ResolutionLitigeOrderByRelevanceFieldEnum | ResolutionLitigeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ResolutionLitigeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type ResolutionLitigeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type ResolutionLitigeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type ServiceParDomaineOrderByRelevanceInput = {
    fields: ServiceParDomaineOrderByRelevanceFieldEnum | ServiceParDomaineOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ServiceParDomaineCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type ServiceParDomaineMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type ServiceParDomaineMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type PreventifsOrderByRelevanceInput = {
    fields: PreventifsOrderByRelevanceFieldEnum | PreventifsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PreventifsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type PreventifsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type PreventifsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type ValeurAjouterOrderByRelevanceInput = {
    fields: ValeurAjouterOrderByRelevanceFieldEnum | ValeurAjouterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ValeurAjouterCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type ValeurAjouterMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type ValeurAjouterMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    desc?: SortOrder
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type FriendsOrderByRelevanceInput = {
    fields: FriendsOrderByRelevanceFieldEnum | FriendsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FriendsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    nbrDeContrat?: SortOrder
    key?: SortOrder
  }

  export type FriendsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    nbrDeContrat?: SortOrder
    key?: SortOrder
  }

  export type FriendsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    nbrDeContrat?: SortOrder
    key?: SortOrder
  }

  export type FriendLawOrderByRelevanceInput = {
    fields: FriendLawOrderByRelevanceFieldEnum | FriendLawOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FriendLawCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    nbrDeContrat?: SortOrder
    key?: SortOrder
  }

  export type FriendLawMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    nbrDeContrat?: SortOrder
    key?: SortOrder
  }

  export type FriendLawMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    nbrDeContrat?: SortOrder
    key?: SortOrder
  }

  export type ContratOrderByRelevanceInput = {
    fields: ContratOrderByRelevanceFieldEnum | ContratOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContratCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    content?: SortOrder
  }

  export type ContratMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    content?: SortOrder
  }

  export type ContratMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    date?: SortOrder
    content?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type LawyerNullableScalarRelationFilter = {
    is?: LawyerWhereInput | null
    isNot?: LawyerWhereInput | null
  }

  export type NotificationOrderByRelevanceInput = {
    fields: NotificationOrderByRelevanceFieldEnum | NotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    TimeToReceive?: SortOrder
    vue?: SortOrder
    type?: SortOrder
    key?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    TimeToReceive?: SortOrder
    vue?: SortOrder
    type?: SortOrder
    key?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    TimeToReceive?: SortOrder
    vue?: SortOrder
    type?: SortOrder
    key?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ClientNotificationOrderByRelevanceInput = {
    fields: ClientNotificationOrderByRelevanceFieldEnum | ClientNotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    TimeToReceive?: SortOrder
    vue?: SortOrder
    type?: SortOrder
    key?: SortOrder
  }

  export type ClientNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    TimeToReceive?: SortOrder
    vue?: SortOrder
    type?: SortOrder
    key?: SortOrder
  }

  export type ClientNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    TimeToReceive?: SortOrder
    vue?: SortOrder
    type?: SortOrder
    key?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ContactOrderByRelevanceInput = {
    fields: ContactOrderByRelevanceFieldEnum | ContactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contenu?: SortOrder
    date?: SortOrder
    key?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contenu?: SortOrder
    date?: SortOrder
    key?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contenu?: SortOrder
    date?: SortOrder
    key?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type ClientContactOrderByRelevanceInput = {
    fields: ClientContactOrderByRelevanceFieldEnum | ClientContactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientContactCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contenu?: SortOrder
    date?: SortOrder
    key?: SortOrder
  }

  export type ClientContactMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contenu?: SortOrder
    date?: SortOrder
    key?: SortOrder
  }

  export type ClientContactMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    contenu?: SortOrder
    date?: SortOrder
    key?: SortOrder
  }

  export type DiplomeOrderByRelevanceInput = {
    fields: DiplomeOrderByRelevanceFieldEnum | DiplomeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DiplomeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ecole?: SortOrder
    anne?: SortOrder
    nom?: SortOrder
  }

  export type DiplomeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ecole?: SortOrder
    anne?: SortOrder
    nom?: SortOrder
  }

  export type DiplomeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    ecole?: SortOrder
    anne?: SortOrder
    nom?: SortOrder
  }

  export type ExperienceOrderByRelevanceInput = {
    fields: ExperienceOrderByRelevanceFieldEnum | ExperienceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExperienceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    poste?: SortOrder
    durant?: SortOrder
  }

  export type ExperienceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    poste?: SortOrder
    durant?: SortOrder
  }

  export type ExperienceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    poste?: SortOrder
    durant?: SortOrder
  }

  export type CalendarOrderByRelevanceInput = {
    fields: CalendarOrderByRelevanceFieldEnum | CalendarOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CalendarCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    client?: SortOrder
    moment?: SortOrder
  }

  export type CalendarMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    client?: SortOrder
    moment?: SortOrder
  }

  export type CalendarMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    client?: SortOrder
    moment?: SortOrder
  }

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    refresh_token_expires_in?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
    refresh_token_expires_in?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    refresh_token_expires_in?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    refresh_token_expires_in?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
    refresh_token_expires_in?: SortOrder
  }

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type PostOrderByRelevanceInput = {
    fields: PostOrderByRelevanceFieldEnum | PostOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VerificationTokenOrderByRelevanceInput = {
    fields: VerificationTokenOrderByRelevanceFieldEnum | VerificationTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type ClientCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput> | ClientCreateWithoutUserInput[] | ClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput | ClientCreateOrConnectWithoutUserInput[]
    createMany?: ClientCreateManyUserInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type LawyerCreateNestedManyWithoutUserInput = {
    create?: XOR<LawyerCreateWithoutUserInput, LawyerUncheckedCreateWithoutUserInput> | LawyerCreateWithoutUserInput[] | LawyerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LawyerCreateOrConnectWithoutUserInput | LawyerCreateOrConnectWithoutUserInput[]
    createMany?: LawyerCreateManyUserInputEnvelope
    connect?: LawyerWhereUniqueInput | LawyerWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PostCreateWithoutCreatedByInput, PostUncheckedCreateWithoutCreatedByInput> | PostCreateWithoutCreatedByInput[] | PostUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCreatedByInput | PostCreateOrConnectWithoutCreatedByInput[]
    createMany?: PostCreateManyCreatedByInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput> | ClientCreateWithoutUserInput[] | ClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput | ClientCreateOrConnectWithoutUserInput[]
    createMany?: ClientCreateManyUserInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type LawyerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LawyerCreateWithoutUserInput, LawyerUncheckedCreateWithoutUserInput> | LawyerCreateWithoutUserInput[] | LawyerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LawyerCreateOrConnectWithoutUserInput | LawyerCreateOrConnectWithoutUserInput[]
    createMany?: LawyerCreateManyUserInputEnvelope
    connect?: LawyerWhereUniqueInput | LawyerWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PostCreateWithoutCreatedByInput, PostUncheckedCreateWithoutCreatedByInput> | PostCreateWithoutCreatedByInput[] | PostUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCreatedByInput | PostCreateOrConnectWithoutCreatedByInput[]
    createMany?: PostCreateManyCreatedByInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ClientUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput> | ClientCreateWithoutUserInput[] | ClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput | ClientCreateOrConnectWithoutUserInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutUserInput | ClientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientCreateManyUserInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutUserInput | ClientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutUserInput | ClientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type LawyerUpdateManyWithoutUserNestedInput = {
    create?: XOR<LawyerCreateWithoutUserInput, LawyerUncheckedCreateWithoutUserInput> | LawyerCreateWithoutUserInput[] | LawyerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LawyerCreateOrConnectWithoutUserInput | LawyerCreateOrConnectWithoutUserInput[]
    upsert?: LawyerUpsertWithWhereUniqueWithoutUserInput | LawyerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LawyerCreateManyUserInputEnvelope
    set?: LawyerWhereUniqueInput | LawyerWhereUniqueInput[]
    disconnect?: LawyerWhereUniqueInput | LawyerWhereUniqueInput[]
    delete?: LawyerWhereUniqueInput | LawyerWhereUniqueInput[]
    connect?: LawyerWhereUniqueInput | LawyerWhereUniqueInput[]
    update?: LawyerUpdateWithWhereUniqueWithoutUserInput | LawyerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LawyerUpdateManyWithWhereWithoutUserInput | LawyerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LawyerScalarWhereInput | LawyerScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PostUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PostCreateWithoutCreatedByInput, PostUncheckedCreateWithoutCreatedByInput> | PostCreateWithoutCreatedByInput[] | PostUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCreatedByInput | PostCreateOrConnectWithoutCreatedByInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCreatedByInput | PostUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PostCreateManyCreatedByInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCreatedByInput | PostUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCreatedByInput | PostUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput> | ClientCreateWithoutUserInput[] | ClientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutUserInput | ClientCreateOrConnectWithoutUserInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutUserInput | ClientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientCreateManyUserInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutUserInput | ClientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutUserInput | ClientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type LawyerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LawyerCreateWithoutUserInput, LawyerUncheckedCreateWithoutUserInput> | LawyerCreateWithoutUserInput[] | LawyerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LawyerCreateOrConnectWithoutUserInput | LawyerCreateOrConnectWithoutUserInput[]
    upsert?: LawyerUpsertWithWhereUniqueWithoutUserInput | LawyerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LawyerCreateManyUserInputEnvelope
    set?: LawyerWhereUniqueInput | LawyerWhereUniqueInput[]
    disconnect?: LawyerWhereUniqueInput | LawyerWhereUniqueInput[]
    delete?: LawyerWhereUniqueInput | LawyerWhereUniqueInput[]
    connect?: LawyerWhereUniqueInput | LawyerWhereUniqueInput[]
    update?: LawyerUpdateWithWhereUniqueWithoutUserInput | LawyerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LawyerUpdateManyWithWhereWithoutUserInput | LawyerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LawyerScalarWhereInput | LawyerScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PostCreateWithoutCreatedByInput, PostUncheckedCreateWithoutCreatedByInput> | PostCreateWithoutCreatedByInput[] | PostUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCreatedByInput | PostCreateOrConnectWithoutCreatedByInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCreatedByInput | PostUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PostCreateManyCreatedByInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCreatedByInput | PostUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCreatedByInput | PostUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type FriendsCreateNestedManyWithoutClientInput = {
    create?: XOR<FriendsCreateWithoutClientInput, FriendsUncheckedCreateWithoutClientInput> | FriendsCreateWithoutClientInput[] | FriendsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutClientInput | FriendsCreateOrConnectWithoutClientInput[]
    createMany?: FriendsCreateManyClientInputEnvelope
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
  }

  export type ClientNotificationCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientNotificationCreateWithoutClientInput, ClientNotificationUncheckedCreateWithoutClientInput> | ClientNotificationCreateWithoutClientInput[] | ClientNotificationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientNotificationCreateOrConnectWithoutClientInput | ClientNotificationCreateOrConnectWithoutClientInput[]
    createMany?: ClientNotificationCreateManyClientInputEnvelope
    connect?: ClientNotificationWhereUniqueInput | ClientNotificationWhereUniqueInput[]
  }

  export type ClientContactCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientContactCreateWithoutClientInput, ClientContactUncheckedCreateWithoutClientInput> | ClientContactCreateWithoutClientInput[] | ClientContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientContactCreateOrConnectWithoutClientInput | ClientContactCreateOrConnectWithoutClientInput[]
    createMany?: ClientContactCreateManyClientInputEnvelope
    connect?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    connect?: UserWhereUniqueInput
  }

  export type FriendsUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<FriendsCreateWithoutClientInput, FriendsUncheckedCreateWithoutClientInput> | FriendsCreateWithoutClientInput[] | FriendsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutClientInput | FriendsCreateOrConnectWithoutClientInput[]
    createMany?: FriendsCreateManyClientInputEnvelope
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
  }

  export type ClientNotificationUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientNotificationCreateWithoutClientInput, ClientNotificationUncheckedCreateWithoutClientInput> | ClientNotificationCreateWithoutClientInput[] | ClientNotificationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientNotificationCreateOrConnectWithoutClientInput | ClientNotificationCreateOrConnectWithoutClientInput[]
    createMany?: ClientNotificationCreateManyClientInputEnvelope
    connect?: ClientNotificationWhereUniqueInput | ClientNotificationWhereUniqueInput[]
  }

  export type ClientContactUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientContactCreateWithoutClientInput, ClientContactUncheckedCreateWithoutClientInput> | ClientContactCreateWithoutClientInput[] | ClientContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientContactCreateOrConnectWithoutClientInput | ClientContactCreateOrConnectWithoutClientInput[]
    createMany?: ClientContactCreateManyClientInputEnvelope
    connect?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FriendsUpdateManyWithoutClientNestedInput = {
    create?: XOR<FriendsCreateWithoutClientInput, FriendsUncheckedCreateWithoutClientInput> | FriendsCreateWithoutClientInput[] | FriendsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutClientInput | FriendsCreateOrConnectWithoutClientInput[]
    upsert?: FriendsUpsertWithWhereUniqueWithoutClientInput | FriendsUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: FriendsCreateManyClientInputEnvelope
    set?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    disconnect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    delete?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    update?: FriendsUpdateWithWhereUniqueWithoutClientInput | FriendsUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: FriendsUpdateManyWithWhereWithoutClientInput | FriendsUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
  }

  export type ClientNotificationUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientNotificationCreateWithoutClientInput, ClientNotificationUncheckedCreateWithoutClientInput> | ClientNotificationCreateWithoutClientInput[] | ClientNotificationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientNotificationCreateOrConnectWithoutClientInput | ClientNotificationCreateOrConnectWithoutClientInput[]
    upsert?: ClientNotificationUpsertWithWhereUniqueWithoutClientInput | ClientNotificationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientNotificationCreateManyClientInputEnvelope
    set?: ClientNotificationWhereUniqueInput | ClientNotificationWhereUniqueInput[]
    disconnect?: ClientNotificationWhereUniqueInput | ClientNotificationWhereUniqueInput[]
    delete?: ClientNotificationWhereUniqueInput | ClientNotificationWhereUniqueInput[]
    connect?: ClientNotificationWhereUniqueInput | ClientNotificationWhereUniqueInput[]
    update?: ClientNotificationUpdateWithWhereUniqueWithoutClientInput | ClientNotificationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientNotificationUpdateManyWithWhereWithoutClientInput | ClientNotificationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientNotificationScalarWhereInput | ClientNotificationScalarWhereInput[]
  }

  export type ClientContactUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientContactCreateWithoutClientInput, ClientContactUncheckedCreateWithoutClientInput> | ClientContactCreateWithoutClientInput[] | ClientContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientContactCreateOrConnectWithoutClientInput | ClientContactCreateOrConnectWithoutClientInput[]
    upsert?: ClientContactUpsertWithWhereUniqueWithoutClientInput | ClientContactUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientContactCreateManyClientInputEnvelope
    set?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[]
    disconnect?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[]
    delete?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[]
    connect?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[]
    update?: ClientContactUpdateWithWhereUniqueWithoutClientInput | ClientContactUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientContactUpdateManyWithWhereWithoutClientInput | ClientContactUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientContactScalarWhereInput | ClientContactScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientInput
    upsert?: UserUpsertWithoutClientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientInput, UserUpdateWithoutClientInput>, UserUncheckedUpdateWithoutClientInput>
  }

  export type FriendsUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<FriendsCreateWithoutClientInput, FriendsUncheckedCreateWithoutClientInput> | FriendsCreateWithoutClientInput[] | FriendsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FriendsCreateOrConnectWithoutClientInput | FriendsCreateOrConnectWithoutClientInput[]
    upsert?: FriendsUpsertWithWhereUniqueWithoutClientInput | FriendsUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: FriendsCreateManyClientInputEnvelope
    set?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    disconnect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    delete?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    connect?: FriendsWhereUniqueInput | FriendsWhereUniqueInput[]
    update?: FriendsUpdateWithWhereUniqueWithoutClientInput | FriendsUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: FriendsUpdateManyWithWhereWithoutClientInput | FriendsUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
  }

  export type ClientNotificationUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientNotificationCreateWithoutClientInput, ClientNotificationUncheckedCreateWithoutClientInput> | ClientNotificationCreateWithoutClientInput[] | ClientNotificationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientNotificationCreateOrConnectWithoutClientInput | ClientNotificationCreateOrConnectWithoutClientInput[]
    upsert?: ClientNotificationUpsertWithWhereUniqueWithoutClientInput | ClientNotificationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientNotificationCreateManyClientInputEnvelope
    set?: ClientNotificationWhereUniqueInput | ClientNotificationWhereUniqueInput[]
    disconnect?: ClientNotificationWhereUniqueInput | ClientNotificationWhereUniqueInput[]
    delete?: ClientNotificationWhereUniqueInput | ClientNotificationWhereUniqueInput[]
    connect?: ClientNotificationWhereUniqueInput | ClientNotificationWhereUniqueInput[]
    update?: ClientNotificationUpdateWithWhereUniqueWithoutClientInput | ClientNotificationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientNotificationUpdateManyWithWhereWithoutClientInput | ClientNotificationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientNotificationScalarWhereInput | ClientNotificationScalarWhereInput[]
  }

  export type ClientContactUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientContactCreateWithoutClientInput, ClientContactUncheckedCreateWithoutClientInput> | ClientContactCreateWithoutClientInput[] | ClientContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientContactCreateOrConnectWithoutClientInput | ClientContactCreateOrConnectWithoutClientInput[]
    upsert?: ClientContactUpsertWithWhereUniqueWithoutClientInput | ClientContactUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientContactCreateManyClientInputEnvelope
    set?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[]
    disconnect?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[]
    delete?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[]
    connect?: ClientContactWhereUniqueInput | ClientContactWhereUniqueInput[]
    update?: ClientContactUpdateWithWhereUniqueWithoutClientInput | ClientContactUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientContactUpdateManyWithWhereWithoutClientInput | ClientContactUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientContactScalarWhereInput | ClientContactScalarWhereInput[]
  }

  export type DiplomeCreateNestedManyWithoutLawyerInput = {
    create?: XOR<DiplomeCreateWithoutLawyerInput, DiplomeUncheckedCreateWithoutLawyerInput> | DiplomeCreateWithoutLawyerInput[] | DiplomeUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: DiplomeCreateOrConnectWithoutLawyerInput | DiplomeCreateOrConnectWithoutLawyerInput[]
    createMany?: DiplomeCreateManyLawyerInputEnvelope
    connect?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
  }

  export type ExperienceCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ExperienceCreateWithoutLawyerInput, ExperienceUncheckedCreateWithoutLawyerInput> | ExperienceCreateWithoutLawyerInput[] | ExperienceUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutLawyerInput | ExperienceCreateOrConnectWithoutLawyerInput[]
    createMany?: ExperienceCreateManyLawyerInputEnvelope
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutLawyerInput = {
    create?: XOR<NotificationCreateWithoutLawyerInput, NotificationUncheckedCreateWithoutLawyerInput> | NotificationCreateWithoutLawyerInput[] | NotificationUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutLawyerInput | NotificationCreateOrConnectWithoutLawyerInput[]
    createMany?: NotificationCreateManyLawyerInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ContratCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ContratCreateWithoutLawyerInput, ContratUncheckedCreateWithoutLawyerInput> | ContratCreateWithoutLawyerInput[] | ContratUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ContratCreateOrConnectWithoutLawyerInput | ContratCreateOrConnectWithoutLawyerInput[]
    createMany?: ContratCreateManyLawyerInputEnvelope
    connect?: ContratWhereUniqueInput | ContratWhereUniqueInput[]
  }

  export type CalendarCreateNestedManyWithoutLawyerInput = {
    create?: XOR<CalendarCreateWithoutLawyerInput, CalendarUncheckedCreateWithoutLawyerInput> | CalendarCreateWithoutLawyerInput[] | CalendarUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutLawyerInput | CalendarCreateOrConnectWithoutLawyerInput[]
    createMany?: CalendarCreateManyLawyerInputEnvelope
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
  }

  export type FriendLawCreateNestedManyWithoutLawyerInput = {
    create?: XOR<FriendLawCreateWithoutLawyerInput, FriendLawUncheckedCreateWithoutLawyerInput> | FriendLawCreateWithoutLawyerInput[] | FriendLawUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: FriendLawCreateOrConnectWithoutLawyerInput | FriendLawCreateOrConnectWithoutLawyerInput[]
    createMany?: FriendLawCreateManyLawyerInputEnvelope
    connect?: FriendLawWhereUniqueInput | FriendLawWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ContactCreateWithoutLawyerInput, ContactUncheckedCreateWithoutLawyerInput> | ContactCreateWithoutLawyerInput[] | ContactUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutLawyerInput | ContactCreateOrConnectWithoutLawyerInput[]
    createMany?: ContactCreateManyLawyerInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ConseilJuridiqueCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ConseilJuridiqueCreateWithoutLawyerInput, ConseilJuridiqueUncheckedCreateWithoutLawyerInput> | ConseilJuridiqueCreateWithoutLawyerInput[] | ConseilJuridiqueUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ConseilJuridiqueCreateOrConnectWithoutLawyerInput | ConseilJuridiqueCreateOrConnectWithoutLawyerInput[]
    createMany?: ConseilJuridiqueCreateManyLawyerInputEnvelope
    connect?: ConseilJuridiqueWhereUniqueInput | ConseilJuridiqueWhereUniqueInput[]
  }

  export type RedactionCreateNestedManyWithoutLawyerInput = {
    create?: XOR<RedactionCreateWithoutLawyerInput, RedactionUncheckedCreateWithoutLawyerInput> | RedactionCreateWithoutLawyerInput[] | RedactionUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: RedactionCreateOrConnectWithoutLawyerInput | RedactionCreateOrConnectWithoutLawyerInput[]
    createMany?: RedactionCreateManyLawyerInputEnvelope
    connect?: RedactionWhereUniqueInput | RedactionWhereUniqueInput[]
  }

  export type ResolutionLitigeCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ResolutionLitigeCreateWithoutLawyerInput, ResolutionLitigeUncheckedCreateWithoutLawyerInput> | ResolutionLitigeCreateWithoutLawyerInput[] | ResolutionLitigeUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ResolutionLitigeCreateOrConnectWithoutLawyerInput | ResolutionLitigeCreateOrConnectWithoutLawyerInput[]
    createMany?: ResolutionLitigeCreateManyLawyerInputEnvelope
    connect?: ResolutionLitigeWhereUniqueInput | ResolutionLitigeWhereUniqueInput[]
  }

  export type ServiceParDomaineCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ServiceParDomaineCreateWithoutLawyerInput, ServiceParDomaineUncheckedCreateWithoutLawyerInput> | ServiceParDomaineCreateWithoutLawyerInput[] | ServiceParDomaineUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ServiceParDomaineCreateOrConnectWithoutLawyerInput | ServiceParDomaineCreateOrConnectWithoutLawyerInput[]
    createMany?: ServiceParDomaineCreateManyLawyerInputEnvelope
    connect?: ServiceParDomaineWhereUniqueInput | ServiceParDomaineWhereUniqueInput[]
  }

  export type PreventifsCreateNestedManyWithoutLawyerInput = {
    create?: XOR<PreventifsCreateWithoutLawyerInput, PreventifsUncheckedCreateWithoutLawyerInput> | PreventifsCreateWithoutLawyerInput[] | PreventifsUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: PreventifsCreateOrConnectWithoutLawyerInput | PreventifsCreateOrConnectWithoutLawyerInput[]
    createMany?: PreventifsCreateManyLawyerInputEnvelope
    connect?: PreventifsWhereUniqueInput | PreventifsWhereUniqueInput[]
  }

  export type ValeurAjouterCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ValeurAjouterCreateWithoutLawyerInput, ValeurAjouterUncheckedCreateWithoutLawyerInput> | ValeurAjouterCreateWithoutLawyerInput[] | ValeurAjouterUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ValeurAjouterCreateOrConnectWithoutLawyerInput | ValeurAjouterCreateOrConnectWithoutLawyerInput[]
    createMany?: ValeurAjouterCreateManyLawyerInputEnvelope
    connect?: ValeurAjouterWhereUniqueInput | ValeurAjouterWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutLawyerInput = {
    create?: XOR<UserCreateWithoutLawyerInput, UserUncheckedCreateWithoutLawyerInput>
    connectOrCreate?: UserCreateOrConnectWithoutLawyerInput
    connect?: UserWhereUniqueInput
  }

  export type DiplomeUncheckedCreateNestedManyWithoutLawyerInput = {
    create?: XOR<DiplomeCreateWithoutLawyerInput, DiplomeUncheckedCreateWithoutLawyerInput> | DiplomeCreateWithoutLawyerInput[] | DiplomeUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: DiplomeCreateOrConnectWithoutLawyerInput | DiplomeCreateOrConnectWithoutLawyerInput[]
    createMany?: DiplomeCreateManyLawyerInputEnvelope
    connect?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
  }

  export type ExperienceUncheckedCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ExperienceCreateWithoutLawyerInput, ExperienceUncheckedCreateWithoutLawyerInput> | ExperienceCreateWithoutLawyerInput[] | ExperienceUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutLawyerInput | ExperienceCreateOrConnectWithoutLawyerInput[]
    createMany?: ExperienceCreateManyLawyerInputEnvelope
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutLawyerInput = {
    create?: XOR<NotificationCreateWithoutLawyerInput, NotificationUncheckedCreateWithoutLawyerInput> | NotificationCreateWithoutLawyerInput[] | NotificationUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutLawyerInput | NotificationCreateOrConnectWithoutLawyerInput[]
    createMany?: NotificationCreateManyLawyerInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ContratUncheckedCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ContratCreateWithoutLawyerInput, ContratUncheckedCreateWithoutLawyerInput> | ContratCreateWithoutLawyerInput[] | ContratUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ContratCreateOrConnectWithoutLawyerInput | ContratCreateOrConnectWithoutLawyerInput[]
    createMany?: ContratCreateManyLawyerInputEnvelope
    connect?: ContratWhereUniqueInput | ContratWhereUniqueInput[]
  }

  export type CalendarUncheckedCreateNestedManyWithoutLawyerInput = {
    create?: XOR<CalendarCreateWithoutLawyerInput, CalendarUncheckedCreateWithoutLawyerInput> | CalendarCreateWithoutLawyerInput[] | CalendarUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutLawyerInput | CalendarCreateOrConnectWithoutLawyerInput[]
    createMany?: CalendarCreateManyLawyerInputEnvelope
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
  }

  export type FriendLawUncheckedCreateNestedManyWithoutLawyerInput = {
    create?: XOR<FriendLawCreateWithoutLawyerInput, FriendLawUncheckedCreateWithoutLawyerInput> | FriendLawCreateWithoutLawyerInput[] | FriendLawUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: FriendLawCreateOrConnectWithoutLawyerInput | FriendLawCreateOrConnectWithoutLawyerInput[]
    createMany?: FriendLawCreateManyLawyerInputEnvelope
    connect?: FriendLawWhereUniqueInput | FriendLawWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ContactCreateWithoutLawyerInput, ContactUncheckedCreateWithoutLawyerInput> | ContactCreateWithoutLawyerInput[] | ContactUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutLawyerInput | ContactCreateOrConnectWithoutLawyerInput[]
    createMany?: ContactCreateManyLawyerInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ConseilJuridiqueCreateWithoutLawyerInput, ConseilJuridiqueUncheckedCreateWithoutLawyerInput> | ConseilJuridiqueCreateWithoutLawyerInput[] | ConseilJuridiqueUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ConseilJuridiqueCreateOrConnectWithoutLawyerInput | ConseilJuridiqueCreateOrConnectWithoutLawyerInput[]
    createMany?: ConseilJuridiqueCreateManyLawyerInputEnvelope
    connect?: ConseilJuridiqueWhereUniqueInput | ConseilJuridiqueWhereUniqueInput[]
  }

  export type RedactionUncheckedCreateNestedManyWithoutLawyerInput = {
    create?: XOR<RedactionCreateWithoutLawyerInput, RedactionUncheckedCreateWithoutLawyerInput> | RedactionCreateWithoutLawyerInput[] | RedactionUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: RedactionCreateOrConnectWithoutLawyerInput | RedactionCreateOrConnectWithoutLawyerInput[]
    createMany?: RedactionCreateManyLawyerInputEnvelope
    connect?: RedactionWhereUniqueInput | RedactionWhereUniqueInput[]
  }

  export type ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ResolutionLitigeCreateWithoutLawyerInput, ResolutionLitigeUncheckedCreateWithoutLawyerInput> | ResolutionLitigeCreateWithoutLawyerInput[] | ResolutionLitigeUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ResolutionLitigeCreateOrConnectWithoutLawyerInput | ResolutionLitigeCreateOrConnectWithoutLawyerInput[]
    createMany?: ResolutionLitigeCreateManyLawyerInputEnvelope
    connect?: ResolutionLitigeWhereUniqueInput | ResolutionLitigeWhereUniqueInput[]
  }

  export type ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ServiceParDomaineCreateWithoutLawyerInput, ServiceParDomaineUncheckedCreateWithoutLawyerInput> | ServiceParDomaineCreateWithoutLawyerInput[] | ServiceParDomaineUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ServiceParDomaineCreateOrConnectWithoutLawyerInput | ServiceParDomaineCreateOrConnectWithoutLawyerInput[]
    createMany?: ServiceParDomaineCreateManyLawyerInputEnvelope
    connect?: ServiceParDomaineWhereUniqueInput | ServiceParDomaineWhereUniqueInput[]
  }

  export type PreventifsUncheckedCreateNestedManyWithoutLawyerInput = {
    create?: XOR<PreventifsCreateWithoutLawyerInput, PreventifsUncheckedCreateWithoutLawyerInput> | PreventifsCreateWithoutLawyerInput[] | PreventifsUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: PreventifsCreateOrConnectWithoutLawyerInput | PreventifsCreateOrConnectWithoutLawyerInput[]
    createMany?: PreventifsCreateManyLawyerInputEnvelope
    connect?: PreventifsWhereUniqueInput | PreventifsWhereUniqueInput[]
  }

  export type ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput = {
    create?: XOR<ValeurAjouterCreateWithoutLawyerInput, ValeurAjouterUncheckedCreateWithoutLawyerInput> | ValeurAjouterCreateWithoutLawyerInput[] | ValeurAjouterUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ValeurAjouterCreateOrConnectWithoutLawyerInput | ValeurAjouterCreateOrConnectWithoutLawyerInput[]
    createMany?: ValeurAjouterCreateManyLawyerInputEnvelope
    connect?: ValeurAjouterWhereUniqueInput | ValeurAjouterWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DiplomeUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<DiplomeCreateWithoutLawyerInput, DiplomeUncheckedCreateWithoutLawyerInput> | DiplomeCreateWithoutLawyerInput[] | DiplomeUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: DiplomeCreateOrConnectWithoutLawyerInput | DiplomeCreateOrConnectWithoutLawyerInput[]
    upsert?: DiplomeUpsertWithWhereUniqueWithoutLawyerInput | DiplomeUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: DiplomeCreateManyLawyerInputEnvelope
    set?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    disconnect?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    delete?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    connect?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    update?: DiplomeUpdateWithWhereUniqueWithoutLawyerInput | DiplomeUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: DiplomeUpdateManyWithWhereWithoutLawyerInput | DiplomeUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: DiplomeScalarWhereInput | DiplomeScalarWhereInput[]
  }

  export type ExperienceUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ExperienceCreateWithoutLawyerInput, ExperienceUncheckedCreateWithoutLawyerInput> | ExperienceCreateWithoutLawyerInput[] | ExperienceUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutLawyerInput | ExperienceCreateOrConnectWithoutLawyerInput[]
    upsert?: ExperienceUpsertWithWhereUniqueWithoutLawyerInput | ExperienceUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ExperienceCreateManyLawyerInputEnvelope
    set?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    disconnect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    delete?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    update?: ExperienceUpdateWithWhereUniqueWithoutLawyerInput | ExperienceUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ExperienceUpdateManyWithWhereWithoutLawyerInput | ExperienceUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<NotificationCreateWithoutLawyerInput, NotificationUncheckedCreateWithoutLawyerInput> | NotificationCreateWithoutLawyerInput[] | NotificationUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutLawyerInput | NotificationCreateOrConnectWithoutLawyerInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutLawyerInput | NotificationUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: NotificationCreateManyLawyerInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutLawyerInput | NotificationUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutLawyerInput | NotificationUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ContratUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ContratCreateWithoutLawyerInput, ContratUncheckedCreateWithoutLawyerInput> | ContratCreateWithoutLawyerInput[] | ContratUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ContratCreateOrConnectWithoutLawyerInput | ContratCreateOrConnectWithoutLawyerInput[]
    upsert?: ContratUpsertWithWhereUniqueWithoutLawyerInput | ContratUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ContratCreateManyLawyerInputEnvelope
    set?: ContratWhereUniqueInput | ContratWhereUniqueInput[]
    disconnect?: ContratWhereUniqueInput | ContratWhereUniqueInput[]
    delete?: ContratWhereUniqueInput | ContratWhereUniqueInput[]
    connect?: ContratWhereUniqueInput | ContratWhereUniqueInput[]
    update?: ContratUpdateWithWhereUniqueWithoutLawyerInput | ContratUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ContratUpdateManyWithWhereWithoutLawyerInput | ContratUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ContratScalarWhereInput | ContratScalarWhereInput[]
  }

  export type CalendarUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<CalendarCreateWithoutLawyerInput, CalendarUncheckedCreateWithoutLawyerInput> | CalendarCreateWithoutLawyerInput[] | CalendarUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutLawyerInput | CalendarCreateOrConnectWithoutLawyerInput[]
    upsert?: CalendarUpsertWithWhereUniqueWithoutLawyerInput | CalendarUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: CalendarCreateManyLawyerInputEnvelope
    set?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    disconnect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    delete?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    update?: CalendarUpdateWithWhereUniqueWithoutLawyerInput | CalendarUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: CalendarUpdateManyWithWhereWithoutLawyerInput | CalendarUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
  }

  export type FriendLawUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<FriendLawCreateWithoutLawyerInput, FriendLawUncheckedCreateWithoutLawyerInput> | FriendLawCreateWithoutLawyerInput[] | FriendLawUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: FriendLawCreateOrConnectWithoutLawyerInput | FriendLawCreateOrConnectWithoutLawyerInput[]
    upsert?: FriendLawUpsertWithWhereUniqueWithoutLawyerInput | FriendLawUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: FriendLawCreateManyLawyerInputEnvelope
    set?: FriendLawWhereUniqueInput | FriendLawWhereUniqueInput[]
    disconnect?: FriendLawWhereUniqueInput | FriendLawWhereUniqueInput[]
    delete?: FriendLawWhereUniqueInput | FriendLawWhereUniqueInput[]
    connect?: FriendLawWhereUniqueInput | FriendLawWhereUniqueInput[]
    update?: FriendLawUpdateWithWhereUniqueWithoutLawyerInput | FriendLawUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: FriendLawUpdateManyWithWhereWithoutLawyerInput | FriendLawUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: FriendLawScalarWhereInput | FriendLawScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ContactCreateWithoutLawyerInput, ContactUncheckedCreateWithoutLawyerInput> | ContactCreateWithoutLawyerInput[] | ContactUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutLawyerInput | ContactCreateOrConnectWithoutLawyerInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutLawyerInput | ContactUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ContactCreateManyLawyerInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutLawyerInput | ContactUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutLawyerInput | ContactUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ConseilJuridiqueUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ConseilJuridiqueCreateWithoutLawyerInput, ConseilJuridiqueUncheckedCreateWithoutLawyerInput> | ConseilJuridiqueCreateWithoutLawyerInput[] | ConseilJuridiqueUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ConseilJuridiqueCreateOrConnectWithoutLawyerInput | ConseilJuridiqueCreateOrConnectWithoutLawyerInput[]
    upsert?: ConseilJuridiqueUpsertWithWhereUniqueWithoutLawyerInput | ConseilJuridiqueUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ConseilJuridiqueCreateManyLawyerInputEnvelope
    set?: ConseilJuridiqueWhereUniqueInput | ConseilJuridiqueWhereUniqueInput[]
    disconnect?: ConseilJuridiqueWhereUniqueInput | ConseilJuridiqueWhereUniqueInput[]
    delete?: ConseilJuridiqueWhereUniqueInput | ConseilJuridiqueWhereUniqueInput[]
    connect?: ConseilJuridiqueWhereUniqueInput | ConseilJuridiqueWhereUniqueInput[]
    update?: ConseilJuridiqueUpdateWithWhereUniqueWithoutLawyerInput | ConseilJuridiqueUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ConseilJuridiqueUpdateManyWithWhereWithoutLawyerInput | ConseilJuridiqueUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ConseilJuridiqueScalarWhereInput | ConseilJuridiqueScalarWhereInput[]
  }

  export type RedactionUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<RedactionCreateWithoutLawyerInput, RedactionUncheckedCreateWithoutLawyerInput> | RedactionCreateWithoutLawyerInput[] | RedactionUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: RedactionCreateOrConnectWithoutLawyerInput | RedactionCreateOrConnectWithoutLawyerInput[]
    upsert?: RedactionUpsertWithWhereUniqueWithoutLawyerInput | RedactionUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: RedactionCreateManyLawyerInputEnvelope
    set?: RedactionWhereUniqueInput | RedactionWhereUniqueInput[]
    disconnect?: RedactionWhereUniqueInput | RedactionWhereUniqueInput[]
    delete?: RedactionWhereUniqueInput | RedactionWhereUniqueInput[]
    connect?: RedactionWhereUniqueInput | RedactionWhereUniqueInput[]
    update?: RedactionUpdateWithWhereUniqueWithoutLawyerInput | RedactionUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: RedactionUpdateManyWithWhereWithoutLawyerInput | RedactionUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: RedactionScalarWhereInput | RedactionScalarWhereInput[]
  }

  export type ResolutionLitigeUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ResolutionLitigeCreateWithoutLawyerInput, ResolutionLitigeUncheckedCreateWithoutLawyerInput> | ResolutionLitigeCreateWithoutLawyerInput[] | ResolutionLitigeUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ResolutionLitigeCreateOrConnectWithoutLawyerInput | ResolutionLitigeCreateOrConnectWithoutLawyerInput[]
    upsert?: ResolutionLitigeUpsertWithWhereUniqueWithoutLawyerInput | ResolutionLitigeUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ResolutionLitigeCreateManyLawyerInputEnvelope
    set?: ResolutionLitigeWhereUniqueInput | ResolutionLitigeWhereUniqueInput[]
    disconnect?: ResolutionLitigeWhereUniqueInput | ResolutionLitigeWhereUniqueInput[]
    delete?: ResolutionLitigeWhereUniqueInput | ResolutionLitigeWhereUniqueInput[]
    connect?: ResolutionLitigeWhereUniqueInput | ResolutionLitigeWhereUniqueInput[]
    update?: ResolutionLitigeUpdateWithWhereUniqueWithoutLawyerInput | ResolutionLitigeUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ResolutionLitigeUpdateManyWithWhereWithoutLawyerInput | ResolutionLitigeUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ResolutionLitigeScalarWhereInput | ResolutionLitigeScalarWhereInput[]
  }

  export type ServiceParDomaineUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ServiceParDomaineCreateWithoutLawyerInput, ServiceParDomaineUncheckedCreateWithoutLawyerInput> | ServiceParDomaineCreateWithoutLawyerInput[] | ServiceParDomaineUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ServiceParDomaineCreateOrConnectWithoutLawyerInput | ServiceParDomaineCreateOrConnectWithoutLawyerInput[]
    upsert?: ServiceParDomaineUpsertWithWhereUniqueWithoutLawyerInput | ServiceParDomaineUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ServiceParDomaineCreateManyLawyerInputEnvelope
    set?: ServiceParDomaineWhereUniqueInput | ServiceParDomaineWhereUniqueInput[]
    disconnect?: ServiceParDomaineWhereUniqueInput | ServiceParDomaineWhereUniqueInput[]
    delete?: ServiceParDomaineWhereUniqueInput | ServiceParDomaineWhereUniqueInput[]
    connect?: ServiceParDomaineWhereUniqueInput | ServiceParDomaineWhereUniqueInput[]
    update?: ServiceParDomaineUpdateWithWhereUniqueWithoutLawyerInput | ServiceParDomaineUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ServiceParDomaineUpdateManyWithWhereWithoutLawyerInput | ServiceParDomaineUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ServiceParDomaineScalarWhereInput | ServiceParDomaineScalarWhereInput[]
  }

  export type PreventifsUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<PreventifsCreateWithoutLawyerInput, PreventifsUncheckedCreateWithoutLawyerInput> | PreventifsCreateWithoutLawyerInput[] | PreventifsUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: PreventifsCreateOrConnectWithoutLawyerInput | PreventifsCreateOrConnectWithoutLawyerInput[]
    upsert?: PreventifsUpsertWithWhereUniqueWithoutLawyerInput | PreventifsUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: PreventifsCreateManyLawyerInputEnvelope
    set?: PreventifsWhereUniqueInput | PreventifsWhereUniqueInput[]
    disconnect?: PreventifsWhereUniqueInput | PreventifsWhereUniqueInput[]
    delete?: PreventifsWhereUniqueInput | PreventifsWhereUniqueInput[]
    connect?: PreventifsWhereUniqueInput | PreventifsWhereUniqueInput[]
    update?: PreventifsUpdateWithWhereUniqueWithoutLawyerInput | PreventifsUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: PreventifsUpdateManyWithWhereWithoutLawyerInput | PreventifsUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: PreventifsScalarWhereInput | PreventifsScalarWhereInput[]
  }

  export type ValeurAjouterUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ValeurAjouterCreateWithoutLawyerInput, ValeurAjouterUncheckedCreateWithoutLawyerInput> | ValeurAjouterCreateWithoutLawyerInput[] | ValeurAjouterUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ValeurAjouterCreateOrConnectWithoutLawyerInput | ValeurAjouterCreateOrConnectWithoutLawyerInput[]
    upsert?: ValeurAjouterUpsertWithWhereUniqueWithoutLawyerInput | ValeurAjouterUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ValeurAjouterCreateManyLawyerInputEnvelope
    set?: ValeurAjouterWhereUniqueInput | ValeurAjouterWhereUniqueInput[]
    disconnect?: ValeurAjouterWhereUniqueInput | ValeurAjouterWhereUniqueInput[]
    delete?: ValeurAjouterWhereUniqueInput | ValeurAjouterWhereUniqueInput[]
    connect?: ValeurAjouterWhereUniqueInput | ValeurAjouterWhereUniqueInput[]
    update?: ValeurAjouterUpdateWithWhereUniqueWithoutLawyerInput | ValeurAjouterUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ValeurAjouterUpdateManyWithWhereWithoutLawyerInput | ValeurAjouterUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ValeurAjouterScalarWhereInput | ValeurAjouterScalarWhereInput[]
  }

  export type UserUpdateOneWithoutLawyerNestedInput = {
    create?: XOR<UserCreateWithoutLawyerInput, UserUncheckedCreateWithoutLawyerInput>
    connectOrCreate?: UserCreateOrConnectWithoutLawyerInput
    upsert?: UserUpsertWithoutLawyerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLawyerInput, UserUpdateWithoutLawyerInput>, UserUncheckedUpdateWithoutLawyerInput>
  }

  export type DiplomeUncheckedUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<DiplomeCreateWithoutLawyerInput, DiplomeUncheckedCreateWithoutLawyerInput> | DiplomeCreateWithoutLawyerInput[] | DiplomeUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: DiplomeCreateOrConnectWithoutLawyerInput | DiplomeCreateOrConnectWithoutLawyerInput[]
    upsert?: DiplomeUpsertWithWhereUniqueWithoutLawyerInput | DiplomeUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: DiplomeCreateManyLawyerInputEnvelope
    set?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    disconnect?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    delete?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    connect?: DiplomeWhereUniqueInput | DiplomeWhereUniqueInput[]
    update?: DiplomeUpdateWithWhereUniqueWithoutLawyerInput | DiplomeUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: DiplomeUpdateManyWithWhereWithoutLawyerInput | DiplomeUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: DiplomeScalarWhereInput | DiplomeScalarWhereInput[]
  }

  export type ExperienceUncheckedUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ExperienceCreateWithoutLawyerInput, ExperienceUncheckedCreateWithoutLawyerInput> | ExperienceCreateWithoutLawyerInput[] | ExperienceUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ExperienceCreateOrConnectWithoutLawyerInput | ExperienceCreateOrConnectWithoutLawyerInput[]
    upsert?: ExperienceUpsertWithWhereUniqueWithoutLawyerInput | ExperienceUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ExperienceCreateManyLawyerInputEnvelope
    set?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    disconnect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    delete?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    connect?: ExperienceWhereUniqueInput | ExperienceWhereUniqueInput[]
    update?: ExperienceUpdateWithWhereUniqueWithoutLawyerInput | ExperienceUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ExperienceUpdateManyWithWhereWithoutLawyerInput | ExperienceUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<NotificationCreateWithoutLawyerInput, NotificationUncheckedCreateWithoutLawyerInput> | NotificationCreateWithoutLawyerInput[] | NotificationUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutLawyerInput | NotificationCreateOrConnectWithoutLawyerInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutLawyerInput | NotificationUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: NotificationCreateManyLawyerInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutLawyerInput | NotificationUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutLawyerInput | NotificationUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ContratUncheckedUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ContratCreateWithoutLawyerInput, ContratUncheckedCreateWithoutLawyerInput> | ContratCreateWithoutLawyerInput[] | ContratUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ContratCreateOrConnectWithoutLawyerInput | ContratCreateOrConnectWithoutLawyerInput[]
    upsert?: ContratUpsertWithWhereUniqueWithoutLawyerInput | ContratUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ContratCreateManyLawyerInputEnvelope
    set?: ContratWhereUniqueInput | ContratWhereUniqueInput[]
    disconnect?: ContratWhereUniqueInput | ContratWhereUniqueInput[]
    delete?: ContratWhereUniqueInput | ContratWhereUniqueInput[]
    connect?: ContratWhereUniqueInput | ContratWhereUniqueInput[]
    update?: ContratUpdateWithWhereUniqueWithoutLawyerInput | ContratUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ContratUpdateManyWithWhereWithoutLawyerInput | ContratUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ContratScalarWhereInput | ContratScalarWhereInput[]
  }

  export type CalendarUncheckedUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<CalendarCreateWithoutLawyerInput, CalendarUncheckedCreateWithoutLawyerInput> | CalendarCreateWithoutLawyerInput[] | CalendarUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: CalendarCreateOrConnectWithoutLawyerInput | CalendarCreateOrConnectWithoutLawyerInput[]
    upsert?: CalendarUpsertWithWhereUniqueWithoutLawyerInput | CalendarUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: CalendarCreateManyLawyerInputEnvelope
    set?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    disconnect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    delete?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    connect?: CalendarWhereUniqueInput | CalendarWhereUniqueInput[]
    update?: CalendarUpdateWithWhereUniqueWithoutLawyerInput | CalendarUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: CalendarUpdateManyWithWhereWithoutLawyerInput | CalendarUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
  }

  export type FriendLawUncheckedUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<FriendLawCreateWithoutLawyerInput, FriendLawUncheckedCreateWithoutLawyerInput> | FriendLawCreateWithoutLawyerInput[] | FriendLawUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: FriendLawCreateOrConnectWithoutLawyerInput | FriendLawCreateOrConnectWithoutLawyerInput[]
    upsert?: FriendLawUpsertWithWhereUniqueWithoutLawyerInput | FriendLawUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: FriendLawCreateManyLawyerInputEnvelope
    set?: FriendLawWhereUniqueInput | FriendLawWhereUniqueInput[]
    disconnect?: FriendLawWhereUniqueInput | FriendLawWhereUniqueInput[]
    delete?: FriendLawWhereUniqueInput | FriendLawWhereUniqueInput[]
    connect?: FriendLawWhereUniqueInput | FriendLawWhereUniqueInput[]
    update?: FriendLawUpdateWithWhereUniqueWithoutLawyerInput | FriendLawUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: FriendLawUpdateManyWithWhereWithoutLawyerInput | FriendLawUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: FriendLawScalarWhereInput | FriendLawScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ContactCreateWithoutLawyerInput, ContactUncheckedCreateWithoutLawyerInput> | ContactCreateWithoutLawyerInput[] | ContactUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutLawyerInput | ContactCreateOrConnectWithoutLawyerInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutLawyerInput | ContactUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ContactCreateManyLawyerInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutLawyerInput | ContactUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutLawyerInput | ContactUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ConseilJuridiqueCreateWithoutLawyerInput, ConseilJuridiqueUncheckedCreateWithoutLawyerInput> | ConseilJuridiqueCreateWithoutLawyerInput[] | ConseilJuridiqueUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ConseilJuridiqueCreateOrConnectWithoutLawyerInput | ConseilJuridiqueCreateOrConnectWithoutLawyerInput[]
    upsert?: ConseilJuridiqueUpsertWithWhereUniqueWithoutLawyerInput | ConseilJuridiqueUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ConseilJuridiqueCreateManyLawyerInputEnvelope
    set?: ConseilJuridiqueWhereUniqueInput | ConseilJuridiqueWhereUniqueInput[]
    disconnect?: ConseilJuridiqueWhereUniqueInput | ConseilJuridiqueWhereUniqueInput[]
    delete?: ConseilJuridiqueWhereUniqueInput | ConseilJuridiqueWhereUniqueInput[]
    connect?: ConseilJuridiqueWhereUniqueInput | ConseilJuridiqueWhereUniqueInput[]
    update?: ConseilJuridiqueUpdateWithWhereUniqueWithoutLawyerInput | ConseilJuridiqueUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ConseilJuridiqueUpdateManyWithWhereWithoutLawyerInput | ConseilJuridiqueUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ConseilJuridiqueScalarWhereInput | ConseilJuridiqueScalarWhereInput[]
  }

  export type RedactionUncheckedUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<RedactionCreateWithoutLawyerInput, RedactionUncheckedCreateWithoutLawyerInput> | RedactionCreateWithoutLawyerInput[] | RedactionUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: RedactionCreateOrConnectWithoutLawyerInput | RedactionCreateOrConnectWithoutLawyerInput[]
    upsert?: RedactionUpsertWithWhereUniqueWithoutLawyerInput | RedactionUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: RedactionCreateManyLawyerInputEnvelope
    set?: RedactionWhereUniqueInput | RedactionWhereUniqueInput[]
    disconnect?: RedactionWhereUniqueInput | RedactionWhereUniqueInput[]
    delete?: RedactionWhereUniqueInput | RedactionWhereUniqueInput[]
    connect?: RedactionWhereUniqueInput | RedactionWhereUniqueInput[]
    update?: RedactionUpdateWithWhereUniqueWithoutLawyerInput | RedactionUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: RedactionUpdateManyWithWhereWithoutLawyerInput | RedactionUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: RedactionScalarWhereInput | RedactionScalarWhereInput[]
  }

  export type ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ResolutionLitigeCreateWithoutLawyerInput, ResolutionLitigeUncheckedCreateWithoutLawyerInput> | ResolutionLitigeCreateWithoutLawyerInput[] | ResolutionLitigeUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ResolutionLitigeCreateOrConnectWithoutLawyerInput | ResolutionLitigeCreateOrConnectWithoutLawyerInput[]
    upsert?: ResolutionLitigeUpsertWithWhereUniqueWithoutLawyerInput | ResolutionLitigeUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ResolutionLitigeCreateManyLawyerInputEnvelope
    set?: ResolutionLitigeWhereUniqueInput | ResolutionLitigeWhereUniqueInput[]
    disconnect?: ResolutionLitigeWhereUniqueInput | ResolutionLitigeWhereUniqueInput[]
    delete?: ResolutionLitigeWhereUniqueInput | ResolutionLitigeWhereUniqueInput[]
    connect?: ResolutionLitigeWhereUniqueInput | ResolutionLitigeWhereUniqueInput[]
    update?: ResolutionLitigeUpdateWithWhereUniqueWithoutLawyerInput | ResolutionLitigeUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ResolutionLitigeUpdateManyWithWhereWithoutLawyerInput | ResolutionLitigeUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ResolutionLitigeScalarWhereInput | ResolutionLitigeScalarWhereInput[]
  }

  export type ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ServiceParDomaineCreateWithoutLawyerInput, ServiceParDomaineUncheckedCreateWithoutLawyerInput> | ServiceParDomaineCreateWithoutLawyerInput[] | ServiceParDomaineUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ServiceParDomaineCreateOrConnectWithoutLawyerInput | ServiceParDomaineCreateOrConnectWithoutLawyerInput[]
    upsert?: ServiceParDomaineUpsertWithWhereUniqueWithoutLawyerInput | ServiceParDomaineUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ServiceParDomaineCreateManyLawyerInputEnvelope
    set?: ServiceParDomaineWhereUniqueInput | ServiceParDomaineWhereUniqueInput[]
    disconnect?: ServiceParDomaineWhereUniqueInput | ServiceParDomaineWhereUniqueInput[]
    delete?: ServiceParDomaineWhereUniqueInput | ServiceParDomaineWhereUniqueInput[]
    connect?: ServiceParDomaineWhereUniqueInput | ServiceParDomaineWhereUniqueInput[]
    update?: ServiceParDomaineUpdateWithWhereUniqueWithoutLawyerInput | ServiceParDomaineUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ServiceParDomaineUpdateManyWithWhereWithoutLawyerInput | ServiceParDomaineUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ServiceParDomaineScalarWhereInput | ServiceParDomaineScalarWhereInput[]
  }

  export type PreventifsUncheckedUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<PreventifsCreateWithoutLawyerInput, PreventifsUncheckedCreateWithoutLawyerInput> | PreventifsCreateWithoutLawyerInput[] | PreventifsUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: PreventifsCreateOrConnectWithoutLawyerInput | PreventifsCreateOrConnectWithoutLawyerInput[]
    upsert?: PreventifsUpsertWithWhereUniqueWithoutLawyerInput | PreventifsUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: PreventifsCreateManyLawyerInputEnvelope
    set?: PreventifsWhereUniqueInput | PreventifsWhereUniqueInput[]
    disconnect?: PreventifsWhereUniqueInput | PreventifsWhereUniqueInput[]
    delete?: PreventifsWhereUniqueInput | PreventifsWhereUniqueInput[]
    connect?: PreventifsWhereUniqueInput | PreventifsWhereUniqueInput[]
    update?: PreventifsUpdateWithWhereUniqueWithoutLawyerInput | PreventifsUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: PreventifsUpdateManyWithWhereWithoutLawyerInput | PreventifsUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: PreventifsScalarWhereInput | PreventifsScalarWhereInput[]
  }

  export type ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput = {
    create?: XOR<ValeurAjouterCreateWithoutLawyerInput, ValeurAjouterUncheckedCreateWithoutLawyerInput> | ValeurAjouterCreateWithoutLawyerInput[] | ValeurAjouterUncheckedCreateWithoutLawyerInput[]
    connectOrCreate?: ValeurAjouterCreateOrConnectWithoutLawyerInput | ValeurAjouterCreateOrConnectWithoutLawyerInput[]
    upsert?: ValeurAjouterUpsertWithWhereUniqueWithoutLawyerInput | ValeurAjouterUpsertWithWhereUniqueWithoutLawyerInput[]
    createMany?: ValeurAjouterCreateManyLawyerInputEnvelope
    set?: ValeurAjouterWhereUniqueInput | ValeurAjouterWhereUniqueInput[]
    disconnect?: ValeurAjouterWhereUniqueInput | ValeurAjouterWhereUniqueInput[]
    delete?: ValeurAjouterWhereUniqueInput | ValeurAjouterWhereUniqueInput[]
    connect?: ValeurAjouterWhereUniqueInput | ValeurAjouterWhereUniqueInput[]
    update?: ValeurAjouterUpdateWithWhereUniqueWithoutLawyerInput | ValeurAjouterUpdateWithWhereUniqueWithoutLawyerInput[]
    updateMany?: ValeurAjouterUpdateManyWithWhereWithoutLawyerInput | ValeurAjouterUpdateManyWithWhereWithoutLawyerInput[]
    deleteMany?: ValeurAjouterScalarWhereInput | ValeurAjouterScalarWhereInput[]
  }

  export type LawyerCreateNestedOneWithoutConseilInput = {
    create?: XOR<LawyerCreateWithoutConseilInput, LawyerUncheckedCreateWithoutConseilInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutConseilInput
    connect?: LawyerWhereUniqueInput
  }

  export type LawyerUpdateOneRequiredWithoutConseilNestedInput = {
    create?: XOR<LawyerCreateWithoutConseilInput, LawyerUncheckedCreateWithoutConseilInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutConseilInput
    upsert?: LawyerUpsertWithoutConseilInput
    connect?: LawyerWhereUniqueInput
    update?: XOR<XOR<LawyerUpdateToOneWithWhereWithoutConseilInput, LawyerUpdateWithoutConseilInput>, LawyerUncheckedUpdateWithoutConseilInput>
  }

  export type LawyerCreateNestedOneWithoutRedactionInput = {
    create?: XOR<LawyerCreateWithoutRedactionInput, LawyerUncheckedCreateWithoutRedactionInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutRedactionInput
    connect?: LawyerWhereUniqueInput
  }

  export type LawyerUpdateOneRequiredWithoutRedactionNestedInput = {
    create?: XOR<LawyerCreateWithoutRedactionInput, LawyerUncheckedCreateWithoutRedactionInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutRedactionInput
    upsert?: LawyerUpsertWithoutRedactionInput
    connect?: LawyerWhereUniqueInput
    update?: XOR<XOR<LawyerUpdateToOneWithWhereWithoutRedactionInput, LawyerUpdateWithoutRedactionInput>, LawyerUncheckedUpdateWithoutRedactionInput>
  }

  export type LawyerCreateNestedOneWithoutResolutionInput = {
    create?: XOR<LawyerCreateWithoutResolutionInput, LawyerUncheckedCreateWithoutResolutionInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutResolutionInput
    connect?: LawyerWhereUniqueInput
  }

  export type LawyerUpdateOneRequiredWithoutResolutionNestedInput = {
    create?: XOR<LawyerCreateWithoutResolutionInput, LawyerUncheckedCreateWithoutResolutionInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutResolutionInput
    upsert?: LawyerUpsertWithoutResolutionInput
    connect?: LawyerWhereUniqueInput
    update?: XOR<XOR<LawyerUpdateToOneWithWhereWithoutResolutionInput, LawyerUpdateWithoutResolutionInput>, LawyerUncheckedUpdateWithoutResolutionInput>
  }

  export type LawyerCreateNestedOneWithoutServicesInput = {
    create?: XOR<LawyerCreateWithoutServicesInput, LawyerUncheckedCreateWithoutServicesInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutServicesInput
    connect?: LawyerWhereUniqueInput
  }

  export type LawyerUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<LawyerCreateWithoutServicesInput, LawyerUncheckedCreateWithoutServicesInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutServicesInput
    upsert?: LawyerUpsertWithoutServicesInput
    connect?: LawyerWhereUniqueInput
    update?: XOR<XOR<LawyerUpdateToOneWithWhereWithoutServicesInput, LawyerUpdateWithoutServicesInput>, LawyerUncheckedUpdateWithoutServicesInput>
  }

  export type LawyerCreateNestedOneWithoutPreventifsInput = {
    create?: XOR<LawyerCreateWithoutPreventifsInput, LawyerUncheckedCreateWithoutPreventifsInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutPreventifsInput
    connect?: LawyerWhereUniqueInput
  }

  export type LawyerUpdateOneRequiredWithoutPreventifsNestedInput = {
    create?: XOR<LawyerCreateWithoutPreventifsInput, LawyerUncheckedCreateWithoutPreventifsInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutPreventifsInput
    upsert?: LawyerUpsertWithoutPreventifsInput
    connect?: LawyerWhereUniqueInput
    update?: XOR<XOR<LawyerUpdateToOneWithWhereWithoutPreventifsInput, LawyerUpdateWithoutPreventifsInput>, LawyerUncheckedUpdateWithoutPreventifsInput>
  }

  export type LawyerCreateNestedOneWithoutValuerInput = {
    create?: XOR<LawyerCreateWithoutValuerInput, LawyerUncheckedCreateWithoutValuerInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutValuerInput
    connect?: LawyerWhereUniqueInput
  }

  export type LawyerUpdateOneRequiredWithoutValuerNestedInput = {
    create?: XOR<LawyerCreateWithoutValuerInput, LawyerUncheckedCreateWithoutValuerInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutValuerInput
    upsert?: LawyerUpsertWithoutValuerInput
    connect?: LawyerWhereUniqueInput
    update?: XOR<XOR<LawyerUpdateToOneWithWhereWithoutValuerInput, LawyerUpdateWithoutValuerInput>, LawyerUncheckedUpdateWithoutValuerInput>
  }

  export type ClientCreateNestedOneWithoutFriendInput = {
    create?: XOR<ClientCreateWithoutFriendInput, ClientUncheckedCreateWithoutFriendInput>
    connectOrCreate?: ClientCreateOrConnectWithoutFriendInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutFriendNestedInput = {
    create?: XOR<ClientCreateWithoutFriendInput, ClientUncheckedCreateWithoutFriendInput>
    connectOrCreate?: ClientCreateOrConnectWithoutFriendInput
    upsert?: ClientUpsertWithoutFriendInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutFriendInput, ClientUpdateWithoutFriendInput>, ClientUncheckedUpdateWithoutFriendInput>
  }

  export type LawyerCreateNestedOneWithoutFriendLawInput = {
    create?: XOR<LawyerCreateWithoutFriendLawInput, LawyerUncheckedCreateWithoutFriendLawInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutFriendLawInput
    connect?: LawyerWhereUniqueInput
  }

  export type LawyerUpdateOneRequiredWithoutFriendLawNestedInput = {
    create?: XOR<LawyerCreateWithoutFriendLawInput, LawyerUncheckedCreateWithoutFriendLawInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutFriendLawInput
    upsert?: LawyerUpsertWithoutFriendLawInput
    connect?: LawyerWhereUniqueInput
    update?: XOR<XOR<LawyerUpdateToOneWithWhereWithoutFriendLawInput, LawyerUpdateWithoutFriendLawInput>, LawyerUncheckedUpdateWithoutFriendLawInput>
  }

  export type LawyerCreateNestedOneWithoutContratInput = {
    create?: XOR<LawyerCreateWithoutContratInput, LawyerUncheckedCreateWithoutContratInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutContratInput
    connect?: LawyerWhereUniqueInput
  }

  export type LawyerUpdateOneRequiredWithoutContratNestedInput = {
    create?: XOR<LawyerCreateWithoutContratInput, LawyerUncheckedCreateWithoutContratInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutContratInput
    upsert?: LawyerUpsertWithoutContratInput
    connect?: LawyerWhereUniqueInput
    update?: XOR<XOR<LawyerUpdateToOneWithWhereWithoutContratInput, LawyerUpdateWithoutContratInput>, LawyerUncheckedUpdateWithoutContratInput>
  }

  export type LawyerCreateNestedOneWithoutNotificationInput = {
    create?: XOR<LawyerCreateWithoutNotificationInput, LawyerUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutNotificationInput
    connect?: LawyerWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type LawyerUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<LawyerCreateWithoutNotificationInput, LawyerUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutNotificationInput
    upsert?: LawyerUpsertWithoutNotificationInput
    disconnect?: LawyerWhereInput | boolean
    delete?: LawyerWhereInput | boolean
    connect?: LawyerWhereUniqueInput
    update?: XOR<XOR<LawyerUpdateToOneWithWhereWithoutNotificationInput, LawyerUpdateWithoutNotificationInput>, LawyerUncheckedUpdateWithoutNotificationInput>
  }

  export type ClientCreateNestedOneWithoutNotificationInput = {
    create?: XOR<ClientCreateWithoutNotificationInput, ClientUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: ClientCreateOrConnectWithoutNotificationInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<ClientCreateWithoutNotificationInput, ClientUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: ClientCreateOrConnectWithoutNotificationInput
    upsert?: ClientUpsertWithoutNotificationInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutNotificationInput, ClientUpdateWithoutNotificationInput>, ClientUncheckedUpdateWithoutNotificationInput>
  }

  export type LawyerCreateNestedOneWithoutContactInput = {
    create?: XOR<LawyerCreateWithoutContactInput, LawyerUncheckedCreateWithoutContactInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutContactInput
    connect?: LawyerWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type LawyerUpdateOneWithoutContactNestedInput = {
    create?: XOR<LawyerCreateWithoutContactInput, LawyerUncheckedCreateWithoutContactInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutContactInput
    upsert?: LawyerUpsertWithoutContactInput
    disconnect?: LawyerWhereInput | boolean
    delete?: LawyerWhereInput | boolean
    connect?: LawyerWhereUniqueInput
    update?: XOR<XOR<LawyerUpdateToOneWithWhereWithoutContactInput, LawyerUpdateWithoutContactInput>, LawyerUncheckedUpdateWithoutContactInput>
  }

  export type ClientCreateNestedOneWithoutClientInput = {
    create?: XOR<ClientCreateWithoutClientInput, ClientUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneWithoutClientNestedInput = {
    create?: XOR<ClientCreateWithoutClientInput, ClientUncheckedCreateWithoutClientInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientInput
    upsert?: ClientUpsertWithoutClientInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientInput, ClientUpdateWithoutClientInput>, ClientUncheckedUpdateWithoutClientInput>
  }

  export type LawyerCreateNestedOneWithoutDiplomeInput = {
    create?: XOR<LawyerCreateWithoutDiplomeInput, LawyerUncheckedCreateWithoutDiplomeInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutDiplomeInput
    connect?: LawyerWhereUniqueInput
  }

  export type LawyerUpdateOneWithoutDiplomeNestedInput = {
    create?: XOR<LawyerCreateWithoutDiplomeInput, LawyerUncheckedCreateWithoutDiplomeInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutDiplomeInput
    upsert?: LawyerUpsertWithoutDiplomeInput
    disconnect?: LawyerWhereInput | boolean
    delete?: LawyerWhereInput | boolean
    connect?: LawyerWhereUniqueInput
    update?: XOR<XOR<LawyerUpdateToOneWithWhereWithoutDiplomeInput, LawyerUpdateWithoutDiplomeInput>, LawyerUncheckedUpdateWithoutDiplomeInput>
  }

  export type LawyerCreateNestedOneWithoutExperienceInput = {
    create?: XOR<LawyerCreateWithoutExperienceInput, LawyerUncheckedCreateWithoutExperienceInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutExperienceInput
    connect?: LawyerWhereUniqueInput
  }

  export type LawyerUpdateOneWithoutExperienceNestedInput = {
    create?: XOR<LawyerCreateWithoutExperienceInput, LawyerUncheckedCreateWithoutExperienceInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutExperienceInput
    upsert?: LawyerUpsertWithoutExperienceInput
    disconnect?: LawyerWhereInput | boolean
    delete?: LawyerWhereInput | boolean
    connect?: LawyerWhereUniqueInput
    update?: XOR<XOR<LawyerUpdateToOneWithWhereWithoutExperienceInput, LawyerUpdateWithoutExperienceInput>, LawyerUncheckedUpdateWithoutExperienceInput>
  }

  export type LawyerCreateNestedOneWithoutCalendarInput = {
    create?: XOR<LawyerCreateWithoutCalendarInput, LawyerUncheckedCreateWithoutCalendarInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutCalendarInput
    connect?: LawyerWhereUniqueInput
  }

  export type LawyerUpdateOneWithoutCalendarNestedInput = {
    create?: XOR<LawyerCreateWithoutCalendarInput, LawyerUncheckedCreateWithoutCalendarInput>
    connectOrCreate?: LawyerCreateOrConnectWithoutCalendarInput
    upsert?: LawyerUpsertWithoutCalendarInput
    disconnect?: LawyerWhereInput | boolean
    delete?: LawyerWhereInput | boolean
    connect?: LawyerWhereUniqueInput
    update?: XOR<XOR<LawyerUpdateToOneWithWhereWithoutCalendarInput, LawyerUpdateWithoutCalendarInput>, LawyerUncheckedUpdateWithoutCalendarInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ClientCreateWithoutUserInput = {
    id?: string
    name: string
    profession: string
    age: number
    gender: string
    localisation: string
    friend?: FriendsCreateNestedManyWithoutClientInput
    notification?: ClientNotificationCreateNestedManyWithoutClientInput
    client?: ClientContactCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    profession: string
    age: number
    gender: string
    localisation: string
    friend?: FriendsUncheckedCreateNestedManyWithoutClientInput
    notification?: ClientNotificationUncheckedCreateNestedManyWithoutClientInput
    client?: ClientContactUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUserInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type ClientCreateManyUserInputEnvelope = {
    data: ClientCreateManyUserInput | ClientCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LawyerCreateWithoutUserInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutUserInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutUserInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutUserInput, LawyerUncheckedCreateWithoutUserInput>
  }

  export type LawyerCreateManyUserInputEnvelope = {
    data: LawyerCreateManyUserInput | LawyerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutCreatedByInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUncheckedCreateWithoutCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutCreatedByInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCreatedByInput, PostUncheckedCreateWithoutCreatedByInput>
  }

  export type PostCreateManyCreatedByInputEnvelope = {
    data: PostCreateManyCreatedByInput | PostCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithWhereUniqueWithoutUserInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
    create: XOR<ClientCreateWithoutUserInput, ClientUncheckedCreateWithoutUserInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutUserInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutUserInput, ClientUncheckedUpdateWithoutUserInput>
  }

  export type ClientUpdateManyWithWhereWithoutUserInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutUserInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    userId?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    profession?: StringFilter<"Client"> | string
    age?: IntFilter<"Client"> | number
    gender?: StringFilter<"Client"> | string
    localisation?: StringFilter<"Client"> | string
  }

  export type LawyerUpsertWithWhereUniqueWithoutUserInput = {
    where: LawyerWhereUniqueInput
    update: XOR<LawyerUpdateWithoutUserInput, LawyerUncheckedUpdateWithoutUserInput>
    create: XOR<LawyerCreateWithoutUserInput, LawyerUncheckedCreateWithoutUserInput>
  }

  export type LawyerUpdateWithWhereUniqueWithoutUserInput = {
    where: LawyerWhereUniqueInput
    data: XOR<LawyerUpdateWithoutUserInput, LawyerUncheckedUpdateWithoutUserInput>
  }

  export type LawyerUpdateManyWithWhereWithoutUserInput = {
    where: LawyerScalarWhereInput
    data: XOR<LawyerUpdateManyMutationInput, LawyerUncheckedUpdateManyWithoutUserInput>
  }

  export type LawyerScalarWhereInput = {
    AND?: LawyerScalarWhereInput | LawyerScalarWhereInput[]
    OR?: LawyerScalarWhereInput[]
    NOT?: LawyerScalarWhereInput | LawyerScalarWhereInput[]
    id?: StringFilter<"Lawyer"> | string
    userId?: StringFilter<"Lawyer"> | string
    name?: StringNullableFilter<"Lawyer"> | string | null
    age?: IntNullableFilter<"Lawyer"> | number | null
    localisation?: StringNullableFilter<"Lawyer"> | string | null
    budget?: StringNullableFilter<"Lawyer"> | string | null
    gender?: StringNullableFilter<"Lawyer"> | string | null
    specialité?: StringNullableFilter<"Lawyer"> | string | null
    Star?: IntNullableFilter<"Lawyer"> | number | null
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableFilter<"Account"> | number | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type PostUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutCreatedByInput, PostUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PostCreateWithoutCreatedByInput, PostUncheckedCreateWithoutCreatedByInput>
  }

  export type PostUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutCreatedByInput, PostUncheckedUpdateWithoutCreatedByInput>
  }

  export type PostUpdateManyWithWhereWithoutCreatedByInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: IntFilter<"Post"> | number
    name?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    createdById?: StringFilter<"Post"> | string
  }

  export type FriendsCreateWithoutClientInput = {
    id?: string
    name: string
    nbrDeContrat: string
    key: string
  }

  export type FriendsUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    nbrDeContrat: string
    key: string
  }

  export type FriendsCreateOrConnectWithoutClientInput = {
    where: FriendsWhereUniqueInput
    create: XOR<FriendsCreateWithoutClientInput, FriendsUncheckedCreateWithoutClientInput>
  }

  export type FriendsCreateManyClientInputEnvelope = {
    data: FriendsCreateManyClientInput | FriendsCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientNotificationCreateWithoutClientInput = {
    id?: string
    content?: string | null
    TimeToReceive?: Date | string | null
    vue?: boolean | null
    type: string
    key: string
  }

  export type ClientNotificationUncheckedCreateWithoutClientInput = {
    id?: string
    content?: string | null
    TimeToReceive?: Date | string | null
    vue?: boolean | null
    type: string
    key: string
  }

  export type ClientNotificationCreateOrConnectWithoutClientInput = {
    where: ClientNotificationWhereUniqueInput
    create: XOR<ClientNotificationCreateWithoutClientInput, ClientNotificationUncheckedCreateWithoutClientInput>
  }

  export type ClientNotificationCreateManyClientInputEnvelope = {
    data: ClientNotificationCreateManyClientInput | ClientNotificationCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientContactCreateWithoutClientInput = {
    id?: string
    name: string
    contenu: string
    date?: Date | string
    key: string
  }

  export type ClientContactUncheckedCreateWithoutClientInput = {
    id?: string
    name: string
    contenu: string
    date?: Date | string
    key: string
  }

  export type ClientContactCreateOrConnectWithoutClientInput = {
    where: ClientContactWhereUniqueInput
    create: XOR<ClientContactCreateWithoutClientInput, ClientContactUncheckedCreateWithoutClientInput>
  }

  export type ClientContactCreateManyClientInputEnvelope = {
    data: ClientContactCreateManyClientInput | ClientContactCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutClientInput = {
    id?: string
    email: string
    password: string
    role: string
    emailVerified?: Date | string | null
    image?: string | null
    lawyer?: LawyerCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutClientInput = {
    id?: string
    email: string
    password: string
    role: string
    emailVerified?: Date | string | null
    image?: string | null
    lawyer?: LawyerUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type FriendsUpsertWithWhereUniqueWithoutClientInput = {
    where: FriendsWhereUniqueInput
    update: XOR<FriendsUpdateWithoutClientInput, FriendsUncheckedUpdateWithoutClientInput>
    create: XOR<FriendsCreateWithoutClientInput, FriendsUncheckedCreateWithoutClientInput>
  }

  export type FriendsUpdateWithWhereUniqueWithoutClientInput = {
    where: FriendsWhereUniqueInput
    data: XOR<FriendsUpdateWithoutClientInput, FriendsUncheckedUpdateWithoutClientInput>
  }

  export type FriendsUpdateManyWithWhereWithoutClientInput = {
    where: FriendsScalarWhereInput
    data: XOR<FriendsUpdateManyMutationInput, FriendsUncheckedUpdateManyWithoutClientInput>
  }

  export type FriendsScalarWhereInput = {
    AND?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
    OR?: FriendsScalarWhereInput[]
    NOT?: FriendsScalarWhereInput | FriendsScalarWhereInput[]
    id?: StringFilter<"Friends"> | string
    userId?: StringFilter<"Friends"> | string
    name?: StringFilter<"Friends"> | string
    nbrDeContrat?: StringFilter<"Friends"> | string
    key?: StringFilter<"Friends"> | string
  }

  export type ClientNotificationUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientNotificationWhereUniqueInput
    update: XOR<ClientNotificationUpdateWithoutClientInput, ClientNotificationUncheckedUpdateWithoutClientInput>
    create: XOR<ClientNotificationCreateWithoutClientInput, ClientNotificationUncheckedCreateWithoutClientInput>
  }

  export type ClientNotificationUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientNotificationWhereUniqueInput
    data: XOR<ClientNotificationUpdateWithoutClientInput, ClientNotificationUncheckedUpdateWithoutClientInput>
  }

  export type ClientNotificationUpdateManyWithWhereWithoutClientInput = {
    where: ClientNotificationScalarWhereInput
    data: XOR<ClientNotificationUpdateManyMutationInput, ClientNotificationUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientNotificationScalarWhereInput = {
    AND?: ClientNotificationScalarWhereInput | ClientNotificationScalarWhereInput[]
    OR?: ClientNotificationScalarWhereInput[]
    NOT?: ClientNotificationScalarWhereInput | ClientNotificationScalarWhereInput[]
    id?: StringFilter<"ClientNotification"> | string
    userId?: StringFilter<"ClientNotification"> | string
    content?: StringNullableFilter<"ClientNotification"> | string | null
    TimeToReceive?: DateTimeNullableFilter<"ClientNotification"> | Date | string | null
    vue?: BoolNullableFilter<"ClientNotification"> | boolean | null
    type?: StringFilter<"ClientNotification"> | string
    key?: StringFilter<"ClientNotification"> | string
  }

  export type ClientContactUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientContactWhereUniqueInput
    update: XOR<ClientContactUpdateWithoutClientInput, ClientContactUncheckedUpdateWithoutClientInput>
    create: XOR<ClientContactCreateWithoutClientInput, ClientContactUncheckedCreateWithoutClientInput>
  }

  export type ClientContactUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientContactWhereUniqueInput
    data: XOR<ClientContactUpdateWithoutClientInput, ClientContactUncheckedUpdateWithoutClientInput>
  }

  export type ClientContactUpdateManyWithWhereWithoutClientInput = {
    where: ClientContactScalarWhereInput
    data: XOR<ClientContactUpdateManyMutationInput, ClientContactUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientContactScalarWhereInput = {
    AND?: ClientContactScalarWhereInput | ClientContactScalarWhereInput[]
    OR?: ClientContactScalarWhereInput[]
    NOT?: ClientContactScalarWhereInput | ClientContactScalarWhereInput[]
    id?: StringFilter<"ClientContact"> | string
    userId?: StringFilter<"ClientContact"> | string
    name?: StringFilter<"ClientContact"> | string
    contenu?: StringFilter<"ClientContact"> | string
    date?: DateTimeFilter<"ClientContact"> | Date | string
    key?: StringFilter<"ClientContact"> | string
  }

  export type UserUpsertWithoutClientInput = {
    update: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
  }

  export type UserUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer?: LawyerUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer?: LawyerUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type DiplomeCreateWithoutLawyerInput = {
    id?: string
    ecole: string
    anne: string
    nom: string
  }

  export type DiplomeUncheckedCreateWithoutLawyerInput = {
    id?: string
    ecole: string
    anne: string
    nom: string
  }

  export type DiplomeCreateOrConnectWithoutLawyerInput = {
    where: DiplomeWhereUniqueInput
    create: XOR<DiplomeCreateWithoutLawyerInput, DiplomeUncheckedCreateWithoutLawyerInput>
  }

  export type DiplomeCreateManyLawyerInputEnvelope = {
    data: DiplomeCreateManyLawyerInput | DiplomeCreateManyLawyerInput[]
    skipDuplicates?: boolean
  }

  export type ExperienceCreateWithoutLawyerInput = {
    id?: string
    poste: string
    durant: string
  }

  export type ExperienceUncheckedCreateWithoutLawyerInput = {
    id?: string
    poste: string
    durant: string
  }

  export type ExperienceCreateOrConnectWithoutLawyerInput = {
    where: ExperienceWhereUniqueInput
    create: XOR<ExperienceCreateWithoutLawyerInput, ExperienceUncheckedCreateWithoutLawyerInput>
  }

  export type ExperienceCreateManyLawyerInputEnvelope = {
    data: ExperienceCreateManyLawyerInput | ExperienceCreateManyLawyerInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutLawyerInput = {
    id?: string
    content?: string | null
    TimeToReceive?: Date | string | null
    vue?: boolean | null
    type: string
    key?: string | null
  }

  export type NotificationUncheckedCreateWithoutLawyerInput = {
    id?: string
    content?: string | null
    TimeToReceive?: Date | string | null
    vue?: boolean | null
    type: string
    key?: string | null
  }

  export type NotificationCreateOrConnectWithoutLawyerInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutLawyerInput, NotificationUncheckedCreateWithoutLawyerInput>
  }

  export type NotificationCreateManyLawyerInputEnvelope = {
    data: NotificationCreateManyLawyerInput | NotificationCreateManyLawyerInput[]
    skipDuplicates?: boolean
  }

  export type ContratCreateWithoutLawyerInput = {
    id?: string
    type?: string | null
    date?: Date | string | null
    content?: string | null
  }

  export type ContratUncheckedCreateWithoutLawyerInput = {
    id?: string
    type?: string | null
    date?: Date | string | null
    content?: string | null
  }

  export type ContratCreateOrConnectWithoutLawyerInput = {
    where: ContratWhereUniqueInput
    create: XOR<ContratCreateWithoutLawyerInput, ContratUncheckedCreateWithoutLawyerInput>
  }

  export type ContratCreateManyLawyerInputEnvelope = {
    data: ContratCreateManyLawyerInput | ContratCreateManyLawyerInput[]
    skipDuplicates?: boolean
  }

  export type CalendarCreateWithoutLawyerInput = {
    id?: string
    client: string
    moment: Date | string
  }

  export type CalendarUncheckedCreateWithoutLawyerInput = {
    id?: string
    client: string
    moment: Date | string
  }

  export type CalendarCreateOrConnectWithoutLawyerInput = {
    where: CalendarWhereUniqueInput
    create: XOR<CalendarCreateWithoutLawyerInput, CalendarUncheckedCreateWithoutLawyerInput>
  }

  export type CalendarCreateManyLawyerInputEnvelope = {
    data: CalendarCreateManyLawyerInput | CalendarCreateManyLawyerInput[]
    skipDuplicates?: boolean
  }

  export type FriendLawCreateWithoutLawyerInput = {
    id?: string
    name: string
    nbrDeContrat: string
    key: string
  }

  export type FriendLawUncheckedCreateWithoutLawyerInput = {
    id?: string
    name: string
    nbrDeContrat: string
    key: string
  }

  export type FriendLawCreateOrConnectWithoutLawyerInput = {
    where: FriendLawWhereUniqueInput
    create: XOR<FriendLawCreateWithoutLawyerInput, FriendLawUncheckedCreateWithoutLawyerInput>
  }

  export type FriendLawCreateManyLawyerInputEnvelope = {
    data: FriendLawCreateManyLawyerInput | FriendLawCreateManyLawyerInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutLawyerInput = {
    id?: string
    name: string
    contenu: string
    date?: Date | string
    key: string
  }

  export type ContactUncheckedCreateWithoutLawyerInput = {
    id?: string
    name: string
    contenu: string
    date?: Date | string
    key: string
  }

  export type ContactCreateOrConnectWithoutLawyerInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutLawyerInput, ContactUncheckedCreateWithoutLawyerInput>
  }

  export type ContactCreateManyLawyerInputEnvelope = {
    data: ContactCreateManyLawyerInput | ContactCreateManyLawyerInput[]
    skipDuplicates?: boolean
  }

  export type ConseilJuridiqueCreateWithoutLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type ConseilJuridiqueUncheckedCreateWithoutLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type ConseilJuridiqueCreateOrConnectWithoutLawyerInput = {
    where: ConseilJuridiqueWhereUniqueInput
    create: XOR<ConseilJuridiqueCreateWithoutLawyerInput, ConseilJuridiqueUncheckedCreateWithoutLawyerInput>
  }

  export type ConseilJuridiqueCreateManyLawyerInputEnvelope = {
    data: ConseilJuridiqueCreateManyLawyerInput | ConseilJuridiqueCreateManyLawyerInput[]
    skipDuplicates?: boolean
  }

  export type RedactionCreateWithoutLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type RedactionUncheckedCreateWithoutLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type RedactionCreateOrConnectWithoutLawyerInput = {
    where: RedactionWhereUniqueInput
    create: XOR<RedactionCreateWithoutLawyerInput, RedactionUncheckedCreateWithoutLawyerInput>
  }

  export type RedactionCreateManyLawyerInputEnvelope = {
    data: RedactionCreateManyLawyerInput | RedactionCreateManyLawyerInput[]
    skipDuplicates?: boolean
  }

  export type ResolutionLitigeCreateWithoutLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type ResolutionLitigeUncheckedCreateWithoutLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type ResolutionLitigeCreateOrConnectWithoutLawyerInput = {
    where: ResolutionLitigeWhereUniqueInput
    create: XOR<ResolutionLitigeCreateWithoutLawyerInput, ResolutionLitigeUncheckedCreateWithoutLawyerInput>
  }

  export type ResolutionLitigeCreateManyLawyerInputEnvelope = {
    data: ResolutionLitigeCreateManyLawyerInput | ResolutionLitigeCreateManyLawyerInput[]
    skipDuplicates?: boolean
  }

  export type ServiceParDomaineCreateWithoutLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type ServiceParDomaineUncheckedCreateWithoutLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type ServiceParDomaineCreateOrConnectWithoutLawyerInput = {
    where: ServiceParDomaineWhereUniqueInput
    create: XOR<ServiceParDomaineCreateWithoutLawyerInput, ServiceParDomaineUncheckedCreateWithoutLawyerInput>
  }

  export type ServiceParDomaineCreateManyLawyerInputEnvelope = {
    data: ServiceParDomaineCreateManyLawyerInput | ServiceParDomaineCreateManyLawyerInput[]
    skipDuplicates?: boolean
  }

  export type PreventifsCreateWithoutLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type PreventifsUncheckedCreateWithoutLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type PreventifsCreateOrConnectWithoutLawyerInput = {
    where: PreventifsWhereUniqueInput
    create: XOR<PreventifsCreateWithoutLawyerInput, PreventifsUncheckedCreateWithoutLawyerInput>
  }

  export type PreventifsCreateManyLawyerInputEnvelope = {
    data: PreventifsCreateManyLawyerInput | PreventifsCreateManyLawyerInput[]
    skipDuplicates?: boolean
  }

  export type ValeurAjouterCreateWithoutLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type ValeurAjouterUncheckedCreateWithoutLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type ValeurAjouterCreateOrConnectWithoutLawyerInput = {
    where: ValeurAjouterWhereUniqueInput
    create: XOR<ValeurAjouterCreateWithoutLawyerInput, ValeurAjouterUncheckedCreateWithoutLawyerInput>
  }

  export type ValeurAjouterCreateManyLawyerInputEnvelope = {
    data: ValeurAjouterCreateManyLawyerInput | ValeurAjouterCreateManyLawyerInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutLawyerInput = {
    id?: string
    email: string
    password: string
    role: string
    emailVerified?: Date | string | null
    image?: string | null
    client?: ClientCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutLawyerInput = {
    id?: string
    email: string
    password: string
    role: string
    emailVerified?: Date | string | null
    image?: string | null
    client?: ClientUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutLawyerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLawyerInput, UserUncheckedCreateWithoutLawyerInput>
  }

  export type DiplomeUpsertWithWhereUniqueWithoutLawyerInput = {
    where: DiplomeWhereUniqueInput
    update: XOR<DiplomeUpdateWithoutLawyerInput, DiplomeUncheckedUpdateWithoutLawyerInput>
    create: XOR<DiplomeCreateWithoutLawyerInput, DiplomeUncheckedCreateWithoutLawyerInput>
  }

  export type DiplomeUpdateWithWhereUniqueWithoutLawyerInput = {
    where: DiplomeWhereUniqueInput
    data: XOR<DiplomeUpdateWithoutLawyerInput, DiplomeUncheckedUpdateWithoutLawyerInput>
  }

  export type DiplomeUpdateManyWithWhereWithoutLawyerInput = {
    where: DiplomeScalarWhereInput
    data: XOR<DiplomeUpdateManyMutationInput, DiplomeUncheckedUpdateManyWithoutLawyerInput>
  }

  export type DiplomeScalarWhereInput = {
    AND?: DiplomeScalarWhereInput | DiplomeScalarWhereInput[]
    OR?: DiplomeScalarWhereInput[]
    NOT?: DiplomeScalarWhereInput | DiplomeScalarWhereInput[]
    id?: StringFilter<"Diplome"> | string
    userId?: StringFilter<"Diplome"> | string
    ecole?: StringFilter<"Diplome"> | string
    anne?: StringFilter<"Diplome"> | string
    nom?: StringFilter<"Diplome"> | string
  }

  export type ExperienceUpsertWithWhereUniqueWithoutLawyerInput = {
    where: ExperienceWhereUniqueInput
    update: XOR<ExperienceUpdateWithoutLawyerInput, ExperienceUncheckedUpdateWithoutLawyerInput>
    create: XOR<ExperienceCreateWithoutLawyerInput, ExperienceUncheckedCreateWithoutLawyerInput>
  }

  export type ExperienceUpdateWithWhereUniqueWithoutLawyerInput = {
    where: ExperienceWhereUniqueInput
    data: XOR<ExperienceUpdateWithoutLawyerInput, ExperienceUncheckedUpdateWithoutLawyerInput>
  }

  export type ExperienceUpdateManyWithWhereWithoutLawyerInput = {
    where: ExperienceScalarWhereInput
    data: XOR<ExperienceUpdateManyMutationInput, ExperienceUncheckedUpdateManyWithoutLawyerInput>
  }

  export type ExperienceScalarWhereInput = {
    AND?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
    OR?: ExperienceScalarWhereInput[]
    NOT?: ExperienceScalarWhereInput | ExperienceScalarWhereInput[]
    id?: StringFilter<"Experience"> | string
    userId?: StringFilter<"Experience"> | string
    poste?: StringFilter<"Experience"> | string
    durant?: StringFilter<"Experience"> | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutLawyerInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutLawyerInput, NotificationUncheckedUpdateWithoutLawyerInput>
    create: XOR<NotificationCreateWithoutLawyerInput, NotificationUncheckedCreateWithoutLawyerInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutLawyerInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutLawyerInput, NotificationUncheckedUpdateWithoutLawyerInput>
  }

  export type NotificationUpdateManyWithWhereWithoutLawyerInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutLawyerInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    content?: StringNullableFilter<"Notification"> | string | null
    TimeToReceive?: DateTimeNullableFilter<"Notification"> | Date | string | null
    vue?: BoolNullableFilter<"Notification"> | boolean | null
    type?: StringFilter<"Notification"> | string
    key?: StringNullableFilter<"Notification"> | string | null
  }

  export type ContratUpsertWithWhereUniqueWithoutLawyerInput = {
    where: ContratWhereUniqueInput
    update: XOR<ContratUpdateWithoutLawyerInput, ContratUncheckedUpdateWithoutLawyerInput>
    create: XOR<ContratCreateWithoutLawyerInput, ContratUncheckedCreateWithoutLawyerInput>
  }

  export type ContratUpdateWithWhereUniqueWithoutLawyerInput = {
    where: ContratWhereUniqueInput
    data: XOR<ContratUpdateWithoutLawyerInput, ContratUncheckedUpdateWithoutLawyerInput>
  }

  export type ContratUpdateManyWithWhereWithoutLawyerInput = {
    where: ContratScalarWhereInput
    data: XOR<ContratUpdateManyMutationInput, ContratUncheckedUpdateManyWithoutLawyerInput>
  }

  export type ContratScalarWhereInput = {
    AND?: ContratScalarWhereInput | ContratScalarWhereInput[]
    OR?: ContratScalarWhereInput[]
    NOT?: ContratScalarWhereInput | ContratScalarWhereInput[]
    id?: StringFilter<"Contrat"> | string
    userId?: StringFilter<"Contrat"> | string
    type?: StringNullableFilter<"Contrat"> | string | null
    date?: DateTimeNullableFilter<"Contrat"> | Date | string | null
    content?: StringNullableFilter<"Contrat"> | string | null
  }

  export type CalendarUpsertWithWhereUniqueWithoutLawyerInput = {
    where: CalendarWhereUniqueInput
    update: XOR<CalendarUpdateWithoutLawyerInput, CalendarUncheckedUpdateWithoutLawyerInput>
    create: XOR<CalendarCreateWithoutLawyerInput, CalendarUncheckedCreateWithoutLawyerInput>
  }

  export type CalendarUpdateWithWhereUniqueWithoutLawyerInput = {
    where: CalendarWhereUniqueInput
    data: XOR<CalendarUpdateWithoutLawyerInput, CalendarUncheckedUpdateWithoutLawyerInput>
  }

  export type CalendarUpdateManyWithWhereWithoutLawyerInput = {
    where: CalendarScalarWhereInput
    data: XOR<CalendarUpdateManyMutationInput, CalendarUncheckedUpdateManyWithoutLawyerInput>
  }

  export type CalendarScalarWhereInput = {
    AND?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
    OR?: CalendarScalarWhereInput[]
    NOT?: CalendarScalarWhereInput | CalendarScalarWhereInput[]
    id?: StringFilter<"Calendar"> | string
    userId?: StringFilter<"Calendar"> | string
    client?: StringFilter<"Calendar"> | string
    moment?: DateTimeFilter<"Calendar"> | Date | string
  }

  export type FriendLawUpsertWithWhereUniqueWithoutLawyerInput = {
    where: FriendLawWhereUniqueInput
    update: XOR<FriendLawUpdateWithoutLawyerInput, FriendLawUncheckedUpdateWithoutLawyerInput>
    create: XOR<FriendLawCreateWithoutLawyerInput, FriendLawUncheckedCreateWithoutLawyerInput>
  }

  export type FriendLawUpdateWithWhereUniqueWithoutLawyerInput = {
    where: FriendLawWhereUniqueInput
    data: XOR<FriendLawUpdateWithoutLawyerInput, FriendLawUncheckedUpdateWithoutLawyerInput>
  }

  export type FriendLawUpdateManyWithWhereWithoutLawyerInput = {
    where: FriendLawScalarWhereInput
    data: XOR<FriendLawUpdateManyMutationInput, FriendLawUncheckedUpdateManyWithoutLawyerInput>
  }

  export type FriendLawScalarWhereInput = {
    AND?: FriendLawScalarWhereInput | FriendLawScalarWhereInput[]
    OR?: FriendLawScalarWhereInput[]
    NOT?: FriendLawScalarWhereInput | FriendLawScalarWhereInput[]
    id?: StringFilter<"FriendLaw"> | string
    userId?: StringFilter<"FriendLaw"> | string
    name?: StringFilter<"FriendLaw"> | string
    nbrDeContrat?: StringFilter<"FriendLaw"> | string
    key?: StringFilter<"FriendLaw"> | string
  }

  export type ContactUpsertWithWhereUniqueWithoutLawyerInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutLawyerInput, ContactUncheckedUpdateWithoutLawyerInput>
    create: XOR<ContactCreateWithoutLawyerInput, ContactUncheckedCreateWithoutLawyerInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutLawyerInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutLawyerInput, ContactUncheckedUpdateWithoutLawyerInput>
  }

  export type ContactUpdateManyWithWhereWithoutLawyerInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutLawyerInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    userId?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    contenu?: StringFilter<"Contact"> | string
    date?: DateTimeFilter<"Contact"> | Date | string
    key?: StringFilter<"Contact"> | string
  }

  export type ConseilJuridiqueUpsertWithWhereUniqueWithoutLawyerInput = {
    where: ConseilJuridiqueWhereUniqueInput
    update: XOR<ConseilJuridiqueUpdateWithoutLawyerInput, ConseilJuridiqueUncheckedUpdateWithoutLawyerInput>
    create: XOR<ConseilJuridiqueCreateWithoutLawyerInput, ConseilJuridiqueUncheckedCreateWithoutLawyerInput>
  }

  export type ConseilJuridiqueUpdateWithWhereUniqueWithoutLawyerInput = {
    where: ConseilJuridiqueWhereUniqueInput
    data: XOR<ConseilJuridiqueUpdateWithoutLawyerInput, ConseilJuridiqueUncheckedUpdateWithoutLawyerInput>
  }

  export type ConseilJuridiqueUpdateManyWithWhereWithoutLawyerInput = {
    where: ConseilJuridiqueScalarWhereInput
    data: XOR<ConseilJuridiqueUpdateManyMutationInput, ConseilJuridiqueUncheckedUpdateManyWithoutLawyerInput>
  }

  export type ConseilJuridiqueScalarWhereInput = {
    AND?: ConseilJuridiqueScalarWhereInput | ConseilJuridiqueScalarWhereInput[]
    OR?: ConseilJuridiqueScalarWhereInput[]
    NOT?: ConseilJuridiqueScalarWhereInput | ConseilJuridiqueScalarWhereInput[]
    id?: StringFilter<"ConseilJuridique"> | string
    userId?: StringFilter<"ConseilJuridique"> | string
    title?: StringFilter<"ConseilJuridique"> | string
    content?: StringFilter<"ConseilJuridique"> | string
    desc?: StringFilter<"ConseilJuridique"> | string
  }

  export type RedactionUpsertWithWhereUniqueWithoutLawyerInput = {
    where: RedactionWhereUniqueInput
    update: XOR<RedactionUpdateWithoutLawyerInput, RedactionUncheckedUpdateWithoutLawyerInput>
    create: XOR<RedactionCreateWithoutLawyerInput, RedactionUncheckedCreateWithoutLawyerInput>
  }

  export type RedactionUpdateWithWhereUniqueWithoutLawyerInput = {
    where: RedactionWhereUniqueInput
    data: XOR<RedactionUpdateWithoutLawyerInput, RedactionUncheckedUpdateWithoutLawyerInput>
  }

  export type RedactionUpdateManyWithWhereWithoutLawyerInput = {
    where: RedactionScalarWhereInput
    data: XOR<RedactionUpdateManyMutationInput, RedactionUncheckedUpdateManyWithoutLawyerInput>
  }

  export type RedactionScalarWhereInput = {
    AND?: RedactionScalarWhereInput | RedactionScalarWhereInput[]
    OR?: RedactionScalarWhereInput[]
    NOT?: RedactionScalarWhereInput | RedactionScalarWhereInput[]
    id?: StringFilter<"Redaction"> | string
    userId?: StringFilter<"Redaction"> | string
    title?: StringFilter<"Redaction"> | string
    content?: StringFilter<"Redaction"> | string
    desc?: StringFilter<"Redaction"> | string
  }

  export type ResolutionLitigeUpsertWithWhereUniqueWithoutLawyerInput = {
    where: ResolutionLitigeWhereUniqueInput
    update: XOR<ResolutionLitigeUpdateWithoutLawyerInput, ResolutionLitigeUncheckedUpdateWithoutLawyerInput>
    create: XOR<ResolutionLitigeCreateWithoutLawyerInput, ResolutionLitigeUncheckedCreateWithoutLawyerInput>
  }

  export type ResolutionLitigeUpdateWithWhereUniqueWithoutLawyerInput = {
    where: ResolutionLitigeWhereUniqueInput
    data: XOR<ResolutionLitigeUpdateWithoutLawyerInput, ResolutionLitigeUncheckedUpdateWithoutLawyerInput>
  }

  export type ResolutionLitigeUpdateManyWithWhereWithoutLawyerInput = {
    where: ResolutionLitigeScalarWhereInput
    data: XOR<ResolutionLitigeUpdateManyMutationInput, ResolutionLitigeUncheckedUpdateManyWithoutLawyerInput>
  }

  export type ResolutionLitigeScalarWhereInput = {
    AND?: ResolutionLitigeScalarWhereInput | ResolutionLitigeScalarWhereInput[]
    OR?: ResolutionLitigeScalarWhereInput[]
    NOT?: ResolutionLitigeScalarWhereInput | ResolutionLitigeScalarWhereInput[]
    id?: StringFilter<"ResolutionLitige"> | string
    userId?: StringFilter<"ResolutionLitige"> | string
    title?: StringFilter<"ResolutionLitige"> | string
    content?: StringFilter<"ResolutionLitige"> | string
    desc?: StringFilter<"ResolutionLitige"> | string
  }

  export type ServiceParDomaineUpsertWithWhereUniqueWithoutLawyerInput = {
    where: ServiceParDomaineWhereUniqueInput
    update: XOR<ServiceParDomaineUpdateWithoutLawyerInput, ServiceParDomaineUncheckedUpdateWithoutLawyerInput>
    create: XOR<ServiceParDomaineCreateWithoutLawyerInput, ServiceParDomaineUncheckedCreateWithoutLawyerInput>
  }

  export type ServiceParDomaineUpdateWithWhereUniqueWithoutLawyerInput = {
    where: ServiceParDomaineWhereUniqueInput
    data: XOR<ServiceParDomaineUpdateWithoutLawyerInput, ServiceParDomaineUncheckedUpdateWithoutLawyerInput>
  }

  export type ServiceParDomaineUpdateManyWithWhereWithoutLawyerInput = {
    where: ServiceParDomaineScalarWhereInput
    data: XOR<ServiceParDomaineUpdateManyMutationInput, ServiceParDomaineUncheckedUpdateManyWithoutLawyerInput>
  }

  export type ServiceParDomaineScalarWhereInput = {
    AND?: ServiceParDomaineScalarWhereInput | ServiceParDomaineScalarWhereInput[]
    OR?: ServiceParDomaineScalarWhereInput[]
    NOT?: ServiceParDomaineScalarWhereInput | ServiceParDomaineScalarWhereInput[]
    id?: StringFilter<"ServiceParDomaine"> | string
    userId?: StringFilter<"ServiceParDomaine"> | string
    title?: StringFilter<"ServiceParDomaine"> | string
    content?: StringFilter<"ServiceParDomaine"> | string
    desc?: StringFilter<"ServiceParDomaine"> | string
  }

  export type PreventifsUpsertWithWhereUniqueWithoutLawyerInput = {
    where: PreventifsWhereUniqueInput
    update: XOR<PreventifsUpdateWithoutLawyerInput, PreventifsUncheckedUpdateWithoutLawyerInput>
    create: XOR<PreventifsCreateWithoutLawyerInput, PreventifsUncheckedCreateWithoutLawyerInput>
  }

  export type PreventifsUpdateWithWhereUniqueWithoutLawyerInput = {
    where: PreventifsWhereUniqueInput
    data: XOR<PreventifsUpdateWithoutLawyerInput, PreventifsUncheckedUpdateWithoutLawyerInput>
  }

  export type PreventifsUpdateManyWithWhereWithoutLawyerInput = {
    where: PreventifsScalarWhereInput
    data: XOR<PreventifsUpdateManyMutationInput, PreventifsUncheckedUpdateManyWithoutLawyerInput>
  }

  export type PreventifsScalarWhereInput = {
    AND?: PreventifsScalarWhereInput | PreventifsScalarWhereInput[]
    OR?: PreventifsScalarWhereInput[]
    NOT?: PreventifsScalarWhereInput | PreventifsScalarWhereInput[]
    id?: StringFilter<"Preventifs"> | string
    userId?: StringFilter<"Preventifs"> | string
    title?: StringFilter<"Preventifs"> | string
    content?: StringFilter<"Preventifs"> | string
    desc?: StringFilter<"Preventifs"> | string
  }

  export type ValeurAjouterUpsertWithWhereUniqueWithoutLawyerInput = {
    where: ValeurAjouterWhereUniqueInput
    update: XOR<ValeurAjouterUpdateWithoutLawyerInput, ValeurAjouterUncheckedUpdateWithoutLawyerInput>
    create: XOR<ValeurAjouterCreateWithoutLawyerInput, ValeurAjouterUncheckedCreateWithoutLawyerInput>
  }

  export type ValeurAjouterUpdateWithWhereUniqueWithoutLawyerInput = {
    where: ValeurAjouterWhereUniqueInput
    data: XOR<ValeurAjouterUpdateWithoutLawyerInput, ValeurAjouterUncheckedUpdateWithoutLawyerInput>
  }

  export type ValeurAjouterUpdateManyWithWhereWithoutLawyerInput = {
    where: ValeurAjouterScalarWhereInput
    data: XOR<ValeurAjouterUpdateManyMutationInput, ValeurAjouterUncheckedUpdateManyWithoutLawyerInput>
  }

  export type ValeurAjouterScalarWhereInput = {
    AND?: ValeurAjouterScalarWhereInput | ValeurAjouterScalarWhereInput[]
    OR?: ValeurAjouterScalarWhereInput[]
    NOT?: ValeurAjouterScalarWhereInput | ValeurAjouterScalarWhereInput[]
    id?: StringFilter<"ValeurAjouter"> | string
    userId?: StringFilter<"ValeurAjouter"> | string
    title?: StringFilter<"ValeurAjouter"> | string
    content?: StringFilter<"ValeurAjouter"> | string
    desc?: StringFilter<"ValeurAjouter"> | string
  }

  export type UserUpsertWithoutLawyerInput = {
    update: XOR<UserUpdateWithoutLawyerInput, UserUncheckedUpdateWithoutLawyerInput>
    create: XOR<UserCreateWithoutLawyerInput, UserUncheckedCreateWithoutLawyerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLawyerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLawyerInput, UserUncheckedUpdateWithoutLawyerInput>
  }

  export type UserUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type LawyerCreateWithoutConseilInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutConseilInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutConseilInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutConseilInput, LawyerUncheckedCreateWithoutConseilInput>
  }

  export type LawyerUpsertWithoutConseilInput = {
    update: XOR<LawyerUpdateWithoutConseilInput, LawyerUncheckedUpdateWithoutConseilInput>
    create: XOR<LawyerCreateWithoutConseilInput, LawyerUncheckedCreateWithoutConseilInput>
    where?: LawyerWhereInput
  }

  export type LawyerUpdateToOneWithWhereWithoutConseilInput = {
    where?: LawyerWhereInput
    data: XOR<LawyerUpdateWithoutConseilInput, LawyerUncheckedUpdateWithoutConseilInput>
  }

  export type LawyerUpdateWithoutConseilInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutConseilInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type LawyerCreateWithoutRedactionInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutRedactionInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutRedactionInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutRedactionInput, LawyerUncheckedCreateWithoutRedactionInput>
  }

  export type LawyerUpsertWithoutRedactionInput = {
    update: XOR<LawyerUpdateWithoutRedactionInput, LawyerUncheckedUpdateWithoutRedactionInput>
    create: XOR<LawyerCreateWithoutRedactionInput, LawyerUncheckedCreateWithoutRedactionInput>
    where?: LawyerWhereInput
  }

  export type LawyerUpdateToOneWithWhereWithoutRedactionInput = {
    where?: LawyerWhereInput
    data: XOR<LawyerUpdateWithoutRedactionInput, LawyerUncheckedUpdateWithoutRedactionInput>
  }

  export type LawyerUpdateWithoutRedactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutRedactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type LawyerCreateWithoutResolutionInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutResolutionInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutResolutionInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutResolutionInput, LawyerUncheckedCreateWithoutResolutionInput>
  }

  export type LawyerUpsertWithoutResolutionInput = {
    update: XOR<LawyerUpdateWithoutResolutionInput, LawyerUncheckedUpdateWithoutResolutionInput>
    create: XOR<LawyerCreateWithoutResolutionInput, LawyerUncheckedCreateWithoutResolutionInput>
    where?: LawyerWhereInput
  }

  export type LawyerUpdateToOneWithWhereWithoutResolutionInput = {
    where?: LawyerWhereInput
    data: XOR<LawyerUpdateWithoutResolutionInput, LawyerUncheckedUpdateWithoutResolutionInput>
  }

  export type LawyerUpdateWithoutResolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutResolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type LawyerCreateWithoutServicesInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutServicesInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutServicesInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutServicesInput, LawyerUncheckedCreateWithoutServicesInput>
  }

  export type LawyerUpsertWithoutServicesInput = {
    update: XOR<LawyerUpdateWithoutServicesInput, LawyerUncheckedUpdateWithoutServicesInput>
    create: XOR<LawyerCreateWithoutServicesInput, LawyerUncheckedCreateWithoutServicesInput>
    where?: LawyerWhereInput
  }

  export type LawyerUpdateToOneWithWhereWithoutServicesInput = {
    where?: LawyerWhereInput
    data: XOR<LawyerUpdateWithoutServicesInput, LawyerUncheckedUpdateWithoutServicesInput>
  }

  export type LawyerUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type LawyerCreateWithoutPreventifsInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutPreventifsInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutPreventifsInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutPreventifsInput, LawyerUncheckedCreateWithoutPreventifsInput>
  }

  export type LawyerUpsertWithoutPreventifsInput = {
    update: XOR<LawyerUpdateWithoutPreventifsInput, LawyerUncheckedUpdateWithoutPreventifsInput>
    create: XOR<LawyerCreateWithoutPreventifsInput, LawyerUncheckedCreateWithoutPreventifsInput>
    where?: LawyerWhereInput
  }

  export type LawyerUpdateToOneWithWhereWithoutPreventifsInput = {
    where?: LawyerWhereInput
    data: XOR<LawyerUpdateWithoutPreventifsInput, LawyerUncheckedUpdateWithoutPreventifsInput>
  }

  export type LawyerUpdateWithoutPreventifsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutPreventifsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type LawyerCreateWithoutValuerInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutValuerInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutValuerInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutValuerInput, LawyerUncheckedCreateWithoutValuerInput>
  }

  export type LawyerUpsertWithoutValuerInput = {
    update: XOR<LawyerUpdateWithoutValuerInput, LawyerUncheckedUpdateWithoutValuerInput>
    create: XOR<LawyerCreateWithoutValuerInput, LawyerUncheckedCreateWithoutValuerInput>
    where?: LawyerWhereInput
  }

  export type LawyerUpdateToOneWithWhereWithoutValuerInput = {
    where?: LawyerWhereInput
    data: XOR<LawyerUpdateWithoutValuerInput, LawyerUncheckedUpdateWithoutValuerInput>
  }

  export type LawyerUpdateWithoutValuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutValuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type ClientCreateWithoutFriendInput = {
    id?: string
    name: string
    profession: string
    age: number
    gender: string
    localisation: string
    notification?: ClientNotificationCreateNestedManyWithoutClientInput
    client?: ClientContactCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutFriendInput = {
    id?: string
    userId: string
    name: string
    profession: string
    age: number
    gender: string
    localisation: string
    notification?: ClientNotificationUncheckedCreateNestedManyWithoutClientInput
    client?: ClientContactUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutFriendInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutFriendInput, ClientUncheckedCreateWithoutFriendInput>
  }

  export type ClientUpsertWithoutFriendInput = {
    update: XOR<ClientUpdateWithoutFriendInput, ClientUncheckedUpdateWithoutFriendInput>
    create: XOR<ClientCreateWithoutFriendInput, ClientUncheckedCreateWithoutFriendInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutFriendInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutFriendInput, ClientUncheckedUpdateWithoutFriendInput>
  }

  export type ClientUpdateWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
    notification?: ClientNotificationUpdateManyWithoutClientNestedInput
    client?: ClientContactUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutFriendInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
    notification?: ClientNotificationUncheckedUpdateManyWithoutClientNestedInput
    client?: ClientContactUncheckedUpdateManyWithoutClientNestedInput
  }

  export type LawyerCreateWithoutFriendLawInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutFriendLawInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutFriendLawInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutFriendLawInput, LawyerUncheckedCreateWithoutFriendLawInput>
  }

  export type LawyerUpsertWithoutFriendLawInput = {
    update: XOR<LawyerUpdateWithoutFriendLawInput, LawyerUncheckedUpdateWithoutFriendLawInput>
    create: XOR<LawyerCreateWithoutFriendLawInput, LawyerUncheckedCreateWithoutFriendLawInput>
    where?: LawyerWhereInput
  }

  export type LawyerUpdateToOneWithWhereWithoutFriendLawInput = {
    where?: LawyerWhereInput
    data: XOR<LawyerUpdateWithoutFriendLawInput, LawyerUncheckedUpdateWithoutFriendLawInput>
  }

  export type LawyerUpdateWithoutFriendLawInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutFriendLawInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type LawyerCreateWithoutContratInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutContratInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutContratInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutContratInput, LawyerUncheckedCreateWithoutContratInput>
  }

  export type LawyerUpsertWithoutContratInput = {
    update: XOR<LawyerUpdateWithoutContratInput, LawyerUncheckedUpdateWithoutContratInput>
    create: XOR<LawyerCreateWithoutContratInput, LawyerUncheckedCreateWithoutContratInput>
    where?: LawyerWhereInput
  }

  export type LawyerUpdateToOneWithWhereWithoutContratInput = {
    where?: LawyerWhereInput
    data: XOR<LawyerUpdateWithoutContratInput, LawyerUncheckedUpdateWithoutContratInput>
  }

  export type LawyerUpdateWithoutContratInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutContratInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type LawyerCreateWithoutNotificationInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutNotificationInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutNotificationInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutNotificationInput, LawyerUncheckedCreateWithoutNotificationInput>
  }

  export type LawyerUpsertWithoutNotificationInput = {
    update: XOR<LawyerUpdateWithoutNotificationInput, LawyerUncheckedUpdateWithoutNotificationInput>
    create: XOR<LawyerCreateWithoutNotificationInput, LawyerUncheckedCreateWithoutNotificationInput>
    where?: LawyerWhereInput
  }

  export type LawyerUpdateToOneWithWhereWithoutNotificationInput = {
    where?: LawyerWhereInput
    data: XOR<LawyerUpdateWithoutNotificationInput, LawyerUncheckedUpdateWithoutNotificationInput>
  }

  export type LawyerUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type ClientCreateWithoutNotificationInput = {
    id?: string
    name: string
    profession: string
    age: number
    gender: string
    localisation: string
    friend?: FriendsCreateNestedManyWithoutClientInput
    client?: ClientContactCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutNotificationInput = {
    id?: string
    userId: string
    name: string
    profession: string
    age: number
    gender: string
    localisation: string
    friend?: FriendsUncheckedCreateNestedManyWithoutClientInput
    client?: ClientContactUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutNotificationInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutNotificationInput, ClientUncheckedCreateWithoutNotificationInput>
  }

  export type ClientUpsertWithoutNotificationInput = {
    update: XOR<ClientUpdateWithoutNotificationInput, ClientUncheckedUpdateWithoutNotificationInput>
    create: XOR<ClientCreateWithoutNotificationInput, ClientUncheckedCreateWithoutNotificationInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutNotificationInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutNotificationInput, ClientUncheckedUpdateWithoutNotificationInput>
  }

  export type ClientUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
    friend?: FriendsUpdateManyWithoutClientNestedInput
    client?: ClientContactUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
    friend?: FriendsUncheckedUpdateManyWithoutClientNestedInput
    client?: ClientContactUncheckedUpdateManyWithoutClientNestedInput
  }

  export type LawyerCreateWithoutContactInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutContactInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutContactInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutContactInput, LawyerUncheckedCreateWithoutContactInput>
  }

  export type LawyerUpsertWithoutContactInput = {
    update: XOR<LawyerUpdateWithoutContactInput, LawyerUncheckedUpdateWithoutContactInput>
    create: XOR<LawyerCreateWithoutContactInput, LawyerUncheckedCreateWithoutContactInput>
    where?: LawyerWhereInput
  }

  export type LawyerUpdateToOneWithWhereWithoutContactInput = {
    where?: LawyerWhereInput
    data: XOR<LawyerUpdateWithoutContactInput, LawyerUncheckedUpdateWithoutContactInput>
  }

  export type LawyerUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type ClientCreateWithoutClientInput = {
    id?: string
    name: string
    profession: string
    age: number
    gender: string
    localisation: string
    friend?: FriendsCreateNestedManyWithoutClientInput
    notification?: ClientNotificationCreateNestedManyWithoutClientInput
    user: UserCreateNestedOneWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutClientInput = {
    id?: string
    userId: string
    name: string
    profession: string
    age: number
    gender: string
    localisation: string
    friend?: FriendsUncheckedCreateNestedManyWithoutClientInput
    notification?: ClientNotificationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutClientInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClientInput, ClientUncheckedCreateWithoutClientInput>
  }

  export type ClientUpsertWithoutClientInput = {
    update: XOR<ClientUpdateWithoutClientInput, ClientUncheckedUpdateWithoutClientInput>
    create: XOR<ClientCreateWithoutClientInput, ClientUncheckedCreateWithoutClientInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClientInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClientInput, ClientUncheckedUpdateWithoutClientInput>
  }

  export type ClientUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
    friend?: FriendsUpdateManyWithoutClientNestedInput
    notification?: ClientNotificationUpdateManyWithoutClientNestedInput
    user?: UserUpdateOneRequiredWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
    friend?: FriendsUncheckedUpdateManyWithoutClientNestedInput
    notification?: ClientNotificationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type LawyerCreateWithoutDiplomeInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutDiplomeInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutDiplomeInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutDiplomeInput, LawyerUncheckedCreateWithoutDiplomeInput>
  }

  export type LawyerUpsertWithoutDiplomeInput = {
    update: XOR<LawyerUpdateWithoutDiplomeInput, LawyerUncheckedUpdateWithoutDiplomeInput>
    create: XOR<LawyerCreateWithoutDiplomeInput, LawyerUncheckedCreateWithoutDiplomeInput>
    where?: LawyerWhereInput
  }

  export type LawyerUpdateToOneWithWhereWithoutDiplomeInput = {
    where?: LawyerWhereInput
    data: XOR<LawyerUpdateWithoutDiplomeInput, LawyerUncheckedUpdateWithoutDiplomeInput>
  }

  export type LawyerUpdateWithoutDiplomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutDiplomeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type LawyerCreateWithoutExperienceInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    calendar?: CalendarCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutExperienceInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    calendar?: CalendarUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutExperienceInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutExperienceInput, LawyerUncheckedCreateWithoutExperienceInput>
  }

  export type LawyerUpsertWithoutExperienceInput = {
    update: XOR<LawyerUpdateWithoutExperienceInput, LawyerUncheckedUpdateWithoutExperienceInput>
    create: XOR<LawyerCreateWithoutExperienceInput, LawyerUncheckedCreateWithoutExperienceInput>
    where?: LawyerWhereInput
  }

  export type LawyerUpdateToOneWithWhereWithoutExperienceInput = {
    where?: LawyerWhereInput
    data: XOR<LawyerUpdateWithoutExperienceInput, LawyerUncheckedUpdateWithoutExperienceInput>
  }

  export type LawyerUpdateWithoutExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutExperienceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type LawyerCreateWithoutCalendarInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeCreateNestedManyWithoutLawyerInput
    experience?: ExperienceCreateNestedManyWithoutLawyerInput
    Notification?: NotificationCreateNestedManyWithoutLawyerInput
    contrat?: ContratCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawCreateNestedManyWithoutLawyerInput
    contact?: ContactCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueCreateNestedManyWithoutLawyerInput
    redaction?: RedactionCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterCreateNestedManyWithoutLawyerInput
    user?: UserCreateNestedOneWithoutLawyerInput
  }

  export type LawyerUncheckedCreateWithoutCalendarInput = {
    id?: string
    userId: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
    diplome?: DiplomeUncheckedCreateNestedManyWithoutLawyerInput
    experience?: ExperienceUncheckedCreateNestedManyWithoutLawyerInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutLawyerInput
    contrat?: ContratUncheckedCreateNestedManyWithoutLawyerInput
    friendLaw?: FriendLawUncheckedCreateNestedManyWithoutLawyerInput
    contact?: ContactUncheckedCreateNestedManyWithoutLawyerInput
    conseil?: ConseilJuridiqueUncheckedCreateNestedManyWithoutLawyerInput
    redaction?: RedactionUncheckedCreateNestedManyWithoutLawyerInput
    resolution?: ResolutionLitigeUncheckedCreateNestedManyWithoutLawyerInput
    services?: ServiceParDomaineUncheckedCreateNestedManyWithoutLawyerInput
    preventifs?: PreventifsUncheckedCreateNestedManyWithoutLawyerInput
    valuer?: ValeurAjouterUncheckedCreateNestedManyWithoutLawyerInput
  }

  export type LawyerCreateOrConnectWithoutCalendarInput = {
    where: LawyerWhereUniqueInput
    create: XOR<LawyerCreateWithoutCalendarInput, LawyerUncheckedCreateWithoutCalendarInput>
  }

  export type LawyerUpsertWithoutCalendarInput = {
    update: XOR<LawyerUpdateWithoutCalendarInput, LawyerUncheckedUpdateWithoutCalendarInput>
    create: XOR<LawyerCreateWithoutCalendarInput, LawyerUncheckedCreateWithoutCalendarInput>
    where?: LawyerWhereInput
  }

  export type LawyerUpdateToOneWithWhereWithoutCalendarInput = {
    where?: LawyerWhereInput
    data: XOR<LawyerUpdateWithoutCalendarInput, LawyerUncheckedUpdateWithoutCalendarInput>
  }

  export type LawyerUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
    user?: UserUpdateOneWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutCalendarInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    password: string
    role: string
    emailVerified?: Date | string | null
    image?: string | null
    client?: ClientCreateNestedManyWithoutUserInput
    lawyer?: LawyerCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    password: string
    role: string
    emailVerified?: Date | string | null
    image?: string | null
    client?: ClientUncheckedCreateNestedManyWithoutUserInput
    lawyer?: LawyerUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateManyWithoutUserNestedInput
    lawyer?: LawyerUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUncheckedUpdateManyWithoutUserNestedInput
    lawyer?: LawyerUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    password: string
    role: string
    emailVerified?: Date | string | null
    image?: string | null
    client?: ClientCreateNestedManyWithoutUserInput
    lawyer?: LawyerCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    password: string
    role: string
    emailVerified?: Date | string | null
    image?: string | null
    client?: ClientUncheckedCreateNestedManyWithoutUserInput
    lawyer?: LawyerUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateManyWithoutUserNestedInput
    lawyer?: LawyerUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUncheckedUpdateManyWithoutUserNestedInput
    lawyer?: LawyerUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutPostsInput = {
    id?: string
    email: string
    password: string
    role: string
    emailVerified?: Date | string | null
    image?: string | null
    client?: ClientCreateNestedManyWithoutUserInput
    lawyer?: LawyerCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: string
    email: string
    password: string
    role: string
    emailVerified?: Date | string | null
    image?: string | null
    client?: ClientUncheckedCreateNestedManyWithoutUserInput
    lawyer?: LawyerUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateManyWithoutUserNestedInput
    lawyer?: LawyerUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUncheckedUpdateManyWithoutUserNestedInput
    lawyer?: LawyerUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClientCreateManyUserInput = {
    id?: string
    name: string
    profession: string
    age: number
    gender: string
    localisation: string
  }

  export type LawyerCreateManyUserInput = {
    id?: string
    name?: string | null
    age?: number | null
    localisation?: string | null
    budget?: string | null
    gender?: string | null
    specialité?: string | null
    Star?: number | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    refresh_token_expires_in?: number | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type PostCreateManyCreatedByInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
    friend?: FriendsUpdateManyWithoutClientNestedInput
    notification?: ClientNotificationUpdateManyWithoutClientNestedInput
    client?: ClientContactUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
    friend?: FriendsUncheckedUpdateManyWithoutClientNestedInput
    notification?: ClientNotificationUncheckedUpdateManyWithoutClientNestedInput
    client?: ClientContactUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profession?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    localisation?: StringFieldUpdateOperationsInput | string
  }

  export type LawyerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUpdateManyWithoutLawyerNestedInput
    contact?: ContactUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUpdateManyWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
    diplome?: DiplomeUncheckedUpdateManyWithoutLawyerNestedInput
    experience?: ExperienceUncheckedUpdateManyWithoutLawyerNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutLawyerNestedInput
    contrat?: ContratUncheckedUpdateManyWithoutLawyerNestedInput
    calendar?: CalendarUncheckedUpdateManyWithoutLawyerNestedInput
    friendLaw?: FriendLawUncheckedUpdateManyWithoutLawyerNestedInput
    contact?: ContactUncheckedUpdateManyWithoutLawyerNestedInput
    conseil?: ConseilJuridiqueUncheckedUpdateManyWithoutLawyerNestedInput
    redaction?: RedactionUncheckedUpdateManyWithoutLawyerNestedInput
    resolution?: ResolutionLitigeUncheckedUpdateManyWithoutLawyerNestedInput
    services?: ServiceParDomaineUncheckedUpdateManyWithoutLawyerNestedInput
    preventifs?: PreventifsUncheckedUpdateManyWithoutLawyerNestedInput
    valuer?: ValeurAjouterUncheckedUpdateManyWithoutLawyerNestedInput
  }

  export type LawyerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    specialité?: NullableStringFieldUpdateOperationsInput | string | null
    Star?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutCreatedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendsCreateManyClientInput = {
    id?: string
    name: string
    nbrDeContrat: string
    key: string
  }

  export type ClientNotificationCreateManyClientInput = {
    id?: string
    content?: string | null
    TimeToReceive?: Date | string | null
    vue?: boolean | null
    type: string
    key: string
  }

  export type ClientContactCreateManyClientInput = {
    id?: string
    name: string
    contenu: string
    date?: Date | string
    key: string
  }

  export type FriendsUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type FriendsUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type FriendsUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ClientNotificationUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ClientNotificationUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ClientNotificationUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ClientContactUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ClientContactUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ClientContactUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type DiplomeCreateManyLawyerInput = {
    id?: string
    ecole: string
    anne: string
    nom: string
  }

  export type ExperienceCreateManyLawyerInput = {
    id?: string
    poste: string
    durant: string
  }

  export type NotificationCreateManyLawyerInput = {
    id?: string
    content?: string | null
    TimeToReceive?: Date | string | null
    vue?: boolean | null
    type: string
    key?: string | null
  }

  export type ContratCreateManyLawyerInput = {
    id?: string
    type?: string | null
    date?: Date | string | null
    content?: string | null
  }

  export type CalendarCreateManyLawyerInput = {
    id?: string
    client: string
    moment: Date | string
  }

  export type FriendLawCreateManyLawyerInput = {
    id?: string
    name: string
    nbrDeContrat: string
    key: string
  }

  export type ContactCreateManyLawyerInput = {
    id?: string
    name: string
    contenu: string
    date?: Date | string
    key: string
  }

  export type ConseilJuridiqueCreateManyLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type RedactionCreateManyLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type ResolutionLitigeCreateManyLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type ServiceParDomaineCreateManyLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type PreventifsCreateManyLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type ValeurAjouterCreateManyLawyerInput = {
    id?: string
    title: string
    content: string
    desc: string
  }

  export type DiplomeUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ecole?: StringFieldUpdateOperationsInput | string
    anne?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type DiplomeUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ecole?: StringFieldUpdateOperationsInput | string
    anne?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type DiplomeUncheckedUpdateManyWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ecole?: StringFieldUpdateOperationsInput | string
    anne?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
  }

  export type ExperienceUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    durant?: StringFieldUpdateOperationsInput | string
  }

  export type ExperienceUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    durant?: StringFieldUpdateOperationsInput | string
  }

  export type ExperienceUncheckedUpdateManyWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    poste?: StringFieldUpdateOperationsInput | string
    durant?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    TimeToReceive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vue?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContratUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContratUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContratUncheckedUpdateManyWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CalendarUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    moment?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    moment?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarUncheckedUpdateManyWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    client?: StringFieldUpdateOperationsInput | string
    moment?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendLawUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type FriendLawUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type FriendLawUncheckedUpdateManyWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nbrDeContrat?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUncheckedUpdateManyWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    key?: StringFieldUpdateOperationsInput | string
  }

  export type ConseilJuridiqueUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ConseilJuridiqueUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ConseilJuridiqueUncheckedUpdateManyWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type RedactionUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type RedactionUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type RedactionUncheckedUpdateManyWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ResolutionLitigeUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ResolutionLitigeUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ResolutionLitigeUncheckedUpdateManyWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceParDomaineUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceParDomaineUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceParDomaineUncheckedUpdateManyWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type PreventifsUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type PreventifsUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type PreventifsUncheckedUpdateManyWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ValeurAjouterUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ValeurAjouterUncheckedUpdateWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }

  export type ValeurAjouterUncheckedUpdateManyWithoutLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}